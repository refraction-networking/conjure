// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: signalling.proto

// TODO: We're using proto2 because it's the default on Ubuntu 16.04.
// At some point we will want to migrate to proto3, but we are not
// using any proto3 features yet.

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type KeyType int32

const (
	KeyType_AES_GCM_128 KeyType = 90
	KeyType_AES_GCM_256 KeyType = 91 // not supported atm
)

// Enum value maps for KeyType.
var (
	KeyType_name = map[int32]string{
		90: "AES_GCM_128",
		91: "AES_GCM_256",
	}
	KeyType_value = map[string]int32{
		"AES_GCM_128": 90,
		"AES_GCM_256": 91,
	}
)

func (x KeyType) Enum() *KeyType {
	p := new(KeyType)
	*p = x
	return p
}

func (x KeyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyType) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[0].Descriptor()
}

func (KeyType) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[0]
}

func (x KeyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *KeyType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = KeyType(num)
	return nil
}

// Deprecated: Use KeyType.Descriptor instead.
func (KeyType) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{0}
}

type DnsRegMethod int32

const (
	DnsRegMethod_UDP DnsRegMethod = 1
	DnsRegMethod_DOT DnsRegMethod = 2
	DnsRegMethod_DOH DnsRegMethod = 3
)

// Enum value maps for DnsRegMethod.
var (
	DnsRegMethod_name = map[int32]string{
		1: "UDP",
		2: "DOT",
		3: "DOH",
	}
	DnsRegMethod_value = map[string]int32{
		"UDP": 1,
		"DOT": 2,
		"DOH": 3,
	}
)

func (x DnsRegMethod) Enum() *DnsRegMethod {
	p := new(DnsRegMethod)
	*p = x
	return p
}

func (x DnsRegMethod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DnsRegMethod) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[1].Descriptor()
}

func (DnsRegMethod) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[1]
}

func (x DnsRegMethod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *DnsRegMethod) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = DnsRegMethod(num)
	return nil
}

// Deprecated: Use DnsRegMethod.Descriptor instead.
func (DnsRegMethod) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{1}
}

// State transitions of the client
type C2S_Transition int32

const (
	C2S_Transition_C2S_NO_CHANGE                C2S_Transition = 0
	C2S_Transition_C2S_SESSION_INIT             C2S_Transition = 1  // connect me to squid
	C2S_Transition_C2S_SESSION_COVERT_INIT      C2S_Transition = 11 // connect me to provided covert
	C2S_Transition_C2S_EXPECT_RECONNECT         C2S_Transition = 2
	C2S_Transition_C2S_SESSION_CLOSE            C2S_Transition = 3
	C2S_Transition_C2S_YIELD_UPLOAD             C2S_Transition = 4
	C2S_Transition_C2S_ACQUIRE_UPLOAD           C2S_Transition = 5
	C2S_Transition_C2S_EXPECT_UPLOADONLY_RECONN C2S_Transition = 6
	C2S_Transition_C2S_ERROR                    C2S_Transition = 255
)

// Enum value maps for C2S_Transition.
var (
	C2S_Transition_name = map[int32]string{
		0:   "C2S_NO_CHANGE",
		1:   "C2S_SESSION_INIT",
		11:  "C2S_SESSION_COVERT_INIT",
		2:   "C2S_EXPECT_RECONNECT",
		3:   "C2S_SESSION_CLOSE",
		4:   "C2S_YIELD_UPLOAD",
		5:   "C2S_ACQUIRE_UPLOAD",
		6:   "C2S_EXPECT_UPLOADONLY_RECONN",
		255: "C2S_ERROR",
	}
	C2S_Transition_value = map[string]int32{
		"C2S_NO_CHANGE":                0,
		"C2S_SESSION_INIT":             1,
		"C2S_SESSION_COVERT_INIT":      11,
		"C2S_EXPECT_RECONNECT":         2,
		"C2S_SESSION_CLOSE":            3,
		"C2S_YIELD_UPLOAD":             4,
		"C2S_ACQUIRE_UPLOAD":           5,
		"C2S_EXPECT_UPLOADONLY_RECONN": 6,
		"C2S_ERROR":                    255,
	}
)

func (x C2S_Transition) Enum() *C2S_Transition {
	p := new(C2S_Transition)
	*p = x
	return p
}

func (x C2S_Transition) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (C2S_Transition) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[2].Descriptor()
}

func (C2S_Transition) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[2]
}

func (x C2S_Transition) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *C2S_Transition) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = C2S_Transition(num)
	return nil
}

// Deprecated: Use C2S_Transition.Descriptor instead.
func (C2S_Transition) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{2}
}

// State transitions of the server
type S2C_Transition int32

const (
	S2C_Transition_S2C_NO_CHANGE           S2C_Transition = 0
	S2C_Transition_S2C_SESSION_INIT        S2C_Transition = 1  // connected to squid
	S2C_Transition_S2C_SESSION_COVERT_INIT S2C_Transition = 11 // connected to covert host
	S2C_Transition_S2C_CONFIRM_RECONNECT   S2C_Transition = 2
	S2C_Transition_S2C_SESSION_CLOSE       S2C_Transition = 3
	// TODO should probably also allow EXPECT_RECONNECT here, for DittoTap
	S2C_Transition_S2C_ERROR S2C_Transition = 255
)

// Enum value maps for S2C_Transition.
var (
	S2C_Transition_name = map[int32]string{
		0:   "S2C_NO_CHANGE",
		1:   "S2C_SESSION_INIT",
		11:  "S2C_SESSION_COVERT_INIT",
		2:   "S2C_CONFIRM_RECONNECT",
		3:   "S2C_SESSION_CLOSE",
		255: "S2C_ERROR",
	}
	S2C_Transition_value = map[string]int32{
		"S2C_NO_CHANGE":           0,
		"S2C_SESSION_INIT":        1,
		"S2C_SESSION_COVERT_INIT": 11,
		"S2C_CONFIRM_RECONNECT":   2,
		"S2C_SESSION_CLOSE":       3,
		"S2C_ERROR":               255,
	}
)

func (x S2C_Transition) Enum() *S2C_Transition {
	p := new(S2C_Transition)
	*p = x
	return p
}

func (x S2C_Transition) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (S2C_Transition) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[3].Descriptor()
}

func (S2C_Transition) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[3]
}

func (x S2C_Transition) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *S2C_Transition) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = S2C_Transition(num)
	return nil
}

// Deprecated: Use S2C_Transition.Descriptor instead.
func (S2C_Transition) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{3}
}

// Should accompany all S2C_ERROR messages.
type ErrorReasonS2C int32

const (
	ErrorReasonS2C_NO_ERROR         ErrorReasonS2C = 0
	ErrorReasonS2C_COVERT_STREAM    ErrorReasonS2C = 1   // Squid TCP connection broke
	ErrorReasonS2C_CLIENT_REPORTED  ErrorReasonS2C = 2   // You told me something was wrong, client
	ErrorReasonS2C_CLIENT_PROTOCOL  ErrorReasonS2C = 3   // You messed up, client (e.g. sent a bad protobuf)
	ErrorReasonS2C_STATION_INTERNAL ErrorReasonS2C = 4   // I broke
	ErrorReasonS2C_DECOY_OVERLOAD   ErrorReasonS2C = 5   // Everything's fine, but don't use this decoy right now
	ErrorReasonS2C_CLIENT_STREAM    ErrorReasonS2C = 100 // My stream to you broke. (This is impossible to send)
	ErrorReasonS2C_CLIENT_TIMEOUT   ErrorReasonS2C = 101 // You never came back. (This is impossible to send)
)

// Enum value maps for ErrorReasonS2C.
var (
	ErrorReasonS2C_name = map[int32]string{
		0:   "NO_ERROR",
		1:   "COVERT_STREAM",
		2:   "CLIENT_REPORTED",
		3:   "CLIENT_PROTOCOL",
		4:   "STATION_INTERNAL",
		5:   "DECOY_OVERLOAD",
		100: "CLIENT_STREAM",
		101: "CLIENT_TIMEOUT",
	}
	ErrorReasonS2C_value = map[string]int32{
		"NO_ERROR":         0,
		"COVERT_STREAM":    1,
		"CLIENT_REPORTED":  2,
		"CLIENT_PROTOCOL":  3,
		"STATION_INTERNAL": 4,
		"DECOY_OVERLOAD":   5,
		"CLIENT_STREAM":    100,
		"CLIENT_TIMEOUT":   101,
	}
)

func (x ErrorReasonS2C) Enum() *ErrorReasonS2C {
	p := new(ErrorReasonS2C)
	*p = x
	return p
}

func (x ErrorReasonS2C) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ErrorReasonS2C) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[4].Descriptor()
}

func (ErrorReasonS2C) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[4]
}

func (x ErrorReasonS2C) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *ErrorReasonS2C) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = ErrorReasonS2C(num)
	return nil
}

// Deprecated: Use ErrorReasonS2C.Descriptor instead.
func (ErrorReasonS2C) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{4}
}

type TransportType int32

const (
	TransportType_Null   TransportType = 0
	TransportType_Min    TransportType = 1 // Send a 32-byte HMAC id to let the station distinguish registrations to same host
	TransportType_Obfs4  TransportType = 2
	TransportType_DTLS   TransportType = 3  // UDP transport: DTLS
	TransportType_Prefix TransportType = 4  // dynamic prefix transport (and updated Min)
	TransportType_uTLS   TransportType = 5  // uTLS based transport
	TransportType_Format TransportType = 6  // Formatting transport - format first, format all
	TransportType_WASM   TransportType = 7  // WebAssembly
	TransportType_FTE    TransportType = 8  // Format transforming encryption
	TransportType_Quic   TransportType = 9  // quic transport?
	TransportType_Webrtc TransportType = 99 // UDP transport: WebRTC DataChannel
)

// Enum value maps for TransportType.
var (
	TransportType_name = map[int32]string{
		0:  "Null",
		1:  "Min",
		2:  "Obfs4",
		3:  "DTLS",
		4:  "Prefix",
		5:  "uTLS",
		6:  "Format",
		7:  "WASM",
		8:  "FTE",
		9:  "Quic",
		99: "Webrtc",
	}
	TransportType_value = map[string]int32{
		"Null":   0,
		"Min":    1,
		"Obfs4":  2,
		"DTLS":   3,
		"Prefix": 4,
		"uTLS":   5,
		"Format": 6,
		"WASM":   7,
		"FTE":    8,
		"Quic":   9,
		"Webrtc": 99,
	}
)

func (x TransportType) Enum() *TransportType {
	p := new(TransportType)
	*p = x
	return p
}

func (x TransportType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransportType) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[5].Descriptor()
}

func (TransportType) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[5]
}

func (x TransportType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *TransportType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = TransportType(num)
	return nil
}

// Deprecated: Use TransportType.Descriptor instead.
func (TransportType) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{5}
}

type RegistrationSource int32

const (
	RegistrationSource_Unspecified      RegistrationSource = 0
	RegistrationSource_Detector         RegistrationSource = 1
	RegistrationSource_API              RegistrationSource = 2
	RegistrationSource_DetectorPrescan  RegistrationSource = 3
	RegistrationSource_BidirectionalAPI RegistrationSource = 4
	RegistrationSource_DNS              RegistrationSource = 5
	RegistrationSource_BidirectionalDNS RegistrationSource = 6
	RegistrationSource_AMPCache         RegistrationSource = 7
	RegistrationSource_BidirectionalAMP RegistrationSource = 8
)

// Enum value maps for RegistrationSource.
var (
	RegistrationSource_name = map[int32]string{
		0: "Unspecified",
		1: "Detector",
		2: "API",
		3: "DetectorPrescan",
		4: "BidirectionalAPI",
		5: "DNS",
		6: "BidirectionalDNS",
		7: "AMPCache",
		8: "BidirectionalAMP",
	}
	RegistrationSource_value = map[string]int32{
		"Unspecified":      0,
		"Detector":         1,
		"API":              2,
		"DetectorPrescan":  3,
		"BidirectionalAPI": 4,
		"DNS":              5,
		"BidirectionalDNS": 6,
		"AMPCache":         7,
		"BidirectionalAMP": 8,
	}
)

func (x RegistrationSource) Enum() *RegistrationSource {
	p := new(RegistrationSource)
	*p = x
	return p
}

func (x RegistrationSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RegistrationSource) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[6].Descriptor()
}

func (RegistrationSource) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[6]
}

func (x RegistrationSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *RegistrationSource) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = RegistrationSource(num)
	return nil
}

// Deprecated: Use RegistrationSource.Descriptor instead.
func (RegistrationSource) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{6}
}

type StationOperations int32

const (
	StationOperations_Unknown StationOperations = 0
	StationOperations_New     StationOperations = 1
	StationOperations_Update  StationOperations = 2
	StationOperations_Clear   StationOperations = 3
)

// Enum value maps for StationOperations.
var (
	StationOperations_name = map[int32]string{
		0: "Unknown",
		1: "New",
		2: "Update",
		3: "Clear",
	}
	StationOperations_value = map[string]int32{
		"Unknown": 0,
		"New":     1,
		"Update":  2,
		"Clear":   3,
	}
)

func (x StationOperations) Enum() *StationOperations {
	p := new(StationOperations)
	*p = x
	return p
}

func (x StationOperations) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StationOperations) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[7].Descriptor()
}

func (StationOperations) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[7]
}

func (x StationOperations) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *StationOperations) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = StationOperations(num)
	return nil
}

// Deprecated: Use StationOperations.Descriptor instead.
func (StationOperations) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{7}
}

type IPProto int32

const (
	IPProto_Unk IPProto = 0
	IPProto_Tcp IPProto = 1
	IPProto_Udp IPProto = 2
)

// Enum value maps for IPProto.
var (
	IPProto_name = map[int32]string{
		0: "Unk",
		1: "Tcp",
		2: "Udp",
	}
	IPProto_value = map[string]int32{
		"Unk": 0,
		"Tcp": 1,
		"Udp": 2,
	}
)

func (x IPProto) Enum() *IPProto {
	p := new(IPProto)
	*p = x
	return p
}

func (x IPProto) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IPProto) Descriptor() protoreflect.EnumDescriptor {
	return file_signalling_proto_enumTypes[8].Descriptor()
}

func (IPProto) Type() protoreflect.EnumType {
	return &file_signalling_proto_enumTypes[8]
}

func (x IPProto) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *IPProto) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = IPProto(num)
	return nil
}

// Deprecated: Use IPProto.Descriptor instead.
func (IPProto) EnumDescriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{8}
}

type PubKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A public key, as used by the station.
	Key           []byte   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Type          *KeyType `protobuf:"varint,2,opt,name=type,enum=proto.KeyType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubKey) Reset() {
	*x = PubKey{}
	mi := &file_signalling_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubKey) ProtoMessage() {}

func (x *PubKey) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubKey.ProtoReflect.Descriptor instead.
func (*PubKey) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{0}
}

func (x *PubKey) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *PubKey) GetType() KeyType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return KeyType_AES_GCM_128
}

type TLSDecoySpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hostname/SNI to use for this host
	//
	// The hostname is the only required field, although other
	// fields are expected to be present in most cases.
	Hostname *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	// The 32-bit ipv4 address, in network byte order
	//
	// If the IPv4 address is absent, then it may be resolved via
	// DNS by the client, or the client may discard this decoy spec
	// if local DNS is untrusted, or the service may be multihomed.
	Ipv4Addr *uint32 `protobuf:"fixed32,2,opt,name=ipv4addr" json:"ipv4addr,omitempty"`
	// The 128-bit ipv6 address, in network byte order
	Ipv6Addr []byte `protobuf:"bytes,6,opt,name=ipv6addr" json:"ipv6addr,omitempty"`
	// The Tapdance station public key to use when contacting this
	// decoy
	//
	// If omitted, the default station public key (if any) is used.
	Pubkey *PubKey `protobuf:"bytes,3,opt,name=pubkey" json:"pubkey,omitempty"`
	// The maximum duration, in milliseconds, to maintain an open
	// connection to this decoy (because the decoy may close the
	// connection itself after this length of time)
	//
	// If omitted, a default of 30,000 milliseconds is assumed.
	Timeout *uint32 `protobuf:"varint,4,opt,name=timeout" json:"timeout,omitempty"`
	// The maximum TCP window size to attempt to use for this decoy.
	//
	// If omitted, a default of 15360 is assumed.
	//
	// TODO: the default is based on the current heuristic of only
	// using decoys that permit windows of 15KB or larger.  If this
	// heuristic changes, then this default doesn't make sense.
	Tcpwin        *uint32 `protobuf:"varint,5,opt,name=tcpwin" json:"tcpwin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TLSDecoySpec) Reset() {
	*x = TLSDecoySpec{}
	mi := &file_signalling_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TLSDecoySpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TLSDecoySpec) ProtoMessage() {}

func (x *TLSDecoySpec) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TLSDecoySpec.ProtoReflect.Descriptor instead.
func (*TLSDecoySpec) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{1}
}

func (x *TLSDecoySpec) GetHostname() string {
	if x != nil && x.Hostname != nil {
		return *x.Hostname
	}
	return ""
}

func (x *TLSDecoySpec) GetIpv4Addr() uint32 {
	if x != nil && x.Ipv4Addr != nil {
		return *x.Ipv4Addr
	}
	return 0
}

func (x *TLSDecoySpec) GetIpv6Addr() []byte {
	if x != nil {
		return x.Ipv6Addr
	}
	return nil
}

func (x *TLSDecoySpec) GetPubkey() *PubKey {
	if x != nil {
		return x.Pubkey
	}
	return nil
}

func (x *TLSDecoySpec) GetTimeout() uint32 {
	if x != nil && x.Timeout != nil {
		return *x.Timeout
	}
	return 0
}

func (x *TLSDecoySpec) GetTcpwin() uint32 {
	if x != nil && x.Tcpwin != nil {
		return *x.Tcpwin
	}
	return 0
}

type ClientConf struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	DecoyList          *DecoyList             `protobuf:"bytes,1,opt,name=decoy_list,json=decoyList" json:"decoy_list,omitempty"`
	Generation         *uint32                `protobuf:"varint,2,opt,name=generation" json:"generation,omitempty"`
	DefaultPubkey      *PubKey                `protobuf:"bytes,3,opt,name=default_pubkey,json=defaultPubkey" json:"default_pubkey,omitempty"`
	PhantomSubnetsList *PhantomSubnetsList    `protobuf:"bytes,4,opt,name=phantom_subnets_list,json=phantomSubnetsList" json:"phantom_subnets_list,omitempty"`
	ConjurePubkey      *PubKey                `protobuf:"bytes,5,opt,name=conjure_pubkey,json=conjurePubkey" json:"conjure_pubkey,omitempty"`
	DnsRegConf         *DnsRegConf            `protobuf:"bytes,6,opt,name=dns_reg_conf,json=dnsRegConf" json:"dns_reg_conf,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ClientConf) Reset() {
	*x = ClientConf{}
	mi := &file_signalling_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientConf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientConf) ProtoMessage() {}

func (x *ClientConf) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientConf.ProtoReflect.Descriptor instead.
func (*ClientConf) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{2}
}

func (x *ClientConf) GetDecoyList() *DecoyList {
	if x != nil {
		return x.DecoyList
	}
	return nil
}

func (x *ClientConf) GetGeneration() uint32 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *ClientConf) GetDefaultPubkey() *PubKey {
	if x != nil {
		return x.DefaultPubkey
	}
	return nil
}

func (x *ClientConf) GetPhantomSubnetsList() *PhantomSubnetsList {
	if x != nil {
		return x.PhantomSubnetsList
	}
	return nil
}

func (x *ClientConf) GetConjurePubkey() *PubKey {
	if x != nil {
		return x.ConjurePubkey
	}
	return nil
}

func (x *ClientConf) GetDnsRegConf() *DnsRegConf {
	if x != nil {
		return x.DnsRegConf
	}
	return nil
}

// Configuration for DNS registrar
type DnsRegConf struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	DnsRegMethod     *DnsRegMethod          `protobuf:"varint,1,req,name=dns_reg_method,json=dnsRegMethod,enum=proto.DnsRegMethod" json:"dns_reg_method,omitempty"`
	Target           *string                `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	Domain           *string                `protobuf:"bytes,3,req,name=domain" json:"domain,omitempty"`
	Pubkey           []byte                 `protobuf:"bytes,4,opt,name=pubkey" json:"pubkey,omitempty"`
	UtlsDistribution *string                `protobuf:"bytes,5,opt,name=utls_distribution,json=utlsDistribution" json:"utls_distribution,omitempty"`
	StunServer       *string                `protobuf:"bytes,6,opt,name=stun_server,json=stunServer" json:"stun_server,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DnsRegConf) Reset() {
	*x = DnsRegConf{}
	mi := &file_signalling_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DnsRegConf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DnsRegConf) ProtoMessage() {}

func (x *DnsRegConf) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DnsRegConf.ProtoReflect.Descriptor instead.
func (*DnsRegConf) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{3}
}

func (x *DnsRegConf) GetDnsRegMethod() DnsRegMethod {
	if x != nil && x.DnsRegMethod != nil {
		return *x.DnsRegMethod
	}
	return DnsRegMethod_UDP
}

func (x *DnsRegConf) GetTarget() string {
	if x != nil && x.Target != nil {
		return *x.Target
	}
	return ""
}

func (x *DnsRegConf) GetDomain() string {
	if x != nil && x.Domain != nil {
		return *x.Domain
	}
	return ""
}

func (x *DnsRegConf) GetPubkey() []byte {
	if x != nil {
		return x.Pubkey
	}
	return nil
}

func (x *DnsRegConf) GetUtlsDistribution() string {
	if x != nil && x.UtlsDistribution != nil {
		return *x.UtlsDistribution
	}
	return ""
}

func (x *DnsRegConf) GetStunServer() string {
	if x != nil && x.StunServer != nil {
		return *x.StunServer
	}
	return ""
}

type DecoyList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TlsDecoys     []*TLSDecoySpec        `protobuf:"bytes,1,rep,name=tls_decoys,json=tlsDecoys" json:"tls_decoys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DecoyList) Reset() {
	*x = DecoyList{}
	mi := &file_signalling_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DecoyList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DecoyList) ProtoMessage() {}

func (x *DecoyList) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DecoyList.ProtoReflect.Descriptor instead.
func (*DecoyList) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{4}
}

func (x *DecoyList) GetTlsDecoys() []*TLSDecoySpec {
	if x != nil {
		return x.TlsDecoys
	}
	return nil
}

type PhantomSubnetsList struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	WeightedSubnets []*PhantomSubnets      `protobuf:"bytes,1,rep,name=weighted_subnets,json=weightedSubnets" json:"weighted_subnets,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PhantomSubnetsList) Reset() {
	*x = PhantomSubnetsList{}
	mi := &file_signalling_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PhantomSubnetsList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhantomSubnetsList) ProtoMessage() {}

func (x *PhantomSubnetsList) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhantomSubnetsList.ProtoReflect.Descriptor instead.
func (*PhantomSubnetsList) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{5}
}

func (x *PhantomSubnetsList) GetWeightedSubnets() []*PhantomSubnets {
	if x != nil {
		return x.WeightedSubnets
	}
	return nil
}

type PhantomSubnets struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Weight           *uint32                `protobuf:"varint,1,opt,name=weight" json:"weight,omitempty"`
	Subnets          []string               `protobuf:"bytes,2,rep,name=subnets" json:"subnets,omitempty"`
	RandomizeDstPort *bool                  `protobuf:"varint,3,opt,name=randomize_dst_port,json=randomizeDstPort" json:"randomize_dst_port,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PhantomSubnets) Reset() {
	*x = PhantomSubnets{}
	mi := &file_signalling_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PhantomSubnets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhantomSubnets) ProtoMessage() {}

func (x *PhantomSubnets) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhantomSubnets.ProtoReflect.Descriptor instead.
func (*PhantomSubnets) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{6}
}

func (x *PhantomSubnets) GetWeight() uint32 {
	if x != nil && x.Weight != nil {
		return *x.Weight
	}
	return 0
}

func (x *PhantomSubnets) GetSubnets() []string {
	if x != nil {
		return x.Subnets
	}
	return nil
}

func (x *PhantomSubnets) GetRandomizeDstPort() bool {
	if x != nil && x.RandomizeDstPort != nil {
		return *x.RandomizeDstPort
	}
	return false
}

// Deflated ICE Candidate by seed2sdp package
type WebRTCICECandidate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IP is represented in its 16-byte form
	IpUpper *uint64 `protobuf:"varint,1,req,name=ip_upper,json=ipUpper" json:"ip_upper,omitempty"`
	IpLower *uint64 `protobuf:"varint,2,req,name=ip_lower,json=ipLower" json:"ip_lower,omitempty"`
	// Composed info includes port, tcptype (unset if not tcp), candidate type (host, srflx, prflx), protocol (TCP/UDP), and component (RTP/RTCP)
	ComposedInfo  *uint32 `protobuf:"varint,3,req,name=composed_info,json=composedInfo" json:"composed_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WebRTCICECandidate) Reset() {
	*x = WebRTCICECandidate{}
	mi := &file_signalling_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebRTCICECandidate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebRTCICECandidate) ProtoMessage() {}

func (x *WebRTCICECandidate) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebRTCICECandidate.ProtoReflect.Descriptor instead.
func (*WebRTCICECandidate) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{7}
}

func (x *WebRTCICECandidate) GetIpUpper() uint64 {
	if x != nil && x.IpUpper != nil {
		return *x.IpUpper
	}
	return 0
}

func (x *WebRTCICECandidate) GetIpLower() uint64 {
	if x != nil && x.IpLower != nil {
		return *x.IpLower
	}
	return 0
}

func (x *WebRTCICECandidate) GetComposedInfo() uint32 {
	if x != nil && x.ComposedInfo != nil {
		return *x.ComposedInfo
	}
	return 0
}

// Deflated SDP for WebRTC by seed2sdp package
type WebRTCSDP struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          *uint32                `protobuf:"varint,1,req,name=type" json:"type,omitempty"`
	Candidates    []*WebRTCICECandidate  `protobuf:"bytes,2,rep,name=candidates" json:"candidates,omitempty"` // there could be multiple candidates
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WebRTCSDP) Reset() {
	*x = WebRTCSDP{}
	mi := &file_signalling_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebRTCSDP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebRTCSDP) ProtoMessage() {}

func (x *WebRTCSDP) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebRTCSDP.ProtoReflect.Descriptor instead.
func (*WebRTCSDP) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{8}
}

func (x *WebRTCSDP) GetType() uint32 {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return 0
}

func (x *WebRTCSDP) GetCandidates() []*WebRTCICECandidate {
	if x != nil {
		return x.Candidates
	}
	return nil
}

// WebRTCSignal includes a deflated SDP and a seed
type WebRTCSignal struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Seed          *string                `protobuf:"bytes,1,req,name=seed" json:"seed,omitempty"`
	Sdp           *WebRTCSDP             `protobuf:"bytes,2,req,name=sdp" json:"sdp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WebRTCSignal) Reset() {
	*x = WebRTCSignal{}
	mi := &file_signalling_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebRTCSignal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebRTCSignal) ProtoMessage() {}

func (x *WebRTCSignal) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebRTCSignal.ProtoReflect.Descriptor instead.
func (*WebRTCSignal) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{9}
}

func (x *WebRTCSignal) GetSeed() string {
	if x != nil && x.Seed != nil {
		return *x.Seed
	}
	return ""
}

func (x *WebRTCSignal) GetSdp() *WebRTCSDP {
	if x != nil {
		return x.Sdp
	}
	return nil
}

type Addr struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IP            []byte                 `protobuf:"bytes,1,opt,name=IP" json:"IP,omitempty"`
	Port          *uint32                `protobuf:"varint,2,opt,name=Port" json:"Port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Addr) Reset() {
	*x = Addr{}
	mi := &file_signalling_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Addr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Addr) ProtoMessage() {}

func (x *Addr) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Addr.ProtoReflect.Descriptor instead.
func (*Addr) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{10}
}

func (x *Addr) GetIP() []byte {
	if x != nil {
		return x.IP
	}
	return nil
}

func (x *Addr) GetPort() uint32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

type DTLSTransportParams struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	SrcAddr4         *Addr                  `protobuf:"bytes,1,opt,name=src_addr4,json=srcAddr4" json:"src_addr4,omitempty"`
	SrcAddr6         *Addr                  `protobuf:"bytes,2,opt,name=src_addr6,json=srcAddr6" json:"src_addr6,omitempty"`
	RandomizeDstPort *bool                  `protobuf:"varint,3,opt,name=randomize_dst_port,json=randomizeDstPort" json:"randomize_dst_port,omitempty"`
	// Unordered sets the reliability of the DTLS stream to unordered
	Unordered     *bool `protobuf:"varint,4,opt,name=unordered" json:"unordered,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DTLSTransportParams) Reset() {
	*x = DTLSTransportParams{}
	mi := &file_signalling_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DTLSTransportParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DTLSTransportParams) ProtoMessage() {}

func (x *DTLSTransportParams) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DTLSTransportParams.ProtoReflect.Descriptor instead.
func (*DTLSTransportParams) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{11}
}

func (x *DTLSTransportParams) GetSrcAddr4() *Addr {
	if x != nil {
		return x.SrcAddr4
	}
	return nil
}

func (x *DTLSTransportParams) GetSrcAddr6() *Addr {
	if x != nil {
		return x.SrcAddr6
	}
	return nil
}

func (x *DTLSTransportParams) GetRandomizeDstPort() bool {
	if x != nil && x.RandomizeDstPort != nil {
		return *x.RandomizeDstPort
	}
	return false
}

func (x *DTLSTransportParams) GetUnordered() bool {
	if x != nil && x.Unordered != nil {
		return *x.Unordered
	}
	return false
}

type StationToClient struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Should accompany (at least) SESSION_INIT and CONFIRM_RECONNECT.
	ProtocolVersion *uint32 `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion" json:"protocol_version,omitempty"`
	// There might be a state transition. May be absent; absence should be
	// treated identically to NO_CHANGE.
	StateTransition *S2C_Transition `protobuf:"varint,2,opt,name=state_transition,json=stateTransition,enum=proto.S2C_Transition" json:"state_transition,omitempty"`
	// The station can send client config info piggybacked
	// on any message, as it sees fit
	ConfigInfo *ClientConf `protobuf:"bytes,3,opt,name=config_info,json=configInfo" json:"config_info,omitempty"`
	// If state_transition == S2C_ERROR, this field is the explanation.
	ErrReason *ErrorReasonS2C `protobuf:"varint,4,opt,name=err_reason,json=errReason,enum=proto.ErrorReasonS2C" json:"err_reason,omitempty"`
	// Signals client to stop connecting for following amount of seconds
	TmpBackoff *uint32 `protobuf:"varint,5,opt,name=tmp_backoff,json=tmpBackoff" json:"tmp_backoff,omitempty"`
	// Sent in SESSION_INIT, identifies the station that picked up
	StationId *string `protobuf:"bytes,6,opt,name=station_id,json=stationId" json:"station_id,omitempty"`
	// Random-sized junk to defeat packet size fingerprinting.
	Padding       []byte `protobuf:"bytes,100,opt,name=padding" json:"padding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StationToClient) Reset() {
	*x = StationToClient{}
	mi := &file_signalling_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StationToClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StationToClient) ProtoMessage() {}

func (x *StationToClient) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StationToClient.ProtoReflect.Descriptor instead.
func (*StationToClient) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{12}
}

func (x *StationToClient) GetProtocolVersion() uint32 {
	if x != nil && x.ProtocolVersion != nil {
		return *x.ProtocolVersion
	}
	return 0
}

func (x *StationToClient) GetStateTransition() S2C_Transition {
	if x != nil && x.StateTransition != nil {
		return *x.StateTransition
	}
	return S2C_Transition_S2C_NO_CHANGE
}

func (x *StationToClient) GetConfigInfo() *ClientConf {
	if x != nil {
		return x.ConfigInfo
	}
	return nil
}

func (x *StationToClient) GetErrReason() ErrorReasonS2C {
	if x != nil && x.ErrReason != nil {
		return *x.ErrReason
	}
	return ErrorReasonS2C_NO_ERROR
}

func (x *StationToClient) GetTmpBackoff() uint32 {
	if x != nil && x.TmpBackoff != nil {
		return *x.TmpBackoff
	}
	return 0
}

func (x *StationToClient) GetStationId() string {
	if x != nil && x.StationId != nil {
		return *x.StationId
	}
	return ""
}

func (x *StationToClient) GetPadding() []byte {
	if x != nil {
		return x.Padding
	}
	return nil
}

type RegistrationFlags struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UploadOnly    *bool                  `protobuf:"varint,1,opt,name=upload_only,json=uploadOnly" json:"upload_only,omitempty"`
	DarkDecoy     *bool                  `protobuf:"varint,2,opt,name=dark_decoy,json=darkDecoy" json:"dark_decoy,omitempty"`
	ProxyHeader   *bool                  `protobuf:"varint,3,opt,name=proxy_header,json=proxyHeader" json:"proxy_header,omitempty"`
	Use_TIL       *bool                  `protobuf:"varint,4,opt,name=use_TIL,json=useTIL" json:"use_TIL,omitempty"`
	Prescanned    *bool                  `protobuf:"varint,5,opt,name=prescanned" json:"prescanned,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegistrationFlags) Reset() {
	*x = RegistrationFlags{}
	mi := &file_signalling_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegistrationFlags) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegistrationFlags) ProtoMessage() {}

func (x *RegistrationFlags) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegistrationFlags.ProtoReflect.Descriptor instead.
func (*RegistrationFlags) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{13}
}

func (x *RegistrationFlags) GetUploadOnly() bool {
	if x != nil && x.UploadOnly != nil {
		return *x.UploadOnly
	}
	return false
}

func (x *RegistrationFlags) GetDarkDecoy() bool {
	if x != nil && x.DarkDecoy != nil {
		return *x.DarkDecoy
	}
	return false
}

func (x *RegistrationFlags) GetProxyHeader() bool {
	if x != nil && x.ProxyHeader != nil {
		return *x.ProxyHeader
	}
	return false
}

func (x *RegistrationFlags) GetUse_TIL() bool {
	if x != nil && x.Use_TIL != nil {
		return *x.Use_TIL
	}
	return false
}

func (x *RegistrationFlags) GetPrescanned() bool {
	if x != nil && x.Prescanned != nil {
		return *x.Prescanned
	}
	return false
}

type ClientToStation struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ProtocolVersion *uint32                `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion" json:"protocol_version,omitempty"`
	// The client reports its decoy list's version number here, which the
	// station can use to decide whether to send an updated one. The station
	// should always send a list if this field is set to 0.
	DecoyListGeneration *uint32         `protobuf:"varint,2,opt,name=decoy_list_generation,json=decoyListGeneration" json:"decoy_list_generation,omitempty"`
	StateTransition     *C2S_Transition `protobuf:"varint,3,opt,name=state_transition,json=stateTransition,enum=proto.C2S_Transition" json:"state_transition,omitempty"`
	// The position in the overall session's upload sequence where the current
	// YIELD=>ACQUIRE switchover is happening.
	UploadSync *uint64 `protobuf:"varint,4,opt,name=upload_sync,json=uploadSync" json:"upload_sync,omitempty"`
	// High level client library version used for indicating feature support, or
	// lack therof.
	ClientLibVersion *uint32 `protobuf:"varint,5,opt,name=client_lib_version,json=clientLibVersion" json:"client_lib_version,omitempty"`
	// Indicates whether the client will allow the registrar to provide alternative parameters that
	// may work better in substitute for the deterministically selected parameters. This only works
	// for bidirectional registration methods where the client receives a RegistrationResponse.
	DisableRegistrarOverrides *bool `protobuf:"varint,6,opt,name=disable_registrar_overrides,json=disableRegistrarOverrides" json:"disable_registrar_overrides,omitempty"`
	// List of decoys that client have unsuccessfully tried in current session.
	// Could be sent in chunks
	FailedDecoys []string      `protobuf:"bytes,10,rep,name=failed_decoys,json=failedDecoys" json:"failed_decoys,omitempty"`
	Stats        *SessionStats `protobuf:"bytes,11,opt,name=stats" json:"stats,omitempty"`
	// NullTransport, MinTransport, Obfs4Transport, etc. Transport type we want from phantom proxy
	Transport       *TransportType `protobuf:"varint,12,opt,name=transport,enum=proto.TransportType" json:"transport,omitempty"`
	TransportParams *anypb.Any     `protobuf:"bytes,13,opt,name=transport_params,json=transportParams" json:"transport_params,omitempty"`
	// Station is only required to check this variable during session initialization.
	// If set, station must facilitate connection to said target by itself, i.e. write into squid
	// socket an HTTP/SOCKS/any other connection request.
	// covert_address must have exactly one ':' colon, that separates host (literal IP address or
	// resolvable hostname) and port
	// TODO: make it required for initialization, and stop connecting any client straight to squid?
	CovertAddress *string `protobuf:"bytes,20,opt,name=covert_address,json=covertAddress" json:"covert_address,omitempty"`
	// Used in dark decoys to signal which dark decoy it will connect to.
	MaskedDecoyServerName *string `protobuf:"bytes,21,opt,name=masked_decoy_server_name,json=maskedDecoyServerName" json:"masked_decoy_server_name,omitempty"`
	// Used to indicate to server if client is registering v4, v6 or both
	V6Support *bool `protobuf:"varint,22,opt,name=v6_support,json=v6Support" json:"v6_support,omitempty"`
	V4Support *bool `protobuf:"varint,23,opt,name=v4_support,json=v4Support" json:"v4_support,omitempty"`
	// A collection of optional flags for the registration.
	Flags *RegistrationFlags `protobuf:"bytes,24,opt,name=flags" json:"flags,omitempty"`
	// Transport Extensions
	// TODO(jmwample) - move to WebRTC specific transport params protobuf message.
	WebrtcSignal *WebRTCSignal `protobuf:"bytes,31,opt,name=webrtc_signal,json=webrtcSignal" json:"webrtc_signal,omitempty"`
	// Random-sized junk to defeat packet size fingerprinting.
	Padding       []byte `protobuf:"bytes,100,opt,name=padding" json:"padding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientToStation) Reset() {
	*x = ClientToStation{}
	mi := &file_signalling_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientToStation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientToStation) ProtoMessage() {}

func (x *ClientToStation) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientToStation.ProtoReflect.Descriptor instead.
func (*ClientToStation) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{14}
}

func (x *ClientToStation) GetProtocolVersion() uint32 {
	if x != nil && x.ProtocolVersion != nil {
		return *x.ProtocolVersion
	}
	return 0
}

func (x *ClientToStation) GetDecoyListGeneration() uint32 {
	if x != nil && x.DecoyListGeneration != nil {
		return *x.DecoyListGeneration
	}
	return 0
}

func (x *ClientToStation) GetStateTransition() C2S_Transition {
	if x != nil && x.StateTransition != nil {
		return *x.StateTransition
	}
	return C2S_Transition_C2S_NO_CHANGE
}

func (x *ClientToStation) GetUploadSync() uint64 {
	if x != nil && x.UploadSync != nil {
		return *x.UploadSync
	}
	return 0
}

func (x *ClientToStation) GetClientLibVersion() uint32 {
	if x != nil && x.ClientLibVersion != nil {
		return *x.ClientLibVersion
	}
	return 0
}

func (x *ClientToStation) GetDisableRegistrarOverrides() bool {
	if x != nil && x.DisableRegistrarOverrides != nil {
		return *x.DisableRegistrarOverrides
	}
	return false
}

func (x *ClientToStation) GetFailedDecoys() []string {
	if x != nil {
		return x.FailedDecoys
	}
	return nil
}

func (x *ClientToStation) GetStats() *SessionStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

func (x *ClientToStation) GetTransport() TransportType {
	if x != nil && x.Transport != nil {
		return *x.Transport
	}
	return TransportType_Null
}

func (x *ClientToStation) GetTransportParams() *anypb.Any {
	if x != nil {
		return x.TransportParams
	}
	return nil
}

func (x *ClientToStation) GetCovertAddress() string {
	if x != nil && x.CovertAddress != nil {
		return *x.CovertAddress
	}
	return ""
}

func (x *ClientToStation) GetMaskedDecoyServerName() string {
	if x != nil && x.MaskedDecoyServerName != nil {
		return *x.MaskedDecoyServerName
	}
	return ""
}

func (x *ClientToStation) GetV6Support() bool {
	if x != nil && x.V6Support != nil {
		return *x.V6Support
	}
	return false
}

func (x *ClientToStation) GetV4Support() bool {
	if x != nil && x.V4Support != nil {
		return *x.V4Support
	}
	return false
}

func (x *ClientToStation) GetFlags() *RegistrationFlags {
	if x != nil {
		return x.Flags
	}
	return nil
}

func (x *ClientToStation) GetWebrtcSignal() *WebRTCSignal {
	if x != nil {
		return x.WebrtcSignal
	}
	return nil
}

func (x *ClientToStation) GetPadding() []byte {
	if x != nil {
		return x.Padding
	}
	return nil
}

type PrefixTransportParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Prefix Identifier
	PrefixId *int32 `protobuf:"varint,1,opt,name=prefix_id,json=prefixId" json:"prefix_id,omitempty"`
	// Prefix bytes (optional - usually sent from station to client as override if allowed by C2S)
	// as the station cannot take this into account when attempting to identify a connection.
	Prefix            []byte `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
	CustomFlushPolicy *int32 `protobuf:"varint,3,opt,name=custom_flush_policy,json=customFlushPolicy" json:"custom_flush_policy,omitempty"`
	// Indicates whether the client has elected to use destination port randomization. Should be
	// checked against selected transport to ensure that destination port randomization is
	// supported.
	RandomizeDstPort *bool `protobuf:"varint,13,opt,name=randomize_dst_port,json=randomizeDstPort" json:"randomize_dst_port,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PrefixTransportParams) Reset() {
	*x = PrefixTransportParams{}
	mi := &file_signalling_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrefixTransportParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrefixTransportParams) ProtoMessage() {}

func (x *PrefixTransportParams) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrefixTransportParams.ProtoReflect.Descriptor instead.
func (*PrefixTransportParams) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{15}
}

func (x *PrefixTransportParams) GetPrefixId() int32 {
	if x != nil && x.PrefixId != nil {
		return *x.PrefixId
	}
	return 0
}

func (x *PrefixTransportParams) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *PrefixTransportParams) GetCustomFlushPolicy() int32 {
	if x != nil && x.CustomFlushPolicy != nil {
		return *x.CustomFlushPolicy
	}
	return 0
}

func (x *PrefixTransportParams) GetRandomizeDstPort() bool {
	if x != nil && x.RandomizeDstPort != nil {
		return *x.RandomizeDstPort
	}
	return false
}

type GenericTransportParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates whether the client has elected to use destination port randomization. Should be
	// checked against selected transport to ensure that destination port randomization is
	// supported.
	RandomizeDstPort *bool `protobuf:"varint,13,opt,name=randomize_dst_port,json=randomizeDstPort" json:"randomize_dst_port,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GenericTransportParams) Reset() {
	*x = GenericTransportParams{}
	mi := &file_signalling_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenericTransportParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenericTransportParams) ProtoMessage() {}

func (x *GenericTransportParams) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenericTransportParams.ProtoReflect.Descriptor instead.
func (*GenericTransportParams) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{16}
}

func (x *GenericTransportParams) GetRandomizeDstPort() bool {
	if x != nil && x.RandomizeDstPort != nil {
		return *x.RandomizeDstPort
	}
	return false
}

type C2SWrapper struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	SharedSecret        []byte                 `protobuf:"bytes,1,opt,name=shared_secret,json=sharedSecret" json:"shared_secret,omitempty"`
	RegistrationPayload *ClientToStation       `protobuf:"bytes,3,opt,name=registration_payload,json=registrationPayload" json:"registration_payload,omitempty"`
	RegistrationSource  *RegistrationSource    `protobuf:"varint,4,opt,name=registration_source,json=registrationSource,enum=proto.RegistrationSource" json:"registration_source,omitempty"`
	// client source address when receiving a registration
	RegistrationAddress []byte `protobuf:"bytes,6,opt,name=registration_address,json=registrationAddress" json:"registration_address,omitempty"`
	// Decoy address used when registering over Decoy registrar
	DecoyAddress []byte `protobuf:"bytes,7,opt,name=decoy_address,json=decoyAddress" json:"decoy_address,omitempty"`
	// The next three fields allow an independent registrar (trusted by a station w/ a zmq keypair) to
	// share the registration overrides that it assigned to the client with the station(s).
	// Registration Respose is here to allow a parsed object with direct access to the fields within.
	// RegRespBytes provides a serialized verion of the Registration response so that the signature of
	// the Bidirectional registrar can be validated before a station applies any overrides present in
	// the Registration Response.
	//
	// If you are reading this in the future and you want to extend the functionality here it might
	// make sense to make the RegistrationResponse that is sent to the client a distinct message from
	// the one that gets sent to the stations.
	RegistrationResponse *RegistrationResponse `protobuf:"bytes,8,opt,name=registration_response,json=registrationResponse" json:"registration_response,omitempty"`
	RegRespBytes         []byte                `protobuf:"bytes,9,opt,name=RegRespBytes" json:"RegRespBytes,omitempty"`
	RegRespSignature     []byte                `protobuf:"bytes,10,opt,name=RegRespSignature" json:"RegRespSignature,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *C2SWrapper) Reset() {
	*x = C2SWrapper{}
	mi := &file_signalling_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *C2SWrapper) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*C2SWrapper) ProtoMessage() {}

func (x *C2SWrapper) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use C2SWrapper.ProtoReflect.Descriptor instead.
func (*C2SWrapper) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{17}
}

func (x *C2SWrapper) GetSharedSecret() []byte {
	if x != nil {
		return x.SharedSecret
	}
	return nil
}

func (x *C2SWrapper) GetRegistrationPayload() *ClientToStation {
	if x != nil {
		return x.RegistrationPayload
	}
	return nil
}

func (x *C2SWrapper) GetRegistrationSource() RegistrationSource {
	if x != nil && x.RegistrationSource != nil {
		return *x.RegistrationSource
	}
	return RegistrationSource_Unspecified
}

func (x *C2SWrapper) GetRegistrationAddress() []byte {
	if x != nil {
		return x.RegistrationAddress
	}
	return nil
}

func (x *C2SWrapper) GetDecoyAddress() []byte {
	if x != nil {
		return x.DecoyAddress
	}
	return nil
}

func (x *C2SWrapper) GetRegistrationResponse() *RegistrationResponse {
	if x != nil {
		return x.RegistrationResponse
	}
	return nil
}

func (x *C2SWrapper) GetRegRespBytes() []byte {
	if x != nil {
		return x.RegRespBytes
	}
	return nil
}

func (x *C2SWrapper) GetRegRespSignature() []byte {
	if x != nil {
		return x.RegRespSignature
	}
	return nil
}

type SessionStats struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	FailedDecoysAmount *uint32                `protobuf:"varint,20,opt,name=failed_decoys_amount,json=failedDecoysAmount" json:"failed_decoys_amount,omitempty"` // how many decoys were tried before success
	// Applicable to whole session:
	TotalTimeToConnect *uint32 `protobuf:"varint,31,opt,name=total_time_to_connect,json=totalTimeToConnect" json:"total_time_to_connect,omitempty"` // includes failed attempts
	// Last (i.e. successful) decoy:
	RttToStation  *uint32 `protobuf:"varint,33,opt,name=rtt_to_station,json=rttToStation" json:"rtt_to_station,omitempty"` // measured during initial handshake
	TlsToDecoy    *uint32 `protobuf:"varint,38,opt,name=tls_to_decoy,json=tlsToDecoy" json:"tls_to_decoy,omitempty"`       // includes tcp to decoy
	TcpToDecoy    *uint32 `protobuf:"varint,39,opt,name=tcp_to_decoy,json=tcpToDecoy" json:"tcp_to_decoy,omitempty"`       // measured when establishing tcp connection to decot
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionStats) Reset() {
	*x = SessionStats{}
	mi := &file_signalling_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionStats) ProtoMessage() {}

func (x *SessionStats) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionStats.ProtoReflect.Descriptor instead.
func (*SessionStats) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{18}
}

func (x *SessionStats) GetFailedDecoysAmount() uint32 {
	if x != nil && x.FailedDecoysAmount != nil {
		return *x.FailedDecoysAmount
	}
	return 0
}

func (x *SessionStats) GetTotalTimeToConnect() uint32 {
	if x != nil && x.TotalTimeToConnect != nil {
		return *x.TotalTimeToConnect
	}
	return 0
}

func (x *SessionStats) GetRttToStation() uint32 {
	if x != nil && x.RttToStation != nil {
		return *x.RttToStation
	}
	return 0
}

func (x *SessionStats) GetTlsToDecoy() uint32 {
	if x != nil && x.TlsToDecoy != nil {
		return *x.TlsToDecoy
	}
	return 0
}

func (x *SessionStats) GetTcpToDecoy() uint32 {
	if x != nil && x.TcpToDecoy != nil {
		return *x.TcpToDecoy
	}
	return 0
}

type StationToDetector struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PhantomIp     *string                `protobuf:"bytes,1,opt,name=phantom_ip,json=phantomIp" json:"phantom_ip,omitempty"`
	ClientIp      *string                `protobuf:"bytes,2,opt,name=client_ip,json=clientIp" json:"client_ip,omitempty"`
	TimeoutNs     *uint64                `protobuf:"varint,3,opt,name=timeout_ns,json=timeoutNs" json:"timeout_ns,omitempty"`
	Operation     *StationOperations     `protobuf:"varint,4,opt,name=operation,enum=proto.StationOperations" json:"operation,omitempty"`
	DstPort       *uint32                `protobuf:"varint,10,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	SrcPort       *uint32                `protobuf:"varint,11,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	Proto         *IPProto               `protobuf:"varint,12,opt,name=proto,enum=proto.IPProto" json:"proto,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StationToDetector) Reset() {
	*x = StationToDetector{}
	mi := &file_signalling_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StationToDetector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StationToDetector) ProtoMessage() {}

func (x *StationToDetector) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StationToDetector.ProtoReflect.Descriptor instead.
func (*StationToDetector) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{19}
}

func (x *StationToDetector) GetPhantomIp() string {
	if x != nil && x.PhantomIp != nil {
		return *x.PhantomIp
	}
	return ""
}

func (x *StationToDetector) GetClientIp() string {
	if x != nil && x.ClientIp != nil {
		return *x.ClientIp
	}
	return ""
}

func (x *StationToDetector) GetTimeoutNs() uint64 {
	if x != nil && x.TimeoutNs != nil {
		return *x.TimeoutNs
	}
	return 0
}

func (x *StationToDetector) GetOperation() StationOperations {
	if x != nil && x.Operation != nil {
		return *x.Operation
	}
	return StationOperations_Unknown
}

func (x *StationToDetector) GetDstPort() uint32 {
	if x != nil && x.DstPort != nil {
		return *x.DstPort
	}
	return 0
}

func (x *StationToDetector) GetSrcPort() uint32 {
	if x != nil && x.SrcPort != nil {
		return *x.SrcPort
	}
	return 0
}

func (x *StationToDetector) GetProto() IPProto {
	if x != nil && x.Proto != nil {
		return *x.Proto
	}
	return IPProto_Unk
}

// Adding message response from Station to Client for bidirectional API
type RegistrationResponse struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Ipv4Addr *uint32                `protobuf:"fixed32,1,opt,name=ipv4addr" json:"ipv4addr,omitempty"`
	// The 128-bit ipv6 address, in network byte order
	Ipv6Addr []byte `protobuf:"bytes,2,opt,name=ipv6addr" json:"ipv6addr,omitempty"`
	// Respond with randomized port
	DstPort *uint32 `protobuf:"varint,3,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	// Future: station provides client with secret, want chanel present
	// Leave null for now
	ServerRandom []byte `protobuf:"bytes,4,opt,name=serverRandom" json:"serverRandom,omitempty"`
	// If registration wrong, populate this error string
	Error *string `protobuf:"bytes,5,opt,name=error" json:"error,omitempty"`
	// ClientConf field (optional)
	ClientConf *ClientConf `protobuf:"bytes,6,opt,name=clientConf" json:"clientConf,omitempty"`
	// Transport Params to if `allow_registrar_overrides` is set.
	TransportParams *anypb.Any `protobuf:"bytes,10,opt,name=transport_params,json=transportParams" json:"transport_params,omitempty"`
	// PhantomsSupportPortRand is a flag that indicates whether the selected phantoms are able to
	// handle phantom connections to randomized ports.
	PhantomsSupportPortRand *bool `protobuf:"varint,11,opt,name=phantoms_support_port_rand,json=phantomsSupportPortRand" json:"phantoms_support_port_rand,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *RegistrationResponse) Reset() {
	*x = RegistrationResponse{}
	mi := &file_signalling_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegistrationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegistrationResponse) ProtoMessage() {}

func (x *RegistrationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegistrationResponse.ProtoReflect.Descriptor instead.
func (*RegistrationResponse) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{20}
}

func (x *RegistrationResponse) GetIpv4Addr() uint32 {
	if x != nil && x.Ipv4Addr != nil {
		return *x.Ipv4Addr
	}
	return 0
}

func (x *RegistrationResponse) GetIpv6Addr() []byte {
	if x != nil {
		return x.Ipv6Addr
	}
	return nil
}

func (x *RegistrationResponse) GetDstPort() uint32 {
	if x != nil && x.DstPort != nil {
		return *x.DstPort
	}
	return 0
}

func (x *RegistrationResponse) GetServerRandom() []byte {
	if x != nil {
		return x.ServerRandom
	}
	return nil
}

func (x *RegistrationResponse) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *RegistrationResponse) GetClientConf() *ClientConf {
	if x != nil {
		return x.ClientConf
	}
	return nil
}

func (x *RegistrationResponse) GetTransportParams() *anypb.Any {
	if x != nil {
		return x.TransportParams
	}
	return nil
}

func (x *RegistrationResponse) GetPhantomsSupportPortRand() bool {
	if x != nil && x.PhantomsSupportPortRand != nil {
		return *x.PhantomsSupportPortRand
	}
	return false
}

// response from dns
type DnsResponse struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Success               *bool                  `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	ClientconfOutdated    *bool                  `protobuf:"varint,2,opt,name=clientconf_outdated,json=clientconfOutdated" json:"clientconf_outdated,omitempty"`
	BidirectionalResponse *RegistrationResponse  `protobuf:"bytes,3,opt,name=bidirectional_response,json=bidirectionalResponse" json:"bidirectional_response,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *DnsResponse) Reset() {
	*x = DnsResponse{}
	mi := &file_signalling_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DnsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DnsResponse) ProtoMessage() {}

func (x *DnsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DnsResponse.ProtoReflect.Descriptor instead.
func (*DnsResponse) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{21}
}

func (x *DnsResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *DnsResponse) GetClientconfOutdated() bool {
	if x != nil && x.ClientconfOutdated != nil {
		return *x.ClientconfOutdated
	}
	return false
}

func (x *DnsResponse) GetBidirectionalResponse() *RegistrationResponse {
	if x != nil {
		return x.BidirectionalResponse
	}
	return nil
}

type DnsPartReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            []byte                 `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	PartNum       *uint32                `protobuf:"varint,2,opt,name=partNum" json:"partNum,omitempty"`
	TotalParts    *uint32                `protobuf:"varint,3,opt,name=totalParts" json:"totalParts,omitempty"`
	Data          []byte                 `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DnsPartReq) Reset() {
	*x = DnsPartReq{}
	mi := &file_signalling_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DnsPartReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DnsPartReq) ProtoMessage() {}

func (x *DnsPartReq) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DnsPartReq.ProtoReflect.Descriptor instead.
func (*DnsPartReq) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{22}
}

func (x *DnsPartReq) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *DnsPartReq) GetPartNum() uint32 {
	if x != nil && x.PartNum != nil {
		return *x.PartNum
	}
	return 0
}

func (x *DnsPartReq) GetTotalParts() uint32 {
	if x != nil && x.TotalParts != nil {
		return *x.TotalParts
	}
	return 0
}

func (x *DnsPartReq) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type DnsPartResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Waiting       *bool                  `protobuf:"varint,1,opt,name=waiting" json:"waiting,omitempty"`
	Data          []byte                 `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DnsPartResp) Reset() {
	*x = DnsPartResp{}
	mi := &file_signalling_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DnsPartResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DnsPartResp) ProtoMessage() {}

func (x *DnsPartResp) ProtoReflect() protoreflect.Message {
	mi := &file_signalling_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DnsPartResp.ProtoReflect.Descriptor instead.
func (*DnsPartResp) Descriptor() ([]byte, []int) {
	return file_signalling_proto_rawDescGZIP(), []int{23}
}

func (x *DnsPartResp) GetWaiting() bool {
	if x != nil && x.Waiting != nil {
		return *x.Waiting
	}
	return false
}

func (x *DnsPartResp) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

var File_signalling_proto protoreflect.FileDescriptor

const file_signalling_proto_rawDesc = "" +
	"\n" +
	"\x10signalling.proto\x12\x05proto\x1a\x19google/protobuf/any.proto\">\n" +
	"\x06PubKey\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\"\n" +
	"\x04type\x18\x02 \x01(\x0e2\x0e.proto.KeyTypeR\x04type\"\xbb\x01\n" +
	"\fTLSDecoySpec\x12\x1a\n" +
	"\bhostname\x18\x01 \x01(\tR\bhostname\x12\x1a\n" +
	"\bipv4addr\x18\x02 \x01(\aR\bipv4addr\x12\x1a\n" +
	"\bipv6addr\x18\x06 \x01(\fR\bipv6addr\x12%\n" +
	"\x06pubkey\x18\x03 \x01(\v2\r.proto.PubKeyR\x06pubkey\x12\x18\n" +
	"\atimeout\x18\x04 \x01(\rR\atimeout\x12\x16\n" +
	"\x06tcpwin\x18\x05 \x01(\rR\x06tcpwin\"\xcb\x02\n" +
	"\n" +
	"ClientConf\x12/\n" +
	"\n" +
	"decoy_list\x18\x01 \x01(\v2\x10.proto.DecoyListR\tdecoyList\x12\x1e\n" +
	"\n" +
	"generation\x18\x02 \x01(\rR\n" +
	"generation\x124\n" +
	"\x0edefault_pubkey\x18\x03 \x01(\v2\r.proto.PubKeyR\rdefaultPubkey\x12K\n" +
	"\x14phantom_subnets_list\x18\x04 \x01(\v2\x19.proto.PhantomSubnetsListR\x12phantomSubnetsList\x124\n" +
	"\x0econjure_pubkey\x18\x05 \x01(\v2\r.proto.PubKeyR\rconjurePubkey\x123\n" +
	"\fdns_reg_conf\x18\x06 \x01(\v2\x11.proto.DnsRegConfR\n" +
	"dnsRegConf\"\xdd\x01\n" +
	"\n" +
	"DnsRegConf\x129\n" +
	"\x0edns_reg_method\x18\x01 \x02(\x0e2\x13.proto.DnsRegMethodR\fdnsRegMethod\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12\x16\n" +
	"\x06domain\x18\x03 \x02(\tR\x06domain\x12\x16\n" +
	"\x06pubkey\x18\x04 \x01(\fR\x06pubkey\x12+\n" +
	"\x11utls_distribution\x18\x05 \x01(\tR\x10utlsDistribution\x12\x1f\n" +
	"\vstun_server\x18\x06 \x01(\tR\n" +
	"stunServer\"?\n" +
	"\tDecoyList\x122\n" +
	"\n" +
	"tls_decoys\x18\x01 \x03(\v2\x13.proto.TLSDecoySpecR\ttlsDecoys\"V\n" +
	"\x12PhantomSubnetsList\x12@\n" +
	"\x10weighted_subnets\x18\x01 \x03(\v2\x15.proto.PhantomSubnetsR\x0fweightedSubnets\"p\n" +
	"\x0ePhantomSubnets\x12\x16\n" +
	"\x06weight\x18\x01 \x01(\rR\x06weight\x12\x18\n" +
	"\asubnets\x18\x02 \x03(\tR\asubnets\x12,\n" +
	"\x12randomize_dst_port\x18\x03 \x01(\bR\x10randomizeDstPort\"o\n" +
	"\x12WebRTCICECandidate\x12\x19\n" +
	"\bip_upper\x18\x01 \x02(\x04R\aipUpper\x12\x19\n" +
	"\bip_lower\x18\x02 \x02(\x04R\aipLower\x12#\n" +
	"\rcomposed_info\x18\x03 \x02(\rR\fcomposedInfo\"Z\n" +
	"\tWebRTCSDP\x12\x12\n" +
	"\x04type\x18\x01 \x02(\rR\x04type\x129\n" +
	"\n" +
	"candidates\x18\x02 \x03(\v2\x19.proto.WebRTCICECandidateR\n" +
	"candidates\"F\n" +
	"\fWebRTCSignal\x12\x12\n" +
	"\x04seed\x18\x01 \x02(\tR\x04seed\x12\"\n" +
	"\x03sdp\x18\x02 \x02(\v2\x10.proto.WebRTCSDPR\x03sdp\"*\n" +
	"\x04Addr\x12\x0e\n" +
	"\x02IP\x18\x01 \x01(\fR\x02IP\x12\x12\n" +
	"\x04Port\x18\x02 \x01(\rR\x04Port\"\xb5\x01\n" +
	"\x13DTLSTransportParams\x12(\n" +
	"\tsrc_addr4\x18\x01 \x01(\v2\v.proto.AddrR\bsrcAddr4\x12(\n" +
	"\tsrc_addr6\x18\x02 \x01(\v2\v.proto.AddrR\bsrcAddr6\x12,\n" +
	"\x12randomize_dst_port\x18\x03 \x01(\bR\x10randomizeDstPort\x12\x1c\n" +
	"\tunordered\x18\x04 \x01(\bR\tunordered\"\xc2\x02\n" +
	"\x0fStationToClient\x12)\n" +
	"\x10protocol_version\x18\x01 \x01(\rR\x0fprotocolVersion\x12@\n" +
	"\x10state_transition\x18\x02 \x01(\x0e2\x15.proto.S2C_TransitionR\x0fstateTransition\x122\n" +
	"\vconfig_info\x18\x03 \x01(\v2\x11.proto.ClientConfR\n" +
	"configInfo\x124\n" +
	"\n" +
	"err_reason\x18\x04 \x01(\x0e2\x15.proto.ErrorReasonS2CR\terrReason\x12\x1f\n" +
	"\vtmp_backoff\x18\x05 \x01(\rR\n" +
	"tmpBackoff\x12\x1d\n" +
	"\n" +
	"station_id\x18\x06 \x01(\tR\tstationId\x12\x18\n" +
	"\apadding\x18d \x01(\fR\apadding\"\xaf\x01\n" +
	"\x11RegistrationFlags\x12\x1f\n" +
	"\vupload_only\x18\x01 \x01(\bR\n" +
	"uploadOnly\x12\x1d\n" +
	"\n" +
	"dark_decoy\x18\x02 \x01(\bR\tdarkDecoy\x12!\n" +
	"\fproxy_header\x18\x03 \x01(\bR\vproxyHeader\x12\x17\n" +
	"\ause_TIL\x18\x04 \x01(\bR\x06useTIL\x12\x1e\n" +
	"\n" +
	"prescanned\x18\x05 \x01(\bR\n" +
	"prescanned\"\xa8\x06\n" +
	"\x0fClientToStation\x12)\n" +
	"\x10protocol_version\x18\x01 \x01(\rR\x0fprotocolVersion\x122\n" +
	"\x15decoy_list_generation\x18\x02 \x01(\rR\x13decoyListGeneration\x12@\n" +
	"\x10state_transition\x18\x03 \x01(\x0e2\x15.proto.C2S_TransitionR\x0fstateTransition\x12\x1f\n" +
	"\vupload_sync\x18\x04 \x01(\x04R\n" +
	"uploadSync\x12,\n" +
	"\x12client_lib_version\x18\x05 \x01(\rR\x10clientLibVersion\x12>\n" +
	"\x1bdisable_registrar_overrides\x18\x06 \x01(\bR\x19disableRegistrarOverrides\x12#\n" +
	"\rfailed_decoys\x18\n" +
	" \x03(\tR\ffailedDecoys\x12)\n" +
	"\x05stats\x18\v \x01(\v2\x13.proto.SessionStatsR\x05stats\x122\n" +
	"\ttransport\x18\f \x01(\x0e2\x14.proto.TransportTypeR\ttransport\x12?\n" +
	"\x10transport_params\x18\r \x01(\v2\x14.google.protobuf.AnyR\x0ftransportParams\x12%\n" +
	"\x0ecovert_address\x18\x14 \x01(\tR\rcovertAddress\x127\n" +
	"\x18masked_decoy_server_name\x18\x15 \x01(\tR\x15maskedDecoyServerName\x12\x1d\n" +
	"\n" +
	"v6_support\x18\x16 \x01(\bR\tv6Support\x12\x1d\n" +
	"\n" +
	"v4_support\x18\x17 \x01(\bR\tv4Support\x12.\n" +
	"\x05flags\x18\x18 \x01(\v2\x18.proto.RegistrationFlagsR\x05flags\x128\n" +
	"\rwebrtc_signal\x18\x1f \x01(\v2\x13.proto.WebRTCSignalR\fwebrtcSignal\x12\x18\n" +
	"\apadding\x18d \x01(\fR\apadding\"\xaa\x01\n" +
	"\x15PrefixTransportParams\x12\x1b\n" +
	"\tprefix_id\x18\x01 \x01(\x05R\bprefixId\x12\x16\n" +
	"\x06prefix\x18\x02 \x01(\fR\x06prefix\x12.\n" +
	"\x13custom_flush_policy\x18\x03 \x01(\x05R\x11customFlushPolicy\x12,\n" +
	"\x12randomize_dst_port\x18\r \x01(\bR\x10randomizeDstPort\"F\n" +
	"\x16GenericTransportParams\x12,\n" +
	"\x12randomize_dst_port\x18\r \x01(\bR\x10randomizeDstPort\"\xc2\x03\n" +
	"\n" +
	"C2SWrapper\x12#\n" +
	"\rshared_secret\x18\x01 \x01(\fR\fsharedSecret\x12I\n" +
	"\x14registration_payload\x18\x03 \x01(\v2\x16.proto.ClientToStationR\x13registrationPayload\x12J\n" +
	"\x13registration_source\x18\x04 \x01(\x0e2\x19.proto.RegistrationSourceR\x12registrationSource\x121\n" +
	"\x14registration_address\x18\x06 \x01(\fR\x13registrationAddress\x12#\n" +
	"\rdecoy_address\x18\a \x01(\fR\fdecoyAddress\x12P\n" +
	"\x15registration_response\x18\b \x01(\v2\x1b.proto.RegistrationResponseR\x14registrationResponse\x12\"\n" +
	"\fRegRespBytes\x18\t \x01(\fR\fRegRespBytes\x12*\n" +
	"\x10RegRespSignature\x18\n" +
	" \x01(\fR\x10RegRespSignature\"\xdd\x01\n" +
	"\fSessionStats\x120\n" +
	"\x14failed_decoys_amount\x18\x14 \x01(\rR\x12failedDecoysAmount\x121\n" +
	"\x15total_time_to_connect\x18\x1f \x01(\rR\x12totalTimeToConnect\x12$\n" +
	"\x0ertt_to_station\x18! \x01(\rR\frttToStation\x12 \n" +
	"\ftls_to_decoy\x18& \x01(\rR\n" +
	"tlsToDecoy\x12 \n" +
	"\ftcp_to_decoy\x18' \x01(\rR\n" +
	"tcpToDecoy\"\x82\x02\n" +
	"\x11StationToDetector\x12\x1d\n" +
	"\n" +
	"phantom_ip\x18\x01 \x01(\tR\tphantomIp\x12\x1b\n" +
	"\tclient_ip\x18\x02 \x01(\tR\bclientIp\x12\x1d\n" +
	"\n" +
	"timeout_ns\x18\x03 \x01(\x04R\ttimeoutNs\x126\n" +
	"\toperation\x18\x04 \x01(\x0e2\x18.proto.StationOperationsR\toperation\x12\x19\n" +
	"\bdst_port\x18\n" +
	" \x01(\rR\adstPort\x12\x19\n" +
	"\bsrc_port\x18\v \x01(\rR\asrcPort\x12$\n" +
	"\x05proto\x18\f \x01(\x0e2\x0e.proto.IPProtoR\x05proto\"\xd4\x02\n" +
	"\x14RegistrationResponse\x12\x1a\n" +
	"\bipv4addr\x18\x01 \x01(\aR\bipv4addr\x12\x1a\n" +
	"\bipv6addr\x18\x02 \x01(\fR\bipv6addr\x12\x19\n" +
	"\bdst_port\x18\x03 \x01(\rR\adstPort\x12\"\n" +
	"\fserverRandom\x18\x04 \x01(\fR\fserverRandom\x12\x14\n" +
	"\x05error\x18\x05 \x01(\tR\x05error\x121\n" +
	"\n" +
	"clientConf\x18\x06 \x01(\v2\x11.proto.ClientConfR\n" +
	"clientConf\x12?\n" +
	"\x10transport_params\x18\n" +
	" \x01(\v2\x14.google.protobuf.AnyR\x0ftransportParams\x12;\n" +
	"\x1aphantoms_support_port_rand\x18\v \x01(\bR\x17phantomsSupportPortRand\"\xac\x01\n" +
	"\vDnsResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12/\n" +
	"\x13clientconf_outdated\x18\x02 \x01(\bR\x12clientconfOutdated\x12R\n" +
	"\x16bidirectional_response\x18\x03 \x01(\v2\x1b.proto.RegistrationResponseR\x15bidirectionalResponse\"j\n" +
	"\n" +
	"DnsPartReq\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\fR\x02id\x12\x18\n" +
	"\apartNum\x18\x02 \x01(\rR\apartNum\x12\x1e\n" +
	"\n" +
	"totalParts\x18\x03 \x01(\rR\n" +
	"totalParts\x12\x12\n" +
	"\x04data\x18\x04 \x01(\fR\x04data\";\n" +
	"\vDnsPartResp\x12\x18\n" +
	"\awaiting\x18\x01 \x01(\bR\awaiting\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data*+\n" +
	"\aKeyType\x12\x0f\n" +
	"\vAES_GCM_128\x10Z\x12\x0f\n" +
	"\vAES_GCM_256\x10[*)\n" +
	"\fDnsRegMethod\x12\a\n" +
	"\x03UDP\x10\x01\x12\a\n" +
	"\x03DOT\x10\x02\x12\a\n" +
	"\x03DOH\x10\x03*\xe7\x01\n" +
	"\x0eC2S_Transition\x12\x11\n" +
	"\rC2S_NO_CHANGE\x10\x00\x12\x14\n" +
	"\x10C2S_SESSION_INIT\x10\x01\x12\x1b\n" +
	"\x17C2S_SESSION_COVERT_INIT\x10\v\x12\x18\n" +
	"\x14C2S_EXPECT_RECONNECT\x10\x02\x12\x15\n" +
	"\x11C2S_SESSION_CLOSE\x10\x03\x12\x14\n" +
	"\x10C2S_YIELD_UPLOAD\x10\x04\x12\x16\n" +
	"\x12C2S_ACQUIRE_UPLOAD\x10\x05\x12 \n" +
	"\x1cC2S_EXPECT_UPLOADONLY_RECONN\x10\x06\x12\x0e\n" +
	"\tC2S_ERROR\x10\xff\x01*\x98\x01\n" +
	"\x0eS2C_Transition\x12\x11\n" +
	"\rS2C_NO_CHANGE\x10\x00\x12\x14\n" +
	"\x10S2C_SESSION_INIT\x10\x01\x12\x1b\n" +
	"\x17S2C_SESSION_COVERT_INIT\x10\v\x12\x19\n" +
	"\x15S2C_CONFIRM_RECONNECT\x10\x02\x12\x15\n" +
	"\x11S2C_SESSION_CLOSE\x10\x03\x12\x0e\n" +
	"\tS2C_ERROR\x10\xff\x01*\xac\x01\n" +
	"\x0eErrorReasonS2C\x12\f\n" +
	"\bNO_ERROR\x10\x00\x12\x11\n" +
	"\rCOVERT_STREAM\x10\x01\x12\x13\n" +
	"\x0fCLIENT_REPORTED\x10\x02\x12\x13\n" +
	"\x0fCLIENT_PROTOCOL\x10\x03\x12\x14\n" +
	"\x10STATION_INTERNAL\x10\x04\x12\x12\n" +
	"\x0eDECOY_OVERLOAD\x10\x05\x12\x11\n" +
	"\rCLIENT_STREAM\x10d\x12\x12\n" +
	"\x0eCLIENT_TIMEOUT\x10e*\x82\x01\n" +
	"\rTransportType\x12\b\n" +
	"\x04Null\x10\x00\x12\a\n" +
	"\x03Min\x10\x01\x12\t\n" +
	"\x05Obfs4\x10\x02\x12\b\n" +
	"\x04DTLS\x10\x03\x12\n" +
	"\n" +
	"\x06Prefix\x10\x04\x12\b\n" +
	"\x04uTLS\x10\x05\x12\n" +
	"\n" +
	"\x06Format\x10\x06\x12\b\n" +
	"\x04WASM\x10\a\x12\a\n" +
	"\x03FTE\x10\b\x12\b\n" +
	"\x04Quic\x10\t\x12\n" +
	"\n" +
	"\x06Webrtc\x10c*\xaa\x01\n" +
	"\x12RegistrationSource\x12\x0f\n" +
	"\vUnspecified\x10\x00\x12\f\n" +
	"\bDetector\x10\x01\x12\a\n" +
	"\x03API\x10\x02\x12\x13\n" +
	"\x0fDetectorPrescan\x10\x03\x12\x14\n" +
	"\x10BidirectionalAPI\x10\x04\x12\a\n" +
	"\x03DNS\x10\x05\x12\x14\n" +
	"\x10BidirectionalDNS\x10\x06\x12\f\n" +
	"\bAMPCache\x10\a\x12\x14\n" +
	"\x10BidirectionalAMP\x10\b*@\n" +
	"\x11StationOperations\x12\v\n" +
	"\aUnknown\x10\x00\x12\a\n" +
	"\x03New\x10\x01\x12\n" +
	"\n" +
	"\x06Update\x10\x02\x12\t\n" +
	"\x05Clear\x10\x03*$\n" +
	"\aIPProto\x12\a\n" +
	"\x03Unk\x10\x00\x12\a\n" +
	"\x03Tcp\x10\x01\x12\a\n" +
	"\x03Udp\x10\x02"

var (
	file_signalling_proto_rawDescOnce sync.Once
	file_signalling_proto_rawDescData []byte
)

func file_signalling_proto_rawDescGZIP() []byte {
	file_signalling_proto_rawDescOnce.Do(func() {
		file_signalling_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_signalling_proto_rawDesc), len(file_signalling_proto_rawDesc)))
	})
	return file_signalling_proto_rawDescData
}

var file_signalling_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_signalling_proto_msgTypes = make([]protoimpl.MessageInfo, 24)
var file_signalling_proto_goTypes = []any{
	(KeyType)(0),                   // 0: proto.KeyType
	(DnsRegMethod)(0),              // 1: proto.DnsRegMethod
	(C2S_Transition)(0),            // 2: proto.C2S_Transition
	(S2C_Transition)(0),            // 3: proto.S2C_Transition
	(ErrorReasonS2C)(0),            // 4: proto.ErrorReasonS2C
	(TransportType)(0),             // 5: proto.TransportType
	(RegistrationSource)(0),        // 6: proto.RegistrationSource
	(StationOperations)(0),         // 7: proto.StationOperations
	(IPProto)(0),                   // 8: proto.IPProto
	(*PubKey)(nil),                 // 9: proto.PubKey
	(*TLSDecoySpec)(nil),           // 10: proto.TLSDecoySpec
	(*ClientConf)(nil),             // 11: proto.ClientConf
	(*DnsRegConf)(nil),             // 12: proto.DnsRegConf
	(*DecoyList)(nil),              // 13: proto.DecoyList
	(*PhantomSubnetsList)(nil),     // 14: proto.PhantomSubnetsList
	(*PhantomSubnets)(nil),         // 15: proto.PhantomSubnets
	(*WebRTCICECandidate)(nil),     // 16: proto.WebRTCICECandidate
	(*WebRTCSDP)(nil),              // 17: proto.WebRTCSDP
	(*WebRTCSignal)(nil),           // 18: proto.WebRTCSignal
	(*Addr)(nil),                   // 19: proto.Addr
	(*DTLSTransportParams)(nil),    // 20: proto.DTLSTransportParams
	(*StationToClient)(nil),        // 21: proto.StationToClient
	(*RegistrationFlags)(nil),      // 22: proto.RegistrationFlags
	(*ClientToStation)(nil),        // 23: proto.ClientToStation
	(*PrefixTransportParams)(nil),  // 24: proto.PrefixTransportParams
	(*GenericTransportParams)(nil), // 25: proto.GenericTransportParams
	(*C2SWrapper)(nil),             // 26: proto.C2SWrapper
	(*SessionStats)(nil),           // 27: proto.SessionStats
	(*StationToDetector)(nil),      // 28: proto.StationToDetector
	(*RegistrationResponse)(nil),   // 29: proto.RegistrationResponse
	(*DnsResponse)(nil),            // 30: proto.DnsResponse
	(*DnsPartReq)(nil),             // 31: proto.DnsPartReq
	(*DnsPartResp)(nil),            // 32: proto.DnsPartResp
	(*anypb.Any)(nil),              // 33: google.protobuf.Any
}
var file_signalling_proto_depIdxs = []int32{
	0,  // 0: proto.PubKey.type:type_name -> proto.KeyType
	9,  // 1: proto.TLSDecoySpec.pubkey:type_name -> proto.PubKey
	13, // 2: proto.ClientConf.decoy_list:type_name -> proto.DecoyList
	9,  // 3: proto.ClientConf.default_pubkey:type_name -> proto.PubKey
	14, // 4: proto.ClientConf.phantom_subnets_list:type_name -> proto.PhantomSubnetsList
	9,  // 5: proto.ClientConf.conjure_pubkey:type_name -> proto.PubKey
	12, // 6: proto.ClientConf.dns_reg_conf:type_name -> proto.DnsRegConf
	1,  // 7: proto.DnsRegConf.dns_reg_method:type_name -> proto.DnsRegMethod
	10, // 8: proto.DecoyList.tls_decoys:type_name -> proto.TLSDecoySpec
	15, // 9: proto.PhantomSubnetsList.weighted_subnets:type_name -> proto.PhantomSubnets
	16, // 10: proto.WebRTCSDP.candidates:type_name -> proto.WebRTCICECandidate
	17, // 11: proto.WebRTCSignal.sdp:type_name -> proto.WebRTCSDP
	19, // 12: proto.DTLSTransportParams.src_addr4:type_name -> proto.Addr
	19, // 13: proto.DTLSTransportParams.src_addr6:type_name -> proto.Addr
	3,  // 14: proto.StationToClient.state_transition:type_name -> proto.S2C_Transition
	11, // 15: proto.StationToClient.config_info:type_name -> proto.ClientConf
	4,  // 16: proto.StationToClient.err_reason:type_name -> proto.ErrorReasonS2C
	2,  // 17: proto.ClientToStation.state_transition:type_name -> proto.C2S_Transition
	27, // 18: proto.ClientToStation.stats:type_name -> proto.SessionStats
	5,  // 19: proto.ClientToStation.transport:type_name -> proto.TransportType
	33, // 20: proto.ClientToStation.transport_params:type_name -> google.protobuf.Any
	22, // 21: proto.ClientToStation.flags:type_name -> proto.RegistrationFlags
	18, // 22: proto.ClientToStation.webrtc_signal:type_name -> proto.WebRTCSignal
	23, // 23: proto.C2SWrapper.registration_payload:type_name -> proto.ClientToStation
	6,  // 24: proto.C2SWrapper.registration_source:type_name -> proto.RegistrationSource
	29, // 25: proto.C2SWrapper.registration_response:type_name -> proto.RegistrationResponse
	7,  // 26: proto.StationToDetector.operation:type_name -> proto.StationOperations
	8,  // 27: proto.StationToDetector.proto:type_name -> proto.IPProto
	11, // 28: proto.RegistrationResponse.clientConf:type_name -> proto.ClientConf
	33, // 29: proto.RegistrationResponse.transport_params:type_name -> google.protobuf.Any
	29, // 30: proto.DnsResponse.bidirectional_response:type_name -> proto.RegistrationResponse
	31, // [31:31] is the sub-list for method output_type
	31, // [31:31] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_signalling_proto_init() }
func file_signalling_proto_init() {
	if File_signalling_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_signalling_proto_rawDesc), len(file_signalling_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   24,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_signalling_proto_goTypes,
		DependencyIndexes: file_signalling_proto_depIdxs,
		EnumInfos:         file_signalling_proto_enumTypes,
		MessageInfos:      file_signalling_proto_msgTypes,
	}.Build()
	File_signalling_proto = out.File
	file_signalling_proto_goTypes = nil
	file_signalling_proto_depIdxs = nil
}
