// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `signalling.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct PubKey {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<KeyType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubKey {
    fn default() -> &'a PubKey {
        <PubKey as ::protobuf::Message>::default_instance()
    }
}

impl PubKey {
    pub fn new() -> PubKey {
        ::std::default::Default::default()
    }

    // optional bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.KeyType type = 2;


    pub fn get_field_type(&self) -> KeyType {
        self.field_type.unwrap_or(KeyType::AES_GCM_128)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: KeyType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PubKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubKey {
        PubKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &PubKey| { &m.key },
                |m: &mut PubKey| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KeyType>>(
                "type",
                |m: &PubKey| { &m.field_type },
                |m: &mut PubKey| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PubKey>(
                "PubKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PubKey {
        static instance: ::protobuf::rt::LazyV2<PubKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PubKey::new)
    }
}

impl ::protobuf::Clear for PubKey {
    fn clear(&mut self) {
        self.key.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TLSDecoySpec {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    ipv4addr: ::std::option::Option<u32>,
    ipv6addr: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub pubkey: ::protobuf::SingularPtrField<PubKey>,
    timeout: ::std::option::Option<u32>,
    tcpwin: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TLSDecoySpec {
    fn default() -> &'a TLSDecoySpec {
        <TLSDecoySpec as ::protobuf::Message>::default_instance()
    }
}

impl TLSDecoySpec {
    pub fn new() -> TLSDecoySpec {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;


    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 ipv4addr = 2;


    pub fn get_ipv4addr(&self) -> u32 {
        self.ipv4addr.unwrap_or(0)
    }
    pub fn clear_ipv4addr(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
    }

    pub fn has_ipv4addr(&self) -> bool {
        self.ipv4addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4addr(&mut self, v: u32) {
        self.ipv4addr = ::std::option::Option::Some(v);
    }

    // optional bytes ipv6addr = 6;


    pub fn get_ipv6addr(&self) -> &[u8] {
        match self.ipv6addr.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ipv6addr(&mut self) {
        self.ipv6addr.clear();
    }

    pub fn has_ipv6addr(&self) -> bool {
        self.ipv6addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ipv6addr.is_none() {
            self.ipv6addr.set_default();
        }
        self.ipv6addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6addr(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6addr.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.PubKey pubkey = 3;


    pub fn get_pubkey(&self) -> &PubKey {
        self.pubkey.as_ref().unwrap_or_else(|| <PubKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    pub fn has_pubkey(&self) -> bool {
        self.pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: PubKey) {
        self.pubkey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut PubKey {
        if self.pubkey.is_none() {
            self.pubkey.set_default();
        }
        self.pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_pubkey(&mut self) -> PubKey {
        self.pubkey.take().unwrap_or_else(|| PubKey::new())
    }

    // optional uint32 timeout = 4;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }

    // optional uint32 tcpwin = 5;


    pub fn get_tcpwin(&self) -> u32 {
        self.tcpwin.unwrap_or(0)
    }
    pub fn clear_tcpwin(&mut self) {
        self.tcpwin = ::std::option::Option::None;
    }

    pub fn has_tcpwin(&self) -> bool {
        self.tcpwin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpwin(&mut self, v: u32) {
        self.tcpwin = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TLSDecoySpec {
    fn is_initialized(&self) -> bool {
        for v in &self.pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ipv4addr = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ipv6addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pubkey)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcpwin = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ipv4addr {
            my_size += 5;
        }
        if let Some(ref v) = self.ipv6addr.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tcpwin {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.ipv4addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(ref v) = self.ipv6addr.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.pubkey.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tcpwin {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TLSDecoySpec {
        TLSDecoySpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &TLSDecoySpec| { &m.hostname },
                |m: &mut TLSDecoySpec| { &mut m.hostname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ipv4addr",
                |m: &TLSDecoySpec| { &m.ipv4addr },
                |m: &mut TLSDecoySpec| { &mut m.ipv4addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ipv6addr",
                |m: &TLSDecoySpec| { &m.ipv6addr },
                |m: &mut TLSDecoySpec| { &mut m.ipv6addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubKey>>(
                "pubkey",
                |m: &TLSDecoySpec| { &m.pubkey },
                |m: &mut TLSDecoySpec| { &mut m.pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &TLSDecoySpec| { &m.timeout },
                |m: &mut TLSDecoySpec| { &mut m.timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tcpwin",
                |m: &TLSDecoySpec| { &m.tcpwin },
                |m: &mut TLSDecoySpec| { &mut m.tcpwin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TLSDecoySpec>(
                "TLSDecoySpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TLSDecoySpec {
        static instance: ::protobuf::rt::LazyV2<TLSDecoySpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TLSDecoySpec::new)
    }
}

impl ::protobuf::Clear for TLSDecoySpec {
    fn clear(&mut self) {
        self.hostname.clear();
        self.ipv4addr = ::std::option::Option::None;
        self.ipv6addr.clear();
        self.pubkey.clear();
        self.timeout = ::std::option::Option::None;
        self.tcpwin = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TLSDecoySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TLSDecoySpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientConf {
    // message fields
    pub decoy_list: ::protobuf::SingularPtrField<DecoyList>,
    generation: ::std::option::Option<u32>,
    pub default_pubkey: ::protobuf::SingularPtrField<PubKey>,
    pub dark_decoy_blocks: ::protobuf::SingularPtrField<DarkDecoyBlocks>,
    pub conjure_pubkey: ::protobuf::SingularPtrField<PubKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientConf {
    fn default() -> &'a ClientConf {
        <ClientConf as ::protobuf::Message>::default_instance()
    }
}

impl ClientConf {
    pub fn new() -> ClientConf {
        ::std::default::Default::default()
    }

    // optional .tapdance.DecoyList decoy_list = 1;


    pub fn get_decoy_list(&self) -> &DecoyList {
        self.decoy_list.as_ref().unwrap_or_else(|| <DecoyList as ::protobuf::Message>::default_instance())
    }
    pub fn clear_decoy_list(&mut self) {
        self.decoy_list.clear();
    }

    pub fn has_decoy_list(&self) -> bool {
        self.decoy_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_list(&mut self, v: DecoyList) {
        self.decoy_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoy_list(&mut self) -> &mut DecoyList {
        if self.decoy_list.is_none() {
            self.decoy_list.set_default();
        }
        self.decoy_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_decoy_list(&mut self) -> DecoyList {
        self.decoy_list.take().unwrap_or_else(|| DecoyList::new())
    }

    // optional uint32 generation = 2;


    pub fn get_generation(&self) -> u32 {
        self.generation.unwrap_or(0)
    }
    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: u32) {
        self.generation = ::std::option::Option::Some(v);
    }

    // optional .tapdance.PubKey default_pubkey = 3;


    pub fn get_default_pubkey(&self) -> &PubKey {
        self.default_pubkey.as_ref().unwrap_or_else(|| <PubKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_pubkey(&mut self) {
        self.default_pubkey.clear();
    }

    pub fn has_default_pubkey(&self) -> bool {
        self.default_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_pubkey(&mut self, v: PubKey) {
        self.default_pubkey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_pubkey(&mut self) -> &mut PubKey {
        if self.default_pubkey.is_none() {
            self.default_pubkey.set_default();
        }
        self.default_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_pubkey(&mut self) -> PubKey {
        self.default_pubkey.take().unwrap_or_else(|| PubKey::new())
    }

    // optional .tapdance.DarkDecoyBlocks dark_decoy_blocks = 4;


    pub fn get_dark_decoy_blocks(&self) -> &DarkDecoyBlocks {
        self.dark_decoy_blocks.as_ref().unwrap_or_else(|| <DarkDecoyBlocks as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dark_decoy_blocks(&mut self) {
        self.dark_decoy_blocks.clear();
    }

    pub fn has_dark_decoy_blocks(&self) -> bool {
        self.dark_decoy_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dark_decoy_blocks(&mut self, v: DarkDecoyBlocks) {
        self.dark_decoy_blocks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dark_decoy_blocks(&mut self) -> &mut DarkDecoyBlocks {
        if self.dark_decoy_blocks.is_none() {
            self.dark_decoy_blocks.set_default();
        }
        self.dark_decoy_blocks.as_mut().unwrap()
    }

    // Take field
    pub fn take_dark_decoy_blocks(&mut self) -> DarkDecoyBlocks {
        self.dark_decoy_blocks.take().unwrap_or_else(|| DarkDecoyBlocks::new())
    }

    // optional .tapdance.PubKey conjure_pubkey = 5;


    pub fn get_conjure_pubkey(&self) -> &PubKey {
        self.conjure_pubkey.as_ref().unwrap_or_else(|| <PubKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conjure_pubkey(&mut self) {
        self.conjure_pubkey.clear();
    }

    pub fn has_conjure_pubkey(&self) -> bool {
        self.conjure_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conjure_pubkey(&mut self, v: PubKey) {
        self.conjure_pubkey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conjure_pubkey(&mut self) -> &mut PubKey {
        if self.conjure_pubkey.is_none() {
            self.conjure_pubkey.set_default();
        }
        self.conjure_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_conjure_pubkey(&mut self) -> PubKey {
        self.conjure_pubkey.take().unwrap_or_else(|| PubKey::new())
    }
}

impl ::protobuf::Message for ClientConf {
    fn is_initialized(&self) -> bool {
        for v in &self.decoy_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dark_decoy_blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conjure_pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.decoy_list)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.generation = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_pubkey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dark_decoy_blocks)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conjure_pubkey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.decoy_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.default_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dark_decoy_blocks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.conjure_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.decoy_list.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.generation {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.default_pubkey.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dark_decoy_blocks.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.conjure_pubkey.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientConf {
        ClientConf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DecoyList>>(
                "decoy_list",
                |m: &ClientConf| { &m.decoy_list },
                |m: &mut ClientConf| { &mut m.decoy_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "generation",
                |m: &ClientConf| { &m.generation },
                |m: &mut ClientConf| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubKey>>(
                "default_pubkey",
                |m: &ClientConf| { &m.default_pubkey },
                |m: &mut ClientConf| { &mut m.default_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DarkDecoyBlocks>>(
                "dark_decoy_blocks",
                |m: &ClientConf| { &m.dark_decoy_blocks },
                |m: &mut ClientConf| { &mut m.dark_decoy_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubKey>>(
                "conjure_pubkey",
                |m: &ClientConf| { &m.conjure_pubkey },
                |m: &mut ClientConf| { &mut m.conjure_pubkey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientConf>(
                "ClientConf",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientConf {
        static instance: ::protobuf::rt::LazyV2<ClientConf> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientConf::new)
    }
}

impl ::protobuf::Clear for ClientConf {
    fn clear(&mut self) {
        self.decoy_list.clear();
        self.generation = ::std::option::Option::None;
        self.default_pubkey.clear();
        self.dark_decoy_blocks.clear();
        self.conjure_pubkey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientConf {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecoyList {
    // message fields
    pub tls_decoys: ::protobuf::RepeatedField<TLSDecoySpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecoyList {
    fn default() -> &'a DecoyList {
        <DecoyList as ::protobuf::Message>::default_instance()
    }
}

impl DecoyList {
    pub fn new() -> DecoyList {
        ::std::default::Default::default()
    }

    // repeated .tapdance.TLSDecoySpec tls_decoys = 1;


    pub fn get_tls_decoys(&self) -> &[TLSDecoySpec] {
        &self.tls_decoys
    }
    pub fn clear_tls_decoys(&mut self) {
        self.tls_decoys.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls_decoys(&mut self, v: ::protobuf::RepeatedField<TLSDecoySpec>) {
        self.tls_decoys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tls_decoys(&mut self) -> &mut ::protobuf::RepeatedField<TLSDecoySpec> {
        &mut self.tls_decoys
    }

    // Take field
    pub fn take_tls_decoys(&mut self) -> ::protobuf::RepeatedField<TLSDecoySpec> {
        ::std::mem::replace(&mut self.tls_decoys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DecoyList {
    fn is_initialized(&self) -> bool {
        for v in &self.tls_decoys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tls_decoys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tls_decoys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tls_decoys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecoyList {
        DecoyList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TLSDecoySpec>>(
                "tls_decoys",
                |m: &DecoyList| { &m.tls_decoys },
                |m: &mut DecoyList| { &mut m.tls_decoys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecoyList>(
                "DecoyList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecoyList {
        static instance: ::protobuf::rt::LazyV2<DecoyList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecoyList::new)
    }
}

impl ::protobuf::Clear for DecoyList {
    fn clear(&mut self) {
        self.tls_decoys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecoyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecoyList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DarkDecoyBlocks {
    // message fields
    pub blocks: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DarkDecoyBlocks {
    fn default() -> &'a DarkDecoyBlocks {
        <DarkDecoyBlocks as ::protobuf::Message>::default_instance()
    }
}

impl DarkDecoyBlocks {
    pub fn new() -> DarkDecoyBlocks {
        ::std::default::Default::default()
    }

    // repeated string blocks = 1;


    pub fn get_blocks(&self) -> &[::std::string::String] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DarkDecoyBlocks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DarkDecoyBlocks {
        DarkDecoyBlocks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blocks",
                |m: &DarkDecoyBlocks| { &m.blocks },
                |m: &mut DarkDecoyBlocks| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DarkDecoyBlocks>(
                "DarkDecoyBlocks",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DarkDecoyBlocks {
        static instance: ::protobuf::rt::LazyV2<DarkDecoyBlocks> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DarkDecoyBlocks::new)
    }
}

impl ::protobuf::Clear for DarkDecoyBlocks {
    fn clear(&mut self) {
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DarkDecoyBlocks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DarkDecoyBlocks {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StationToClient {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    state_transition: ::std::option::Option<S2C_Transition>,
    pub config_info: ::protobuf::SingularPtrField<ClientConf>,
    err_reason: ::std::option::Option<ErrorReasonS2C>,
    tmp_backoff: ::std::option::Option<u32>,
    station_id: ::protobuf::SingularField<::std::string::String>,
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StationToClient {
    fn default() -> &'a StationToClient {
        <StationToClient as ::protobuf::Message>::default_instance()
    }
}

impl StationToClient {
    pub fn new() -> StationToClient {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional .tapdance.S2C_Transition state_transition = 2;


    pub fn get_state_transition(&self) -> S2C_Transition {
        self.state_transition.unwrap_or(S2C_Transition::S2C_NO_CHANGE)
    }
    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: S2C_Transition) {
        self.state_transition = ::std::option::Option::Some(v);
    }

    // optional .tapdance.ClientConf config_info = 3;


    pub fn get_config_info(&self) -> &ClientConf {
        self.config_info.as_ref().unwrap_or_else(|| <ClientConf as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config_info(&mut self) {
        self.config_info.clear();
    }

    pub fn has_config_info(&self) -> bool {
        self.config_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_info(&mut self, v: ClientConf) {
        self.config_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_info(&mut self) -> &mut ClientConf {
        if self.config_info.is_none() {
            self.config_info.set_default();
        }
        self.config_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_info(&mut self) -> ClientConf {
        self.config_info.take().unwrap_or_else(|| ClientConf::new())
    }

    // optional .tapdance.ErrorReasonS2C err_reason = 4;


    pub fn get_err_reason(&self) -> ErrorReasonS2C {
        self.err_reason.unwrap_or(ErrorReasonS2C::NO_ERROR)
    }
    pub fn clear_err_reason(&mut self) {
        self.err_reason = ::std::option::Option::None;
    }

    pub fn has_err_reason(&self) -> bool {
        self.err_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_err_reason(&mut self, v: ErrorReasonS2C) {
        self.err_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 tmp_backoff = 5;


    pub fn get_tmp_backoff(&self) -> u32 {
        self.tmp_backoff.unwrap_or(0)
    }
    pub fn clear_tmp_backoff(&mut self) {
        self.tmp_backoff = ::std::option::Option::None;
    }

    pub fn has_tmp_backoff(&self) -> bool {
        self.tmp_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tmp_backoff(&mut self, v: u32) {
        self.tmp_backoff = ::std::option::Option::Some(v);
    }

    // optional string station_id = 6;


    pub fn get_station_id(&self) -> &str {
        match self.station_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_station_id(&mut self) {
        self.station_id.clear();
    }

    pub fn has_station_id(&self) -> bool {
        self.station_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_id(&mut self, v: ::std::string::String) {
        self.station_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_station_id(&mut self) -> &mut ::std::string::String {
        if self.station_id.is_none() {
            self.station_id.set_default();
        }
        self.station_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_station_id(&mut self) -> ::std::string::String {
        self.station_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes padding = 100;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StationToClient {
    fn is_initialized(&self) -> bool {
        for v in &self.config_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state_transition, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config_info)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.err_reason, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tmp_backoff = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.station_id)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.config_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.err_reason {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.tmp_backoff {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.station_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.config_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.err_reason {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.tmp_backoff {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.station_id.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(100, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StationToClient {
        StationToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &StationToClient| { &m.protocol_version },
                |m: &mut StationToClient| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<S2C_Transition>>(
                "state_transition",
                |m: &StationToClient| { &m.state_transition },
                |m: &mut StationToClient| { &mut m.state_transition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientConf>>(
                "config_info",
                |m: &StationToClient| { &m.config_info },
                |m: &mut StationToClient| { &mut m.config_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ErrorReasonS2C>>(
                "err_reason",
                |m: &StationToClient| { &m.err_reason },
                |m: &mut StationToClient| { &mut m.err_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tmp_backoff",
                |m: &StationToClient| { &m.tmp_backoff },
                |m: &mut StationToClient| { &mut m.tmp_backoff },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "station_id",
                |m: &StationToClient| { &m.station_id },
                |m: &mut StationToClient| { &mut m.station_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &StationToClient| { &m.padding },
                |m: &mut StationToClient| { &mut m.padding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StationToClient>(
                "StationToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StationToClient {
        static instance: ::protobuf::rt::LazyV2<StationToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StationToClient::new)
    }
}

impl ::protobuf::Clear for StationToClient {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.config_info.clear();
        self.err_reason = ::std::option::Option::None;
        self.tmp_backoff = ::std::option::Option::None;
        self.station_id.clear();
        self.padding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StationToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationFlags {
    // message fields
    upload_only: ::std::option::Option<bool>,
    dark_decoy: ::std::option::Option<bool>,
    proxy_header: ::std::option::Option<bool>,
    use_TIL: ::std::option::Option<bool>,
    prescanned: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationFlags {
    fn default() -> &'a RegistrationFlags {
        <RegistrationFlags as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationFlags {
    pub fn new() -> RegistrationFlags {
        ::std::default::Default::default()
    }

    // optional bool upload_only = 1;


    pub fn get_upload_only(&self) -> bool {
        self.upload_only.unwrap_or(false)
    }
    pub fn clear_upload_only(&mut self) {
        self.upload_only = ::std::option::Option::None;
    }

    pub fn has_upload_only(&self) -> bool {
        self.upload_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_only(&mut self, v: bool) {
        self.upload_only = ::std::option::Option::Some(v);
    }

    // optional bool dark_decoy = 2;


    pub fn get_dark_decoy(&self) -> bool {
        self.dark_decoy.unwrap_or(false)
    }
    pub fn clear_dark_decoy(&mut self) {
        self.dark_decoy = ::std::option::Option::None;
    }

    pub fn has_dark_decoy(&self) -> bool {
        self.dark_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dark_decoy(&mut self, v: bool) {
        self.dark_decoy = ::std::option::Option::Some(v);
    }

    // optional bool proxy_header = 3;


    pub fn get_proxy_header(&self) -> bool {
        self.proxy_header.unwrap_or(false)
    }
    pub fn clear_proxy_header(&mut self) {
        self.proxy_header = ::std::option::Option::None;
    }

    pub fn has_proxy_header(&self) -> bool {
        self.proxy_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_header(&mut self, v: bool) {
        self.proxy_header = ::std::option::Option::Some(v);
    }

    // optional bool use_TIL = 4;


    pub fn get_use_TIL(&self) -> bool {
        self.use_TIL.unwrap_or(false)
    }
    pub fn clear_use_TIL(&mut self) {
        self.use_TIL = ::std::option::Option::None;
    }

    pub fn has_use_TIL(&self) -> bool {
        self.use_TIL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_TIL(&mut self, v: bool) {
        self.use_TIL = ::std::option::Option::Some(v);
    }

    // optional bool prescanned = 5;


    pub fn get_prescanned(&self) -> bool {
        self.prescanned.unwrap_or(false)
    }
    pub fn clear_prescanned(&mut self) {
        self.prescanned = ::std::option::Option::None;
    }

    pub fn has_prescanned(&self) -> bool {
        self.prescanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prescanned(&mut self, v: bool) {
        self.prescanned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RegistrationFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.upload_only = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dark_decoy = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.proxy_header = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_TIL = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prescanned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.upload_only {
            my_size += 2;
        }
        if let Some(v) = self.dark_decoy {
            my_size += 2;
        }
        if let Some(v) = self.proxy_header {
            my_size += 2;
        }
        if let Some(v) = self.use_TIL {
            my_size += 2;
        }
        if let Some(v) = self.prescanned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.upload_only {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dark_decoy {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.proxy_header {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.use_TIL {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.prescanned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationFlags {
        RegistrationFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "upload_only",
                |m: &RegistrationFlags| { &m.upload_only },
                |m: &mut RegistrationFlags| { &mut m.upload_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dark_decoy",
                |m: &RegistrationFlags| { &m.dark_decoy },
                |m: &mut RegistrationFlags| { &mut m.dark_decoy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "proxy_header",
                |m: &RegistrationFlags| { &m.proxy_header },
                |m: &mut RegistrationFlags| { &mut m.proxy_header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_TIL",
                |m: &RegistrationFlags| { &m.use_TIL },
                |m: &mut RegistrationFlags| { &mut m.use_TIL },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prescanned",
                |m: &RegistrationFlags| { &m.prescanned },
                |m: &mut RegistrationFlags| { &mut m.prescanned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationFlags>(
                "RegistrationFlags",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationFlags {
        static instance: ::protobuf::rt::LazyV2<RegistrationFlags> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationFlags::new)
    }
}

impl ::protobuf::Clear for RegistrationFlags {
    fn clear(&mut self) {
        self.upload_only = ::std::option::Option::None;
        self.dark_decoy = ::std::option::Option::None;
        self.proxy_header = ::std::option::Option::None;
        self.use_TIL = ::std::option::Option::None;
        self.prescanned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientToStation {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    decoy_list_generation: ::std::option::Option<u32>,
    state_transition: ::std::option::Option<C2S_Transition>,
    upload_sync: ::std::option::Option<u64>,
    pub failed_decoys: ::protobuf::RepeatedField<::std::string::String>,
    pub stats: ::protobuf::SingularPtrField<SessionStats>,
    transport: ::std::option::Option<TransportType>,
    covert_address: ::protobuf::SingularField<::std::string::String>,
    masked_decoy_server_name: ::protobuf::SingularField<::std::string::String>,
    v6_support: ::std::option::Option<bool>,
    v4_support: ::std::option::Option<bool>,
    pub flags: ::protobuf::SingularPtrField<RegistrationFlags>,
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientToStation {
    fn default() -> &'a ClientToStation {
        <ClientToStation as ::protobuf::Message>::default_instance()
    }
}

impl ClientToStation {
    pub fn new() -> ClientToStation {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 decoy_list_generation = 2;


    pub fn get_decoy_list_generation(&self) -> u32 {
        self.decoy_list_generation.unwrap_or(0)
    }
    pub fn clear_decoy_list_generation(&mut self) {
        self.decoy_list_generation = ::std::option::Option::None;
    }

    pub fn has_decoy_list_generation(&self) -> bool {
        self.decoy_list_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_list_generation(&mut self, v: u32) {
        self.decoy_list_generation = ::std::option::Option::Some(v);
    }

    // optional .tapdance.C2S_Transition state_transition = 3;


    pub fn get_state_transition(&self) -> C2S_Transition {
        self.state_transition.unwrap_or(C2S_Transition::C2S_NO_CHANGE)
    }
    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: C2S_Transition) {
        self.state_transition = ::std::option::Option::Some(v);
    }

    // optional uint64 upload_sync = 4;


    pub fn get_upload_sync(&self) -> u64 {
        self.upload_sync.unwrap_or(0)
    }
    pub fn clear_upload_sync(&mut self) {
        self.upload_sync = ::std::option::Option::None;
    }

    pub fn has_upload_sync(&self) -> bool {
        self.upload_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_sync(&mut self, v: u64) {
        self.upload_sync = ::std::option::Option::Some(v);
    }

    // repeated string failed_decoys = 10;


    pub fn get_failed_decoys(&self) -> &[::std::string::String] {
        &self.failed_decoys
    }
    pub fn clear_failed_decoys(&mut self) {
        self.failed_decoys.clear();
    }

    // Param is passed by value, moved
    pub fn set_failed_decoys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.failed_decoys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failed_decoys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.failed_decoys
    }

    // Take field
    pub fn take_failed_decoys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.failed_decoys, ::protobuf::RepeatedField::new())
    }

    // optional .tapdance.SessionStats stats = 11;


    pub fn get_stats(&self) -> &SessionStats {
        self.stats.as_ref().unwrap_or_else(|| <SessionStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: SessionStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut SessionStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> SessionStats {
        self.stats.take().unwrap_or_else(|| SessionStats::new())
    }

    // optional .tapdance.TransportType transport = 12;


    pub fn get_transport(&self) -> TransportType {
        self.transport.unwrap_or(TransportType::Null)
    }
    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: TransportType) {
        self.transport = ::std::option::Option::Some(v);
    }

    // optional string covert_address = 20;


    pub fn get_covert_address(&self) -> &str {
        match self.covert_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_covert_address(&mut self) {
        self.covert_address.clear();
    }

    pub fn has_covert_address(&self) -> bool {
        self.covert_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_covert_address(&mut self, v: ::std::string::String) {
        self.covert_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_covert_address(&mut self) -> &mut ::std::string::String {
        if self.covert_address.is_none() {
            self.covert_address.set_default();
        }
        self.covert_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_covert_address(&mut self) -> ::std::string::String {
        self.covert_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string masked_decoy_server_name = 21;


    pub fn get_masked_decoy_server_name(&self) -> &str {
        match self.masked_decoy_server_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_masked_decoy_server_name(&mut self) {
        self.masked_decoy_server_name.clear();
    }

    pub fn has_masked_decoy_server_name(&self) -> bool {
        self.masked_decoy_server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked_decoy_server_name(&mut self, v: ::std::string::String) {
        self.masked_decoy_server_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked_decoy_server_name(&mut self) -> &mut ::std::string::String {
        if self.masked_decoy_server_name.is_none() {
            self.masked_decoy_server_name.set_default();
        }
        self.masked_decoy_server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked_decoy_server_name(&mut self) -> ::std::string::String {
        self.masked_decoy_server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool v6_support = 22;


    pub fn get_v6_support(&self) -> bool {
        self.v6_support.unwrap_or(false)
    }
    pub fn clear_v6_support(&mut self) {
        self.v6_support = ::std::option::Option::None;
    }

    pub fn has_v6_support(&self) -> bool {
        self.v6_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v6_support(&mut self, v: bool) {
        self.v6_support = ::std::option::Option::Some(v);
    }

    // optional bool v4_support = 23;


    pub fn get_v4_support(&self) -> bool {
        self.v4_support.unwrap_or(false)
    }
    pub fn clear_v4_support(&mut self) {
        self.v4_support = ::std::option::Option::None;
    }

    pub fn has_v4_support(&self) -> bool {
        self.v4_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v4_support(&mut self, v: bool) {
        self.v4_support = ::std::option::Option::Some(v);
    }

    // optional .tapdance.RegistrationFlags flags = 24;


    pub fn get_flags(&self) -> &RegistrationFlags {
        self.flags.as_ref().unwrap_or_else(|| <RegistrationFlags as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: RegistrationFlags) {
        self.flags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&mut self) -> &mut RegistrationFlags {
        if self.flags.is_none() {
            self.flags.set_default();
        }
        self.flags.as_mut().unwrap()
    }

    // Take field
    pub fn take_flags(&mut self) -> RegistrationFlags {
        self.flags.take().unwrap_or_else(|| RegistrationFlags::new())
    }

    // optional bytes padding = 100;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ClientToStation {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.decoy_list_generation = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state_transition, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upload_sync = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.failed_decoys)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                12 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.transport, 12, &mut self.unknown_fields)?
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.covert_address)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.masked_decoy_server_name)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.v6_support = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.v4_support = ::std::option::Option::Some(tmp);
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flags)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.decoy_list_generation {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.upload_sync {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.failed_decoys {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::enum_size(12, v);
        }
        if let Some(ref v) = self.covert_address.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.masked_decoy_server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.v6_support {
            my_size += 3;
        }
        if let Some(v) = self.v4_support {
            my_size += 3;
        }
        if let Some(ref v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.decoy_list_generation {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.upload_sync {
            os.write_uint64(4, v)?;
        }
        for v in &self.failed_decoys {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.covert_address.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.masked_decoy_server_name.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(v) = self.v6_support {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.v4_support {
            os.write_bool(23, v)?;
        }
        if let Some(ref v) = self.flags.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(100, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientToStation {
        ClientToStation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &ClientToStation| { &m.protocol_version },
                |m: &mut ClientToStation| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "decoy_list_generation",
                |m: &ClientToStation| { &m.decoy_list_generation },
                |m: &mut ClientToStation| { &mut m.decoy_list_generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<C2S_Transition>>(
                "state_transition",
                |m: &ClientToStation| { &m.state_transition },
                |m: &mut ClientToStation| { &mut m.state_transition },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upload_sync",
                |m: &ClientToStation| { &m.upload_sync },
                |m: &mut ClientToStation| { &mut m.upload_sync },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "failed_decoys",
                |m: &ClientToStation| { &m.failed_decoys },
                |m: &mut ClientToStation| { &mut m.failed_decoys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SessionStats>>(
                "stats",
                |m: &ClientToStation| { &m.stats },
                |m: &mut ClientToStation| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransportType>>(
                "transport",
                |m: &ClientToStation| { &m.transport },
                |m: &mut ClientToStation| { &mut m.transport },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "covert_address",
                |m: &ClientToStation| { &m.covert_address },
                |m: &mut ClientToStation| { &mut m.covert_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "masked_decoy_server_name",
                |m: &ClientToStation| { &m.masked_decoy_server_name },
                |m: &mut ClientToStation| { &mut m.masked_decoy_server_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "v6_support",
                |m: &ClientToStation| { &m.v6_support },
                |m: &mut ClientToStation| { &mut m.v6_support },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "v4_support",
                |m: &ClientToStation| { &m.v4_support },
                |m: &mut ClientToStation| { &mut m.v4_support },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegistrationFlags>>(
                "flags",
                |m: &ClientToStation| { &m.flags },
                |m: &mut ClientToStation| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &ClientToStation| { &m.padding },
                |m: &mut ClientToStation| { &mut m.padding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientToStation>(
                "ClientToStation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientToStation {
        static instance: ::protobuf::rt::LazyV2<ClientToStation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientToStation::new)
    }
}

impl ::protobuf::Clear for ClientToStation {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.decoy_list_generation = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.upload_sync = ::std::option::Option::None;
        self.failed_decoys.clear();
        self.stats.clear();
        self.transport = ::std::option::Option::None;
        self.covert_address.clear();
        self.masked_decoy_server_name.clear();
        self.v6_support = ::std::option::Option::None;
        self.v4_support = ::std::option::Option::None;
        self.flags.clear();
        self.padding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientToStation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientToStation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct C2SWrapper {
    // message fields
    shared_secret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub registration_payload: ::protobuf::SingularPtrField<ClientToStation>,
    registration_source: ::std::option::Option<RegistrationSource>,
    registration_address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    decoy_address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2SWrapper {
    fn default() -> &'a C2SWrapper {
        <C2SWrapper as ::protobuf::Message>::default_instance()
    }
}

impl C2SWrapper {
    pub fn new() -> C2SWrapper {
        ::std::default::Default::default()
    }

    // optional bytes shared_secret = 1;


    pub fn get_shared_secret(&self) -> &[u8] {
        match self.shared_secret.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_shared_secret(&mut self) {
        self.shared_secret.clear();
    }

    pub fn has_shared_secret(&self) -> bool {
        self.shared_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.shared_secret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shared_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.shared_secret.is_none() {
            self.shared_secret.set_default();
        }
        self.shared_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_shared_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.shared_secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.ClientToStation registration_payload = 3;


    pub fn get_registration_payload(&self) -> &ClientToStation {
        self.registration_payload.as_ref().unwrap_or_else(|| <ClientToStation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration_payload(&mut self) {
        self.registration_payload.clear();
    }

    pub fn has_registration_payload(&self) -> bool {
        self.registration_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_payload(&mut self, v: ClientToStation) {
        self.registration_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_payload(&mut self) -> &mut ClientToStation {
        if self.registration_payload.is_none() {
            self.registration_payload.set_default();
        }
        self.registration_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_payload(&mut self) -> ClientToStation {
        self.registration_payload.take().unwrap_or_else(|| ClientToStation::new())
    }

    // optional .tapdance.RegistrationSource registration_source = 4;


    pub fn get_registration_source(&self) -> RegistrationSource {
        self.registration_source.unwrap_or(RegistrationSource::Unspecified)
    }
    pub fn clear_registration_source(&mut self) {
        self.registration_source = ::std::option::Option::None;
    }

    pub fn has_registration_source(&self) -> bool {
        self.registration_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_source(&mut self, v: RegistrationSource) {
        self.registration_source = ::std::option::Option::Some(v);
    }

    // optional bytes registration_address = 6;


    pub fn get_registration_address(&self) -> &[u8] {
        match self.registration_address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_registration_address(&mut self) {
        self.registration_address.clear();
    }

    pub fn has_registration_address(&self) -> bool {
        self.registration_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.registration_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.registration_address.is_none() {
            self.registration_address.set_default();
        }
        self.registration_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_address(&mut self) -> ::std::vec::Vec<u8> {
        self.registration_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes decoy_address = 7;


    pub fn get_decoy_address(&self) -> &[u8] {
        match self.decoy_address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_decoy_address(&mut self) {
        self.decoy_address.clear();
    }

    pub fn has_decoy_address(&self) -> bool {
        self.decoy_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.decoy_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoy_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.decoy_address.is_none() {
            self.decoy_address.set_default();
        }
        self.decoy_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_decoy_address(&mut self) -> ::std::vec::Vec<u8> {
        self.decoy_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for C2SWrapper {
    fn is_initialized(&self) -> bool {
        for v in &self.registration_payload {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.shared_secret)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration_payload)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.registration_source, 4, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.registration_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.decoy_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shared_secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.registration_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.registration_source {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.registration_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.decoy_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shared_secret.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.registration_payload.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.registration_source {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.registration_address.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.decoy_address.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2SWrapper {
        C2SWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "shared_secret",
                |m: &C2SWrapper| { &m.shared_secret },
                |m: &mut C2SWrapper| { &mut m.shared_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientToStation>>(
                "registration_payload",
                |m: &C2SWrapper| { &m.registration_payload },
                |m: &mut C2SWrapper| { &mut m.registration_payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RegistrationSource>>(
                "registration_source",
                |m: &C2SWrapper| { &m.registration_source },
                |m: &mut C2SWrapper| { &mut m.registration_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "registration_address",
                |m: &C2SWrapper| { &m.registration_address },
                |m: &mut C2SWrapper| { &mut m.registration_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "decoy_address",
                |m: &C2SWrapper| { &m.decoy_address },
                |m: &mut C2SWrapper| { &mut m.decoy_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<C2SWrapper>(
                "C2SWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static C2SWrapper {
        static instance: ::protobuf::rt::LazyV2<C2SWrapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2SWrapper::new)
    }
}

impl ::protobuf::Clear for C2SWrapper {
    fn clear(&mut self) {
        self.shared_secret.clear();
        self.registration_payload.clear();
        self.registration_source = ::std::option::Option::None;
        self.registration_address.clear();
        self.decoy_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for C2SWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for C2SWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SessionStats {
    // message fields
    failed_decoys_amount: ::std::option::Option<u32>,
    total_time_to_connect: ::std::option::Option<u32>,
    rtt_to_station: ::std::option::Option<u32>,
    tls_to_decoy: ::std::option::Option<u32>,
    tcp_to_decoy: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionStats {
    fn default() -> &'a SessionStats {
        <SessionStats as ::protobuf::Message>::default_instance()
    }
}

impl SessionStats {
    pub fn new() -> SessionStats {
        ::std::default::Default::default()
    }

    // optional uint32 failed_decoys_amount = 20;


    pub fn get_failed_decoys_amount(&self) -> u32 {
        self.failed_decoys_amount.unwrap_or(0)
    }
    pub fn clear_failed_decoys_amount(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
    }

    pub fn has_failed_decoys_amount(&self) -> bool {
        self.failed_decoys_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_decoys_amount(&mut self, v: u32) {
        self.failed_decoys_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 total_time_to_connect = 31;


    pub fn get_total_time_to_connect(&self) -> u32 {
        self.total_time_to_connect.unwrap_or(0)
    }
    pub fn clear_total_time_to_connect(&mut self) {
        self.total_time_to_connect = ::std::option::Option::None;
    }

    pub fn has_total_time_to_connect(&self) -> bool {
        self.total_time_to_connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_time_to_connect(&mut self, v: u32) {
        self.total_time_to_connect = ::std::option::Option::Some(v);
    }

    // optional uint32 rtt_to_station = 33;


    pub fn get_rtt_to_station(&self) -> u32 {
        self.rtt_to_station.unwrap_or(0)
    }
    pub fn clear_rtt_to_station(&mut self) {
        self.rtt_to_station = ::std::option::Option::None;
    }

    pub fn has_rtt_to_station(&self) -> bool {
        self.rtt_to_station.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtt_to_station(&mut self, v: u32) {
        self.rtt_to_station = ::std::option::Option::Some(v);
    }

    // optional uint32 tls_to_decoy = 38;


    pub fn get_tls_to_decoy(&self) -> u32 {
        self.tls_to_decoy.unwrap_or(0)
    }
    pub fn clear_tls_to_decoy(&mut self) {
        self.tls_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tls_to_decoy(&self) -> bool {
        self.tls_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls_to_decoy(&mut self, v: u32) {
        self.tls_to_decoy = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_to_decoy = 39;


    pub fn get_tcp_to_decoy(&self) -> u32 {
        self.tcp_to_decoy.unwrap_or(0)
    }
    pub fn clear_tcp_to_decoy(&mut self) {
        self.tcp_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tcp_to_decoy(&self) -> bool {
        self.tcp_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_to_decoy(&mut self, v: u32) {
        self.tcp_to_decoy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SessionStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.failed_decoys_amount = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_time_to_connect = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtt_to_station = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tls_to_decoy = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcp_to_decoy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.failed_decoys_amount {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_time_to_connect {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtt_to_station {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tls_to_decoy {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tcp_to_decoy {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.failed_decoys_amount {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.total_time_to_connect {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.rtt_to_station {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.tls_to_decoy {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.tcp_to_decoy {
            os.write_uint32(39, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionStats {
        SessionStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "failed_decoys_amount",
                |m: &SessionStats| { &m.failed_decoys_amount },
                |m: &mut SessionStats| { &mut m.failed_decoys_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_time_to_connect",
                |m: &SessionStats| { &m.total_time_to_connect },
                |m: &mut SessionStats| { &mut m.total_time_to_connect },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rtt_to_station",
                |m: &SessionStats| { &m.rtt_to_station },
                |m: &mut SessionStats| { &mut m.rtt_to_station },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tls_to_decoy",
                |m: &SessionStats| { &m.tls_to_decoy },
                |m: &mut SessionStats| { &mut m.tls_to_decoy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tcp_to_decoy",
                |m: &SessionStats| { &m.tcp_to_decoy },
                |m: &mut SessionStats| { &mut m.tcp_to_decoy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionStats>(
                "SessionStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SessionStats {
        static instance: ::protobuf::rt::LazyV2<SessionStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SessionStats::new)
    }
}

impl ::protobuf::Clear for SessionStats {
    fn clear(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
        self.total_time_to_connect = ::std::option::Option::None;
        self.rtt_to_station = ::std::option::Option::None;
        self.tls_to_decoy = ::std::option::Option::None;
        self.tcp_to_decoy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StationToDetector {
    // message fields
    phantom_ip: ::protobuf::SingularField<::std::string::String>,
    client_ip: ::protobuf::SingularField<::std::string::String>,
    timeout_ns: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StationToDetector {
    fn default() -> &'a StationToDetector {
        <StationToDetector as ::protobuf::Message>::default_instance()
    }
}

impl StationToDetector {
    pub fn new() -> StationToDetector {
        ::std::default::Default::default()
    }

    // optional string phantom_ip = 1;


    pub fn get_phantom_ip(&self) -> &str {
        match self.phantom_ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phantom_ip(&mut self) {
        self.phantom_ip.clear();
    }

    pub fn has_phantom_ip(&self) -> bool {
        self.phantom_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phantom_ip(&mut self, v: ::std::string::String) {
        self.phantom_ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phantom_ip(&mut self) -> &mut ::std::string::String {
        if self.phantom_ip.is_none() {
            self.phantom_ip.set_default();
        }
        self.phantom_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_phantom_ip(&mut self) -> ::std::string::String {
        self.phantom_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string client_ip = 2;


    pub fn get_client_ip(&self) -> &str {
        match self.client_ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_ip(&mut self) {
        self.client_ip.clear();
    }

    pub fn has_client_ip(&self) -> bool {
        self.client_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_ip(&mut self, v: ::std::string::String) {
        self.client_ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_ip(&mut self) -> &mut ::std::string::String {
        if self.client_ip.is_none() {
            self.client_ip.set_default();
        }
        self.client_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_ip(&mut self) -> ::std::string::String {
        self.client_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timeout_ns = 3;


    pub fn get_timeout_ns(&self) -> u64 {
        self.timeout_ns.unwrap_or(0)
    }
    pub fn clear_timeout_ns(&mut self) {
        self.timeout_ns = ::std::option::Option::None;
    }

    pub fn has_timeout_ns(&self) -> bool {
        self.timeout_ns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ns(&mut self, v: u64) {
        self.timeout_ns = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StationToDetector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phantom_ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_ip)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout_ns = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phantom_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.client_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timeout_ns {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phantom_ip.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.client_ip.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.timeout_ns {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StationToDetector {
        StationToDetector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phantom_ip",
                |m: &StationToDetector| { &m.phantom_ip },
                |m: &mut StationToDetector| { &mut m.phantom_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_ip",
                |m: &StationToDetector| { &m.client_ip },
                |m: &mut StationToDetector| { &mut m.client_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeout_ns",
                |m: &StationToDetector| { &m.timeout_ns },
                |m: &mut StationToDetector| { &mut m.timeout_ns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StationToDetector>(
                "StationToDetector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StationToDetector {
        static instance: ::protobuf::rt::LazyV2<StationToDetector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StationToDetector::new)
    }
}

impl ::protobuf::Clear for StationToDetector {
    fn clear(&mut self) {
        self.phantom_ip.clear();
        self.client_ip.clear();
        self.timeout_ns = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StationToDetector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToDetector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KeyType {
    AES_GCM_128 = 90,
    AES_GCM_256 = 91,
}

impl ::protobuf::ProtobufEnum for KeyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyType> {
        match value {
            90 => ::std::option::Option::Some(KeyType::AES_GCM_128),
            91 => ::std::option::Option::Some(KeyType::AES_GCM_256),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KeyType] = &[
            KeyType::AES_GCM_128,
            KeyType::AES_GCM_256,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<KeyType>("KeyType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for KeyType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for KeyType {
    fn default() -> Self {
        KeyType::AES_GCM_128
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum C2S_Transition {
    C2S_NO_CHANGE = 0,
    C2S_SESSION_INIT = 1,
    C2S_SESSION_COVERT_INIT = 11,
    C2S_EXPECT_RECONNECT = 2,
    C2S_SESSION_CLOSE = 3,
    C2S_YIELD_UPLOAD = 4,
    C2S_ACQUIRE_UPLOAD = 5,
    C2S_EXPECT_UPLOADONLY_RECONN = 6,
    C2S_ERROR = 255,
}

impl ::protobuf::ProtobufEnum for C2S_Transition {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<C2S_Transition> {
        match value {
            0 => ::std::option::Option::Some(C2S_Transition::C2S_NO_CHANGE),
            1 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_INIT),
            11 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_RECONNECT),
            3 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_CLOSE),
            4 => ::std::option::Option::Some(C2S_Transition::C2S_YIELD_UPLOAD),
            5 => ::std::option::Option::Some(C2S_Transition::C2S_ACQUIRE_UPLOAD),
            6 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN),
            255 => ::std::option::Option::Some(C2S_Transition::C2S_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [C2S_Transition] = &[
            C2S_Transition::C2S_NO_CHANGE,
            C2S_Transition::C2S_SESSION_INIT,
            C2S_Transition::C2S_SESSION_COVERT_INIT,
            C2S_Transition::C2S_EXPECT_RECONNECT,
            C2S_Transition::C2S_SESSION_CLOSE,
            C2S_Transition::C2S_YIELD_UPLOAD,
            C2S_Transition::C2S_ACQUIRE_UPLOAD,
            C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN,
            C2S_Transition::C2S_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<C2S_Transition>("C2S_Transition", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for C2S_Transition {
}

impl ::std::default::Default for C2S_Transition {
    fn default() -> Self {
        C2S_Transition::C2S_NO_CHANGE
    }
}

impl ::protobuf::reflect::ProtobufValue for C2S_Transition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum S2C_Transition {
    S2C_NO_CHANGE = 0,
    S2C_SESSION_INIT = 1,
    S2C_SESSION_COVERT_INIT = 11,
    S2C_CONFIRM_RECONNECT = 2,
    S2C_SESSION_CLOSE = 3,
    S2C_ERROR = 255,
}

impl ::protobuf::ProtobufEnum for S2C_Transition {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<S2C_Transition> {
        match value {
            0 => ::std::option::Option::Some(S2C_Transition::S2C_NO_CHANGE),
            1 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_INIT),
            11 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(S2C_Transition::S2C_CONFIRM_RECONNECT),
            3 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_CLOSE),
            255 => ::std::option::Option::Some(S2C_Transition::S2C_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [S2C_Transition] = &[
            S2C_Transition::S2C_NO_CHANGE,
            S2C_Transition::S2C_SESSION_INIT,
            S2C_Transition::S2C_SESSION_COVERT_INIT,
            S2C_Transition::S2C_CONFIRM_RECONNECT,
            S2C_Transition::S2C_SESSION_CLOSE,
            S2C_Transition::S2C_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<S2C_Transition>("S2C_Transition", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for S2C_Transition {
}

impl ::std::default::Default for S2C_Transition {
    fn default() -> Self {
        S2C_Transition::S2C_NO_CHANGE
    }
}

impl ::protobuf::reflect::ProtobufValue for S2C_Transition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrorReasonS2C {
    NO_ERROR = 0,
    COVERT_STREAM = 1,
    CLIENT_REPORTED = 2,
    CLIENT_PROTOCOL = 3,
    STATION_INTERNAL = 4,
    DECOY_OVERLOAD = 5,
    CLIENT_STREAM = 100,
    CLIENT_TIMEOUT = 101,
}

impl ::protobuf::ProtobufEnum for ErrorReasonS2C {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorReasonS2C> {
        match value {
            0 => ::std::option::Option::Some(ErrorReasonS2C::NO_ERROR),
            1 => ::std::option::Option::Some(ErrorReasonS2C::COVERT_STREAM),
            2 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_REPORTED),
            3 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_PROTOCOL),
            4 => ::std::option::Option::Some(ErrorReasonS2C::STATION_INTERNAL),
            5 => ::std::option::Option::Some(ErrorReasonS2C::DECOY_OVERLOAD),
            100 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_STREAM),
            101 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrorReasonS2C] = &[
            ErrorReasonS2C::NO_ERROR,
            ErrorReasonS2C::COVERT_STREAM,
            ErrorReasonS2C::CLIENT_REPORTED,
            ErrorReasonS2C::CLIENT_PROTOCOL,
            ErrorReasonS2C::STATION_INTERNAL,
            ErrorReasonS2C::DECOY_OVERLOAD,
            ErrorReasonS2C::CLIENT_STREAM,
            ErrorReasonS2C::CLIENT_TIMEOUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ErrorReasonS2C>("ErrorReasonS2C", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ErrorReasonS2C {
}

impl ::std::default::Default for ErrorReasonS2C {
    fn default() -> Self {
        ErrorReasonS2C::NO_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorReasonS2C {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransportType {
    Null = 0,
    Min = 1,
    Obfs4 = 2,
}

impl ::protobuf::ProtobufEnum for TransportType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransportType> {
        match value {
            0 => ::std::option::Option::Some(TransportType::Null),
            1 => ::std::option::Option::Some(TransportType::Min),
            2 => ::std::option::Option::Some(TransportType::Obfs4),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransportType] = &[
            TransportType::Null,
            TransportType::Min,
            TransportType::Obfs4,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TransportType>("TransportType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TransportType {
}

impl ::std::default::Default for TransportType {
    fn default() -> Self {
        TransportType::Null
    }
}

impl ::protobuf::reflect::ProtobufValue for TransportType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RegistrationSource {
    Unspecified = 0,
    Detector = 1,
    API = 2,
    DetectorPrescan = 3,
}

impl ::protobuf::ProtobufEnum for RegistrationSource {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RegistrationSource> {
        match value {
            0 => ::std::option::Option::Some(RegistrationSource::Unspecified),
            1 => ::std::option::Option::Some(RegistrationSource::Detector),
            2 => ::std::option::Option::Some(RegistrationSource::API),
            3 => ::std::option::Option::Some(RegistrationSource::DetectorPrescan),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RegistrationSource] = &[
            RegistrationSource::Unspecified,
            RegistrationSource::Detector,
            RegistrationSource::API,
            RegistrationSource::DetectorPrescan,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RegistrationSource>("RegistrationSource", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RegistrationSource {
}

impl ::std::default::Default for RegistrationSource {
    fn default() -> Self {
        RegistrationSource::Unspecified
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10signalling.proto\x12\x08tapdance\"A\n\x06PubKey\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x0cR\x03key\x12%\n\x04type\x18\x02\x20\x01(\x0e2\x11.t\
    apdance.KeyTypeR\x04type\"\xbe\x01\n\x0cTLSDecoySpec\x12\x1a\n\x08hostna\
    me\x18\x01\x20\x01(\tR\x08hostname\x12\x1a\n\x08ipv4addr\x18\x02\x20\x01\
    (\x07R\x08ipv4addr\x12\x1a\n\x08ipv6addr\x18\x06\x20\x01(\x0cR\x08ipv6ad\
    dr\x12(\n\x06pubkey\x18\x03\x20\x01(\x0b2\x10.tapdance.PubKeyR\x06pubkey\
    \x12\x18\n\x07timeout\x18\x04\x20\x01(\rR\x07timeout\x12\x16\n\x06tcpwin\
    \x18\x05\x20\x01(\rR\x06tcpwin\"\x99\x02\n\nClientConf\x122\n\ndecoy_lis\
    t\x18\x01\x20\x01(\x0b2\x13.tapdance.DecoyListR\tdecoyList\x12\x1e\n\nge\
    neration\x18\x02\x20\x01(\rR\ngeneration\x127\n\x0edefault_pubkey\x18\
    \x03\x20\x01(\x0b2\x10.tapdance.PubKeyR\rdefaultPubkey\x12E\n\x11dark_de\
    coy_blocks\x18\x04\x20\x01(\x0b2\x19.tapdance.DarkDecoyBlocksR\x0fdarkDe\
    coyBlocks\x127\n\x0econjure_pubkey\x18\x05\x20\x01(\x0b2\x10.tapdance.Pu\
    bKeyR\rconjurePubkey\"B\n\tDecoyList\x125\n\ntls_decoys\x18\x01\x20\x03(\
    \x0b2\x16.tapdance.TLSDecoySpecR\ttlsDecoys\")\n\x0fDarkDecoyBlocks\x12\
    \x16\n\x06blocks\x18\x01\x20\x03(\tR\x06blocks\"\xcb\x02\n\x0fStationToC\
    lient\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\x0fprotocolVersion\
    \x12C\n\x10state_transition\x18\x02\x20\x01(\x0e2\x18.tapdance.S2C_Trans\
    itionR\x0fstateTransition\x125\n\x0bconfig_info\x18\x03\x20\x01(\x0b2\
    \x14.tapdance.ClientConfR\nconfigInfo\x127\n\nerr_reason\x18\x04\x20\x01\
    (\x0e2\x18.tapdance.ErrorReasonS2CR\terrReason\x12\x1f\n\x0btmp_backoff\
    \x18\x05\x20\x01(\rR\ntmpBackoff\x12\x1d\n\nstation_id\x18\x06\x20\x01(\
    \tR\tstationId\x12\x18\n\x07padding\x18d\x20\x01(\x0cR\x07padding\"\xaf\
    \x01\n\x11RegistrationFlags\x12\x1f\n\x0bupload_only\x18\x01\x20\x01(\
    \x08R\nuploadOnly\x12\x1d\n\ndark_decoy\x18\x02\x20\x01(\x08R\tdarkDecoy\
    \x12!\n\x0cproxy_header\x18\x03\x20\x01(\x08R\x0bproxyHeader\x12\x17\n\
    \x07use_TIL\x18\x04\x20\x01(\x08R\x06useTIL\x12\x1e\n\nprescanned\x18\
    \x05\x20\x01(\x08R\nprescanned\"\xcb\x04\n\x0fClientToStation\x12)\n\x10\
    protocol_version\x18\x01\x20\x01(\rR\x0fprotocolVersion\x122\n\x15decoy_\
    list_generation\x18\x02\x20\x01(\rR\x13decoyListGeneration\x12C\n\x10sta\
    te_transition\x18\x03\x20\x01(\x0e2\x18.tapdance.C2S_TransitionR\x0fstat\
    eTransition\x12\x1f\n\x0bupload_sync\x18\x04\x20\x01(\x04R\nuploadSync\
    \x12#\n\rfailed_decoys\x18\n\x20\x03(\tR\x0cfailedDecoys\x12,\n\x05stats\
    \x18\x0b\x20\x01(\x0b2\x16.tapdance.SessionStatsR\x05stats\x125\n\ttrans\
    port\x18\x0c\x20\x01(\x0e2\x17.tapdance.TransportTypeR\ttransport\x12%\n\
    \x0ecovert_address\x18\x14\x20\x01(\tR\rcovertAddress\x127\n\x18masked_d\
    ecoy_server_name\x18\x15\x20\x01(\tR\x15maskedDecoyServerName\x12\x1d\n\
    \nv6_support\x18\x16\x20\x01(\x08R\tv6Support\x12\x1d\n\nv4_support\x18\
    \x17\x20\x01(\x08R\tv4Support\x121\n\x05flags\x18\x18\x20\x01(\x0b2\x1b.\
    tapdance.RegistrationFlagsR\x05flags\x12\x18\n\x07padding\x18d\x20\x01(\
    \x0cR\x07padding\"\xa6\x02\n\nC2SWrapper\x12#\n\rshared_secret\x18\x01\
    \x20\x01(\x0cR\x0csharedSecret\x12L\n\x14registration_payload\x18\x03\
    \x20\x01(\x0b2\x19.tapdance.ClientToStationR\x13registrationPayload\x12M\
    \n\x13registration_source\x18\x04\x20\x01(\x0e2\x1c.tapdance.Registratio\
    nSourceR\x12registrationSource\x121\n\x14registration_address\x18\x06\
    \x20\x01(\x0cR\x13registrationAddress\x12#\n\rdecoy_address\x18\x07\x20\
    \x01(\x0cR\x0cdecoyAddress\"\xdd\x01\n\x0cSessionStats\x120\n\x14failed_\
    decoys_amount\x18\x14\x20\x01(\rR\x12failedDecoysAmount\x121\n\x15total_\
    time_to_connect\x18\x1f\x20\x01(\rR\x12totalTimeToConnect\x12$\n\x0ertt_\
    to_station\x18!\x20\x01(\rR\x0crttToStation\x12\x20\n\x0ctls_to_decoy\
    \x18&\x20\x01(\rR\ntlsToDecoy\x12\x20\n\x0ctcp_to_decoy\x18'\x20\x01(\rR\
    \ntcpToDecoy\"n\n\x11StationToDetector\x12\x1d\n\nphantom_ip\x18\x01\x20\
    \x01(\tR\tphantomIp\x12\x1b\n\tclient_ip\x18\x02\x20\x01(\tR\x08clientIp\
    \x12\x1d\n\ntimeout_ns\x18\x03\x20\x01(\x04R\ttimeoutNs*+\n\x07KeyType\
    \x12\x0f\n\x0bAES_GCM_128\x10Z\x12\x0f\n\x0bAES_GCM_256\x10[*\xe7\x01\n\
    \x0eC2S_Transition\x12\x11\n\rC2S_NO_CHANGE\x10\0\x12\x14\n\x10C2S_SESSI\
    ON_INIT\x10\x01\x12\x1b\n\x17C2S_SESSION_COVERT_INIT\x10\x0b\x12\x18\n\
    \x14C2S_EXPECT_RECONNECT\x10\x02\x12\x15\n\x11C2S_SESSION_CLOSE\x10\x03\
    \x12\x14\n\x10C2S_YIELD_UPLOAD\x10\x04\x12\x16\n\x12C2S_ACQUIRE_UPLOAD\
    \x10\x05\x12\x20\n\x1cC2S_EXPECT_UPLOADONLY_RECONN\x10\x06\x12\x0e\n\tC2\
    S_ERROR\x10\xff\x01*\x98\x01\n\x0eS2C_Transition\x12\x11\n\rS2C_NO_CHANG\
    E\x10\0\x12\x14\n\x10S2C_SESSION_INIT\x10\x01\x12\x1b\n\x17S2C_SESSION_C\
    OVERT_INIT\x10\x0b\x12\x19\n\x15S2C_CONFIRM_RECONNECT\x10\x02\x12\x15\n\
    \x11S2C_SESSION_CLOSE\x10\x03\x12\x0e\n\tS2C_ERROR\x10\xff\x01*\xac\x01\
    \n\x0eErrorReasonS2C\x12\x0c\n\x08NO_ERROR\x10\0\x12\x11\n\rCOVERT_STREA\
    M\x10\x01\x12\x13\n\x0fCLIENT_REPORTED\x10\x02\x12\x13\n\x0fCLIENT_PROTO\
    COL\x10\x03\x12\x14\n\x10STATION_INTERNAL\x10\x04\x12\x12\n\x0eDECOY_OVE\
    RLOAD\x10\x05\x12\x11\n\rCLIENT_STREAM\x10d\x12\x12\n\x0eCLIENT_TIMEOUT\
    \x10e*-\n\rTransportType\x12\x08\n\x04Null\x10\0\x12\x07\n\x03Min\x10\
    \x01\x12\t\n\x05Obfs4\x10\x02*Q\n\x12RegistrationSource\x12\x0f\n\x0bUns\
    pecified\x10\0\x12\x0c\n\x08Detector\x10\x01\x12\x07\n\x03API\x10\x02\
    \x12\x13\n\x0fDetectorPrescan\x10\x03J\xd0T\n\x07\x12\x05\0\0\x83\x02\
    \x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\xb0\x01\n\x01\x02\x12\x03\x06\x08\
    \x102\xa5\x01\x20TODO:\x20We're\x20using\x20proto2\x20because\x20it's\
    \x20the\x20default\x20on\x20Ubuntu\x2016.04.\n\x20At\x20some\x20point\
    \x20we\x20will\x20want\x20to\x20migrate\x20to\x20proto3,\x20but\x20we\
    \x20are\x20not\n\x20using\x20any\x20proto3\x20features\x20yet.\n\n\n\n\
    \x02\x05\0\x12\x04\x08\0\x0b\x01\n\n\n\x03\x05\0\x01\x12\x03\x08\x05\x0c\
    \n\x0b\n\x04\x05\0\x02\0\x12\x03\t\x04\x15\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x03\t\x04\x0f\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t\x12\x14\n\x20\n\
    \x04\x05\0\x02\x01\x12\x03\n\x04\x15\"\x13\x20not\x20supported\x20atm\n\
    \n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\n\x04\x0f\n\x0c\n\x05\x05\0\x02\
    \x01\x02\x12\x03\n\x12\x14\n\n\n\x02\x04\0\x12\x04\r\0\x12\x01\n\n\n\x03\
    \x04\0\x01\x12\x03\r\x08\x0e\n4\n\x04\x04\0\x02\0\x12\x03\x0f\x04\x1b\
    \x1a'\x20A\x20public\x20key,\x20as\x20used\x20by\x20the\x20station.\n\n\
    \x0c\n\x05\x04\0\x02\0\x04\x12\x03\x0f\x04\x0c\n\x0c\n\x05\x04\0\x02\0\
    \x05\x12\x03\x0f\r\x12\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0f\x13\x16\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0f\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\
    \x12\x03\x11\x04\x1e\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x11\x04\x0c\n\
    \x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x11\r\x14\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03\x11\x15\x19\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x11\x1c\
    \x1d\n\n\n\x02\x04\x01\x12\x04\x14\0:\x01\n\n\n\x03\x04\x01\x01\x12\x03\
    \x14\x08\x14\n\xa1\x01\n\x04\x04\x01\x02\0\x12\x03\x19\x04!\x1a\x93\x01\
    \x20The\x20hostname/SNI\x20to\x20use\x20for\x20this\x20host\n\n\x20The\
    \x20hostname\x20is\x20the\x20only\x20required\x20field,\x20although\x20o\
    ther\n\x20fields\x20are\x20expected\x20to\x20be\x20present\x20in\x20most\
    \x20cases.\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x19\x04\x0c\n\x0c\n\
    \x05\x04\x01\x02\0\x05\x12\x03\x19\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03\x19\x14\x1c\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x19\x1f\x20\n\
    \xf7\x01\n\x04\x04\x01\x02\x01\x12\x03\x20\x04\"\x1a\xe9\x01\x20The\x203\
    2-bit\x20ipv4\x20address,\x20in\x20network\x20byte\x20order\n\n\x20If\
    \x20the\x20IPv4\x20address\x20is\x20absent,\x20then\x20it\x20may\x20be\
    \x20resolved\x20via\n\x20DNS\x20by\x20the\x20client,\x20or\x20the\x20cli\
    ent\x20may\x20discard\x20this\x20decoy\x20spec\n\x20if\x20local\x20DNS\
    \x20is\x20untrusted,\x20or\x20the\x20service\x20may\x20be\x20multihomed.\
    \n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x20\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\x01\x05\x12\x03\x20\r\x14\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03\x20\x15\x1d\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x20\x20!\n>\n\
    \x04\x04\x01\x02\x02\x12\x03#\x04\x20\x1a1\x20The\x20128-bit\x20ipv6\x20\
    address,\x20in\x20network\x20byte\x20order\n\n\x0c\n\x05\x04\x01\x02\x02\
    \x04\x12\x03#\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03#\r\x12\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03#\x13\x1b\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03#\x1e\x1f\n\x91\x01\n\x04\x04\x01\x02\x03\x12\x03)\x04\
    \x1f\x1a\x83\x01\x20The\x20Tapdance\x20station\x20public\x20key\x20to\
    \x20use\x20when\x20contacting\x20this\n\x20decoy\n\n\x20If\x20omitted,\
    \x20the\x20default\x20station\x20public\x20key\x20(if\x20any)\x20is\x20u\
    sed.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03)\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\x03\x06\x12\x03)\r\x13\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03)\
    \x14\x1a\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03)\x1d\x1e\n\xee\x01\n\
    \x04\x04\x01\x02\x04\x12\x030\x04\x20\x1a\xe0\x01\x20The\x20maximum\x20d\
    uration,\x20in\x20milliseconds,\x20to\x20maintain\x20an\x20open\n\x20con\
    nection\x20to\x20this\x20decoy\x20(because\x20the\x20decoy\x20may\x20clo\
    se\x20the\n\x20connection\x20itself\x20after\x20this\x20length\x20of\x20\
    time)\n\n\x20If\x20omitted,\x20a\x20default\x20of\x2030,000\x20milliseco\
    nds\x20is\x20assumed.\n\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x030\x04\x0c\
    \n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x030\r\x13\n\x0c\n\x05\x04\x01\x02\
    \x04\x01\x12\x030\x14\x1b\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x030\x1e\
    \x1f\n\xb0\x02\n\x04\x04\x01\x02\x05\x12\x039\x04\x1f\x1a\xa2\x02\x20The\
    \x20maximum\x20TCP\x20window\x20size\x20to\x20attempt\x20to\x20use\x20fo\
    r\x20this\x20decoy.\n\n\x20If\x20omitted,\x20a\x20default\x20of\x2015360\
    \x20is\x20assumed.\n\n\x20TODO:\x20the\x20default\x20is\x20based\x20on\
    \x20the\x20current\x20heuristic\x20of\x20only\n\x20using\x20decoys\x20th\
    at\x20permit\x20windows\x20of\x2015KB\x20or\x20larger.\x20\x20If\x20this\
    \n\x20heuristic\x20changes,\x20then\x20this\x20default\x20doesn't\x20mak\
    e\x20sense.\n\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x039\x04\x0c\n\x0c\n\
    \x05\x04\x01\x02\x05\x05\x12\x039\r\x13\n\x0c\n\x05\x04\x01\x02\x05\x01\
    \x12\x039\x14\x1a\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x039\x1d\x1e\n\x83\
    \x08\n\x02\x04\x02\x12\x04Q\0W\x012\xf6\x07\x20In\x20version\x201,\x20th\
    e\x20request\x20is\x20very\x20simple:\x20when\n\x20the\x20client\x20send\
    s\x20a\x20MSG_PROTO\x20to\x20the\x20station,\x20if\x20the\n\x20generatio\
    n\x20number\x20is\x20present,\x20then\x20this\x20request\x20includes\n\
    \x20(in\x20addition\x20to\x20whatever\x20other\x20operations\x20are\x20p\
    art\x20of\x20the\n\x20request)\x20a\x20request\x20for\x20the\x20station\
    \x20to\x20send\x20a\x20copy\x20of\n\x20the\x20current\x20decoy\x20set\
    \x20that\x20has\x20a\x20generation\x20number\x20greater\n\x20than\x20the\
    \x20generation\x20number\x20in\x20its\x20request.\n\n\x20If\x20the\x20re\
    sponse\x20contains\x20a\x20DecoyListUpdate\x20with\x20a\x20generation\
    \x20number\x20equal\n\x20to\x20that\x20which\x20the\x20client\x20sent,\
    \x20then\x20the\x20client\x20is\x20\"caught\x20up\"\x20with\n\x20the\x20\
    station\x20and\x20the\x20response\x20contains\x20no\x20new\x20informatio\
    n\n\x20(and\x20all\x20other\x20fields\x20may\x20be\x20omitted\x20or\x20e\
    mpty).\x20\x20Otherwise,\n\x20the\x20station\x20will\x20send\x20the\x20l\
    atest\x20configuration\x20information,\n\x20along\x20with\x20its\x20gene\
    ration\x20number.\n\n\x20The\x20station\x20can\x20also\x20send\x20Client\
    Conf\x20messages\n\x20(as\x20part\x20of\x20Station2Client\x20messages)\
    \x20whenever\x20it\x20wants.\n\x20The\x20client\x20is\x20expected\x20to\
    \x20react\x20as\x20if\x20it\x20had\x20requested\n\x20such\x20messages\
    \x20--\x20possibly\x20by\x20ignoring\x20them,\x20if\x20the\x20client\n\
    \x20is\x20already\x20up-to-date\x20according\x20to\x20the\x20generation\
    \x20number.\n\n\n\n\x03\x04\x02\x01\x12\x03Q\x08\x12\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x03R\x04&\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03R\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\0\x06\x12\x03R\r\x16\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03R\x17!\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03R$%\n\x0b\n\x04\
    \x04\x02\x02\x01\x12\x03S\x04#\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03S\
    \x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03S\r\x13\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03S\x14\x1e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\
    \x03S!\"\n\x0b\n\x04\x04\x02\x02\x02\x12\x03T\x04'\n\x0c\n\x05\x04\x02\
    \x02\x02\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03T\r\
    \x13\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03T\x14\"\n\x0c\n\x05\x04\x02\
    \x02\x02\x03\x12\x03T%&\n\x0b\n\x04\x04\x02\x02\x03\x12\x03U\x043\n\x0c\
    \n\x05\x04\x02\x02\x03\x04\x12\x03U\x04\x0c\n\x0c\n\x05\x04\x02\x02\x03\
    \x06\x12\x03U\r\x1c\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03U\x1d.\n\x0c\
    \n\x05\x04\x02\x02\x03\x03\x12\x03U12\n\x0b\n\x04\x04\x02\x02\x04\x12\
    \x03V\x04'\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03V\x04\x0c\n\x0c\n\x05\
    \x04\x02\x02\x04\x06\x12\x03V\r\x13\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\
    \x03V\x14\"\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03V%&\n\n\n\x02\x04\x03\
    \x12\x04Y\0[\x01\n\n\n\x03\x04\x03\x01\x12\x03Y\x08\x11\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03Z\x04)\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03Z\x04\x0c\
    \n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03Z\r\x19\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03Z\x1a$\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03Z'(\n\n\n\x02\
    \x04\x04\x12\x04]\0_\x01\n\n\n\x03\x04\x04\x01\x12\x03]\x08\x17\n\x0b\n\
    \x04\x04\x04\x02\0\x12\x03^\x04\x1f\n\x0c\n\x05\x04\x04\x02\0\x04\x12\
    \x03^\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03^\r\x13\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03^\x14\x1a\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03^\x1d\x1e\n-\n\x02\x05\x01\x12\x04b\0l\x01\x1a!\x20State\x20transiti\
    ons\x20of\x20the\x20client\n\n\n\n\x03\x05\x01\x01\x12\x03b\x05\x13\n\
    \x0b\n\x04\x05\x01\x02\0\x12\x03c\x04\x16\n\x0c\n\x05\x05\x01\x02\0\x01\
    \x12\x03c\x04\x11\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03c\x14\x15\n\"\n\
    \x04\x05\x01\x02\x01\x12\x03d\x04\x19\"\x15\x20connect\x20me\x20to\x20sq\
    uid\n\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03d\x04\x14\n\x0c\n\x05\x05\
    \x01\x02\x01\x02\x12\x03d\x17\x18\n,\n\x04\x05\x01\x02\x02\x12\x03e\x04!\
    \"\x1f\x20connect\x20me\x20to\x20provided\x20covert\n\n\x0c\n\x05\x05\
    \x01\x02\x02\x01\x12\x03e\x04\x1b\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\
    \x03e\x1e\x20\n\x0b\n\x04\x05\x01\x02\x03\x12\x03f\x04\x1d\n\x0c\n\x05\
    \x05\x01\x02\x03\x01\x12\x03f\x04\x18\n\x0c\n\x05\x05\x01\x02\x03\x02\
    \x12\x03f\x1b\x1c\n\x0b\n\x04\x05\x01\x02\x04\x12\x03g\x04\x1a\n\x0c\n\
    \x05\x05\x01\x02\x04\x01\x12\x03g\x04\x15\n\x0c\n\x05\x05\x01\x02\x04\
    \x02\x12\x03g\x18\x19\n\x0b\n\x04\x05\x01\x02\x05\x12\x03h\x04\x19\n\x0c\
    \n\x05\x05\x01\x02\x05\x01\x12\x03h\x04\x14\n\x0c\n\x05\x05\x01\x02\x05\
    \x02\x12\x03h\x17\x18\n\x0b\n\x04\x05\x01\x02\x06\x12\x03i\x04\x1b\n\x0c\
    \n\x05\x05\x01\x02\x06\x01\x12\x03i\x04\x16\n\x0c\n\x05\x05\x01\x02\x06\
    \x02\x12\x03i\x19\x1a\n\x0b\n\x04\x05\x01\x02\x07\x12\x03j\x04%\n\x0c\n\
    \x05\x05\x01\x02\x07\x01\x12\x03j\x04\x20\n\x0c\n\x05\x05\x01\x02\x07\
    \x02\x12\x03j#$\n\x0b\n\x04\x05\x01\x02\x08\x12\x03k\x04\x14\n\x0c\n\x05\
    \x05\x01\x02\x08\x01\x12\x03k\x04\r\n\x0c\n\x05\x05\x01\x02\x08\x02\x12\
    \x03k\x10\x13\n-\n\x02\x05\x02\x12\x04o\0w\x01\x1a!\x20State\x20transiti\
    ons\x20of\x20the\x20server\n\n\n\n\x03\x05\x02\x01\x12\x03o\x05\x13\n\
    \x0b\n\x04\x05\x02\x02\0\x12\x03p\x04\x16\n\x0c\n\x05\x05\x02\x02\0\x01\
    \x12\x03p\x04\x11\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03p\x14\x15\n!\n\
    \x04\x05\x02\x02\x01\x12\x03q\x04\x19\"\x14\x20connected\x20to\x20squid\
    \n\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03q\x04\x14\n\x0c\n\x05\x05\x02\
    \x02\x01\x02\x12\x03q\x17\x18\n'\n\x04\x05\x02\x02\x02\x12\x03r\x04!\"\
    \x1a\x20connected\x20to\x20covert\x20host\n\n\x0c\n\x05\x05\x02\x02\x02\
    \x01\x12\x03r\x04\x1b\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03r\x1e\x20\n\
    \x0b\n\x04\x05\x02\x02\x03\x12\x03s\x04\x1e\n\x0c\n\x05\x05\x02\x02\x03\
    \x01\x12\x03s\x04\x19\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03s\x1c\x1d\n\
    \x0b\n\x04\x05\x02\x02\x04\x12\x03t\x04\x1a\n\x0c\n\x05\x05\x02\x02\x04\
    \x01\x12\x03t\x04\x15\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03t\x18\x19\n\
    R\n\x04\x05\x02\x02\x05\x12\x03v\x04\x14\x1aE\x20TODO\x20should\x20proba\
    bly\x20also\x20allow\x20EXPECT_RECONNECT\x20here,\x20for\x20DittoTap\n\n\
    \x0c\n\x05\x05\x02\x02\x05\x01\x12\x03v\x04\r\n\x0c\n\x05\x05\x02\x02\
    \x05\x02\x12\x03v\x10\x13\n7\n\x02\x05\x03\x12\x05z\0\x84\x01\x01\x1a*\
    \x20Should\x20accompany\x20all\x20S2C_ERROR\x20messages.\n\n\n\n\x03\x05\
    \x03\x01\x12\x03z\x05\x13\n\x0b\n\x04\x05\x03\x02\0\x12\x03{\x04\x11\n\
    \x0c\n\x05\x05\x03\x02\0\x01\x12\x03{\x04\x0c\n\x0c\n\x05\x05\x03\x02\0\
    \x02\x12\x03{\x0f\x10\n)\n\x04\x05\x03\x02\x01\x12\x03|\x04\x16\"\x1c\
    \x20Squid\x20TCP\x20connection\x20broke\n\n\x0c\n\x05\x05\x03\x02\x01\
    \x01\x12\x03|\x04\x11\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03|\x14\x15\n\
    6\n\x04\x05\x03\x02\x02\x12\x03}\x04\x18\")\x20You\x20told\x20me\x20some\
    thing\x20was\x20wrong,\x20client\n\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\
    \x03}\x04\x13\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03}\x16\x17\n?\n\x04\
    \x05\x03\x02\x03\x12\x03~\x04\x18\"2\x20You\x20messed\x20up,\x20client\
    \x20(e.g.\x20sent\x20a\x20bad\x20protobuf)\n\n\x0c\n\x05\x05\x03\x02\x03\
    \x01\x12\x03~\x04\x13\n\x0c\n\x05\x05\x03\x02\x03\x02\x12\x03~\x16\x17\n\
    \x16\n\x04\x05\x03\x02\x04\x12\x03\x7f\x04\x19\"\t\x20I\x20broke\n\n\x0c\
    \n\x05\x05\x03\x02\x04\x01\x12\x03\x7f\x04\x14\n\x0c\n\x05\x05\x03\x02\
    \x04\x02\x12\x03\x7f\x17\x18\nE\n\x04\x05\x03\x02\x05\x12\x04\x80\x01\
    \x04\x17\"7\x20Everything's\x20fine,\x20but\x20don't\x20use\x20this\x20d\
    ecoy\x20right\x20now\n\n\r\n\x05\x05\x03\x02\x05\x01\x12\x04\x80\x01\x04\
    \x12\n\r\n\x05\x05\x03\x02\x05\x02\x12\x04\x80\x01\x15\x16\nD\n\x04\x05\
    \x03\x02\x06\x12\x04\x82\x01\x04\x18\"6\x20My\x20stream\x20to\x20you\x20\
    broke.\x20(This\x20is\x20impossible\x20to\x20send)\n\n\r\n\x05\x05\x03\
    \x02\x06\x01\x12\x04\x82\x01\x04\x11\n\r\n\x05\x05\x03\x02\x06\x02\x12\
    \x04\x82\x01\x14\x17\nA\n\x04\x05\x03\x02\x07\x12\x04\x83\x01\x04\x19\"3\
    \x20You\x20never\x20came\x20back.\x20(This\x20is\x20impossible\x20to\x20\
    send)\n\n\r\n\x05\x05\x03\x02\x07\x01\x12\x04\x83\x01\x04\x12\n\r\n\x05\
    \x05\x03\x02\x07\x02\x12\x04\x83\x01\x15\x18\n\x0c\n\x02\x05\x04\x12\x06\
    \x86\x01\0\x8a\x01\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\x86\x01\x05\x12\n\
    \x0c\n\x04\x05\x04\x02\0\x12\x04\x87\x01\x04\r\n\r\n\x05\x05\x04\x02\0\
    \x01\x12\x04\x87\x01\x04\x08\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\x87\x01\
    \x0b\x0c\n`\n\x04\x05\x04\x02\x01\x12\x04\x88\x01\x04\x0c\"R\x20Send\x20\
    a\x2032-byte\x20HMAC\x20id\x20to\x20let\x20the\x20station\x20distinguish\
    \x20registrations\x20to\x20same\x20host\n\n\r\n\x05\x05\x04\x02\x01\x01\
    \x12\x04\x88\x01\x04\x07\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\x88\x01\n\
    \x0b\n$\n\x04\x05\x04\x02\x02\x12\x04\x89\x01\x04\x0e\"\x16\x20Not\x20im\
    plemented\x20yet?\n\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\x89\x01\x04\t\
    \n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\x89\x01\x0c\r\n\x0c\n\x02\x04\x05\
    \x12\x06\x8c\x01\0\xa3\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x8c\x01\
    \x08\x17\nO\n\x04\x04\x05\x02\0\x12\x04\x8e\x01\x04)\x1aA\x20Should\x20a\
    ccompany\x20(at\x20least)\x20SESSION_INIT\x20and\x20CONFIRM_RECONNECT.\n\
    \n\r\n\x05\x04\x05\x02\0\x04\x12\x04\x8e\x01\x04\x0c\n\r\n\x05\x04\x05\
    \x02\0\x05\x12\x04\x8e\x01\r\x13\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x8e\
    \x01\x14$\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x8e\x01'(\nv\n\x04\x04\x05\
    \x02\x01\x12\x04\x92\x01\x041\x1ah\x20There\x20might\x20be\x20a\x20state\
    \x20transition.\x20May\x20be\x20absent;\x20absence\x20should\x20be\n\x20\
    treated\x20identically\x20to\x20NO_CHANGE.\n\n\r\n\x05\x04\x05\x02\x01\
    \x04\x12\x04\x92\x01\x04\x0c\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\x92\
    \x01\r\x1b\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x92\x01\x1c,\n\r\n\x05\
    \x04\x05\x02\x01\x03\x12\x04\x92\x01/0\nc\n\x04\x04\x05\x02\x02\x12\x04\
    \x96\x01\x04(\x1aU\x20The\x20station\x20can\x20send\x20client\x20config\
    \x20info\x20piggybacked\n\x20on\x20any\x20message,\x20as\x20it\x20sees\
    \x20fit\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\x96\x01\x04\x0c\n\r\n\
    \x05\x04\x05\x02\x02\x06\x12\x04\x96\x01\r\x17\n\r\n\x05\x04\x05\x02\x02\
    \x01\x12\x04\x96\x01\x18#\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x96\x01&\
    '\nP\n\x04\x04\x05\x02\x03\x12\x04\x99\x01\x04+\x1aB\x20If\x20state_tran\
    sition\x20==\x20S2C_ERROR,\x20this\x20field\x20is\x20the\x20explanation.\
    \n\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\x99\x01\x04\x0c\n\r\n\x05\x04\
    \x05\x02\x03\x06\x12\x04\x99\x01\r\x1b\n\r\n\x05\x04\x05\x02\x03\x01\x12\
    \x04\x99\x01\x1c&\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x99\x01)*\nQ\n\
    \x04\x04\x05\x02\x04\x12\x04\x9c\x01\x04$\x1aC\x20Signals\x20client\x20t\
    o\x20stop\x20connecting\x20for\x20following\x20amount\x20of\x20seconds\n\
    \n\r\n\x05\x04\x05\x02\x04\x04\x12\x04\x9c\x01\x04\x0c\n\r\n\x05\x04\x05\
    \x02\x04\x05\x12\x04\x9c\x01\r\x13\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\
    \x9c\x01\x14\x1f\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\x9c\x01\"#\nK\n\
    \x04\x04\x05\x02\x05\x12\x04\x9f\x01\x04#\x1a=\x20Sent\x20in\x20SESSION_\
    INIT,\x20identifies\x20the\x20station\x20that\x20picked\x20up\n\n\r\n\
    \x05\x04\x05\x02\x05\x04\x12\x04\x9f\x01\x04\x0c\n\r\n\x05\x04\x05\x02\
    \x05\x05\x12\x04\x9f\x01\r\x13\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\x9f\
    \x01\x14\x1e\n\r\n\x05\x04\x05\x02\x05\x03\x12\x04\x9f\x01!\"\nG\n\x04\
    \x04\x05\x02\x06\x12\x04\xa2\x01\x04!\x1a9\x20Random-sized\x20junk\x20to\
    \x20defeat\x20packet\x20size\x20fingerprinting.\n\n\r\n\x05\x04\x05\x02\
    \x06\x04\x12\x04\xa2\x01\x04\x0c\n\r\n\x05\x04\x05\x02\x06\x05\x12\x04\
    \xa2\x01\r\x12\n\r\n\x05\x04\x05\x02\x06\x01\x12\x04\xa2\x01\x13\x1a\n\r\
    \n\x05\x04\x05\x02\x06\x03\x12\x04\xa2\x01\x1d\x20\n\x0c\n\x02\x04\x06\
    \x12\x06\xa5\x01\0\xab\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xa5\x01\
    \x08\x19\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xa6\x01\x08&\n\r\n\x05\x04\
    \x06\x02\0\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x05\x12\
    \x04\xa6\x01\x11\x15\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xa6\x01\x16!\n\
    \r\n\x05\x04\x06\x02\0\x03\x12\x04\xa6\x01$%\n\x0c\n\x04\x04\x06\x02\x01\
    \x12\x04\xa7\x01\x08%\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xa7\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xa7\x01\x11\x15\n\r\n\x05\x04\
    \x06\x02\x01\x01\x12\x04\xa7\x01\x16\x20\n\r\n\x05\x04\x06\x02\x01\x03\
    \x12\x04\xa7\x01#$\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xa8\x01\x08'\n\r\
    \n\x05\x04\x06\x02\x02\x04\x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\x06\x02\
    \x02\x05\x12\x04\xa8\x01\x11\x15\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\
    \xa8\x01\x16\"\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xa8\x01%&\n\x0c\n\
    \x04\x04\x06\x02\x03\x12\x04\xa9\x01\x04\x1e\n\r\n\x05\x04\x06\x02\x03\
    \x04\x12\x04\xa9\x01\x04\x0c\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\xa9\
    \x01\r\x11\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xa9\x01\x12\x19\n\r\n\
    \x05\x04\x06\x02\x03\x03\x12\x04\xa9\x01\x1c\x1d\n\x0c\n\x04\x04\x06\x02\
    \x04\x12\x04\xaa\x01\x04!\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\xaa\x01\
    \x04\x0c\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xaa\x01\r\x11\n\r\n\x05\
    \x04\x06\x02\x04\x01\x12\x04\xaa\x01\x12\x1c\n\r\n\x05\x04\x06\x02\x04\
    \x03\x12\x04\xaa\x01\x1f\x20\n\x0c\n\x02\x04\x07\x12\x06\xad\x01\0\xd9\
    \x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xad\x01\x08\x17\n\x0c\n\x04\x04\
    \x07\x02\0\x12\x04\xae\x01\x04)\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xae\
    \x01\x04\x0c\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xae\x01\r\x13\n\r\n\x05\
    \x04\x07\x02\0\x01\x12\x04\xae\x01\x14$\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\xae\x01'(\n\xd0\x01\n\x04\x04\x07\x02\x01\x12\x04\xb3\x01\x04.\x1a\
    \xc1\x01\x20The\x20client\x20reports\x20its\x20decoy\x20list's\x20versio\
    n\x20number\x20here,\x20which\x20the\n\x20station\x20can\x20use\x20to\
    \x20decide\x20whether\x20to\x20send\x20an\x20updated\x20one.\x20The\x20s\
    tation\n\x20should\x20always\x20send\x20a\x20list\x20if\x20this\x20field\
    \x20is\x20set\x20to\x200.\n\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\xb3\
    \x01\x04\x0c\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xb3\x01\r\x13\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\xb3\x01\x14)\n\r\n\x05\x04\x07\x02\x01\
    \x03\x12\x04\xb3\x01,-\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xb5\x01\x041\
    \n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xb5\x01\x04\x0c\n\r\n\x05\x04\x07\
    \x02\x02\x06\x12\x04\xb5\x01\r\x1b\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\
    \xb5\x01\x1c,\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xb5\x01/0\n\x80\x01\
    \n\x04\x04\x07\x02\x03\x12\x04\xb9\x01\x04$\x1ar\x20The\x20position\x20i\
    n\x20the\x20overall\x20session's\x20upload\x20sequence\x20where\x20the\
    \x20current\n\x20YIELD=>ACQUIRE\x20switchover\x20is\x20happening.\n\n\r\
    \n\x05\x04\x07\x02\x03\x04\x12\x04\xb9\x01\x04\x0c\n\r\n\x05\x04\x07\x02\
    \x03\x05\x12\x04\xb9\x01\r\x13\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xb9\
    \x01\x14\x1f\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xb9\x01\"#\nq\n\x04\
    \x04\x07\x02\x04\x12\x04\xbe\x01\x04'\x1ac\x20List\x20of\x20decoys\x20th\
    at\x20client\x20have\x20unsuccessfully\x20tried\x20in\x20current\x20sess\
    ion.\n\x20Could\x20be\x20sent\x20in\x20chunks\n\n\r\n\x05\x04\x07\x02\
    \x04\x04\x12\x04\xbe\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\
    \xbe\x01\r\x13\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xbe\x01\x14!\n\r\n\
    \x05\x04\x07\x02\x04\x03\x12\x04\xbe\x01$&\n\x0c\n\x04\x04\x07\x02\x05\
    \x12\x04\xc0\x01\x04%\n\r\n\x05\x04\x07\x02\x05\x04\x12\x04\xc0\x01\x04\
    \x0c\n\r\n\x05\x04\x07\x02\x05\x06\x12\x04\xc0\x01\r\x19\n\r\n\x05\x04\
    \x07\x02\x05\x01\x12\x04\xc0\x01\x1a\x1f\n\r\n\x05\x04\x07\x02\x05\x03\
    \x12\x04\xc0\x01\"$\nk\n\x04\x04\x07\x02\x06\x12\x04\xc3\x01\x04*\x1a]\
    \x20NullTransport,\x20MinTransport,\x20Obfs4Transport,\x20etc.\x20Transp\
    ort\x20type\x20we\x20want\x20from\x20phantom\x20proxy\n\n\r\n\x05\x04\
    \x07\x02\x06\x04\x12\x04\xc3\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x06\x06\
    \x12\x04\xc3\x01\r\x1a\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\xc3\x01\x1b\
    $\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\xc3\x01')\n\xc8\x03\n\x04\x04\
    \x07\x02\x07\x12\x04\xcb\x01\x04(\x1a\xb9\x03\x20Station\x20is\x20only\
    \x20required\x20to\x20check\x20this\x20variable\x20during\x20session\x20\
    initialization.\n\x20If\x20set,\x20station\x20must\x20facilitate\x20conn\
    ection\x20to\x20said\x20target\x20by\x20itself,\x20i.e.\x20write\x20into\
    \x20squid\n\x20socket\x20an\x20HTTP/SOCKS/any\x20other\x20connection\x20\
    request.\n\x20covert_address\x20must\x20have\x20exactly\x20one\x20':'\
    \x20colon,\x20that\x20separates\x20host\x20(literal\x20IP\x20address\x20\
    or\n\x20resolvable\x20hostname)\x20and\x20port\n\x20TODO:\x20make\x20it\
    \x20required\x20for\x20initialization,\x20and\x20stop\x20connecting\x20a\
    ny\x20client\x20straight\x20to\x20squid?\n\n\r\n\x05\x04\x07\x02\x07\x04\
    \x12\x04\xcb\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x07\x05\x12\x04\xcb\x01\r\
    \x13\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xcb\x01\x14\"\n\r\n\x05\x04\
    \x07\x02\x07\x03\x12\x04\xcb\x01%'\nR\n\x04\x04\x07\x02\x08\x12\x04\xce\
    \x01\x042\x1aD\x20Used\x20in\x20dark\x20decoys\x20to\x20signal\x20which\
    \x20dark\x20decoy\x20it\x20will\x20connect\x20to.\n\n\r\n\x05\x04\x07\
    \x02\x08\x04\x12\x04\xce\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x08\x05\x12\
    \x04\xce\x01\r\x13\n\r\n\x05\x04\x07\x02\x08\x01\x12\x04\xce\x01\x14,\n\
    \r\n\x05\x04\x07\x02\x08\x03\x12\x04\xce\x01/1\nR\n\x04\x04\x07\x02\t\
    \x12\x04\xd1\x01\x04\"\x1aD\x20Used\x20to\x20indicate\x20to\x20server\
    \x20if\x20client\x20is\x20registering\x20v4,\x20v6\x20or\x20both\n\n\r\n\
    \x05\x04\x07\x02\t\x04\x12\x04\xd1\x01\x04\x0c\n\r\n\x05\x04\x07\x02\t\
    \x05\x12\x04\xd1\x01\r\x11\n\r\n\x05\x04\x07\x02\t\x01\x12\x04\xd1\x01\
    \x12\x1c\n\r\n\x05\x04\x07\x02\t\x03\x12\x04\xd1\x01\x1f!\n\x0c\n\x04\
    \x04\x07\x02\n\x12\x04\xd2\x01\x04\"\n\r\n\x05\x04\x07\x02\n\x04\x12\x04\
    \xd2\x01\x04\x0c\n\r\n\x05\x04\x07\x02\n\x05\x12\x04\xd2\x01\r\x11\n\r\n\
    \x05\x04\x07\x02\n\x01\x12\x04\xd2\x01\x12\x1c\n\r\n\x05\x04\x07\x02\n\
    \x03\x12\x04\xd2\x01\x1f!\nD\n\x04\x04\x07\x02\x0b\x12\x04\xd5\x01\x08.\
    \x1a6\x20A\x20collection\x20of\x20optional\x20flags\x20for\x20the\x20reg\
    istration.\n\n\r\n\x05\x04\x07\x02\x0b\x04\x12\x04\xd5\x01\x08\x10\n\r\n\
    \x05\x04\x07\x02\x0b\x06\x12\x04\xd5\x01\x11\"\n\r\n\x05\x04\x07\x02\x0b\
    \x01\x12\x04\xd5\x01#(\n\r\n\x05\x04\x07\x02\x0b\x03\x12\x04\xd5\x01+-\n\
    G\n\x04\x04\x07\x02\x0c\x12\x04\xd8\x01\x04!\x1a9\x20Random-sized\x20jun\
    k\x20to\x20defeat\x20packet\x20size\x20fingerprinting.\n\n\r\n\x05\x04\
    \x07\x02\x0c\x04\x12\x04\xd8\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x0c\x05\
    \x12\x04\xd8\x01\r\x12\n\r\n\x05\x04\x07\x02\x0c\x01\x12\x04\xd8\x01\x13\
    \x1a\n\r\n\x05\x04\x07\x02\x0c\x03\x12\x04\xd8\x01\x1d\x20\n\x0c\n\x02\
    \x05\x05\x12\x06\xdc\x01\0\xe1\x01\x01\n\x0b\n\x03\x05\x05\x01\x12\x04\
    \xdc\x01\x05\x17\n\x0c\n\x04\x05\x05\x02\0\x12\x04\xdd\x01\x04\x14\n\r\n\
    \x05\x05\x05\x02\0\x01\x12\x04\xdd\x01\x04\x0f\n\r\n\x05\x05\x05\x02\0\
    \x02\x12\x04\xdd\x01\x12\x13\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\xde\x01\
    \x08\x15\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xde\x01\x08\x10\n\r\n\x05\
    \x05\x05\x02\x01\x02\x12\x04\xde\x01\x13\x14\n\x0c\n\x04\x05\x05\x02\x02\
    \x12\x04\xdf\x01\x08\x10\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\xdf\x01\
    \x08\x0b\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xdf\x01\x0e\x0f\n\x0c\n\
    \x04\x05\x05\x02\x03\x12\x04\xe0\x01\x04\x18\n\r\n\x05\x05\x05\x02\x03\
    \x01\x12\x04\xe0\x01\x04\x13\n\r\n\x05\x05\x05\x02\x03\x02\x12\x04\xe0\
    \x01\x16\x17\n\x0c\n\x02\x04\x08\x12\x06\xe3\x01\0\xed\x01\x01\n\x0b\n\
    \x03\x04\x08\x01\x12\x04\xe3\x01\x08\x12\n\x0c\n\x04\x04\x08\x02\0\x12\
    \x04\xe4\x01\x08)\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xe4\x01\x08\x10\n\
    \r\n\x05\x04\x08\x02\0\x05\x12\x04\xe4\x01\x11\x16\n\r\n\x05\x04\x08\x02\
    \0\x01\x12\x04\xe4\x01\x17$\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xe4\x01'\
    (\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xe5\x01\x08:\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\
    \xe5\x01\x11\x20\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xe5\x01!5\n\r\n\
    \x05\x04\x08\x02\x01\x03\x12\x04\xe5\x0189\n\x0c\n\x04\x04\x08\x02\x02\
    \x12\x04\xe6\x01\x048\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xe6\x01\x04\
    \x0c\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xe6\x01\r\x1f\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\xe6\x01\x203\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\xe6\x0167\nC\n\x04\x04\x08\x02\x03\x12\x04\xe9\x01\x04,\x1a5\x20cli\
    ent\x20source\x20address\x20when\x20receiving\x20a\x20registration\n\n\r\
    \n\x05\x04\x08\x02\x03\x04\x12\x04\xe9\x01\x04\x0c\n\r\n\x05\x04\x08\x02\
    \x03\x05\x12\x04\xe9\x01\r\x12\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xe9\
    \x01\x13'\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xe9\x01*+\nH\n\x04\x04\
    \x08\x02\x04\x12\x04\xec\x01\x04%\x1a:\x20Decoy\x20address\x20used\x20wh\
    en\x20registering\x20over\x20Decoy\x20registrar\n\n\r\n\x05\x04\x08\x02\
    \x04\x04\x12\x04\xec\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x04\x05\x12\x04\
    \xec\x01\r\x12\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xec\x01\x13\x20\n\r\
    \n\x05\x04\x08\x02\x04\x03\x12\x04\xec\x01#$\n\x0c\n\x02\x04\t\x12\x06\
    \xef\x01\0\xfb\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xef\x01\x08\x14\n9\
    \n\x04\x04\t\x02\0\x12\x04\xf0\x01\x04.\"+\x20how\x20many\x20decoys\x20w\
    ere\x20tried\x20before\x20success\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04\
    \xf0\x01\x04\x0c\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xf0\x01\r\x13\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xf0\x01\x14(\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\xf0\x01+-\nm\n\x04\x04\t\x02\x01\x12\x04\xf5\x01\x04/\x1a\x1e\x20Ap\
    plicable\x20to\x20whole\x20session:\n\"\x1a\x20includes\x20failed\x20att\
    empts\n2#\x20Timings\x20below\x20are\x20in\x20milliseconds\n\n\r\n\x05\
    \x04\t\x02\x01\x04\x12\x04\xf5\x01\x04\x0c\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\xf5\x01\r\x13\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xf5\x01\x14)\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xf5\x01,.\nR\n\x04\x04\t\x02\x02\
    \x12\x04\xf8\x01\x04(\x1a\x1f\x20Last\x20(i.e.\x20successful)\x20decoy:\
    \n\"#\x20measured\x20during\x20initial\x20handshake\n\n\r\n\x05\x04\t\
    \x02\x02\x04\x12\x04\xf8\x01\x04\x0c\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\
    \xf8\x01\r\x13\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xf8\x01\x14\"\n\r\n\
    \x05\x04\t\x02\x02\x03\x12\x04\xf8\x01%'\n%\n\x04\x04\t\x02\x03\x12\x04\
    \xf9\x01\x04&\"\x17\x20includes\x20tcp\x20to\x20decoy\n\n\r\n\x05\x04\t\
    \x02\x03\x04\x12\x04\xf9\x01\x04\x0c\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\
    \xf9\x01\r\x13\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xf9\x01\x14\x20\n\r\n\
    \x05\x04\t\x02\x03\x03\x12\x04\xf9\x01#%\nB\n\x04\x04\t\x02\x04\x12\x04\
    \xfa\x01\x04&\"4\x20measured\x20when\x20establishing\x20tcp\x20connectio\
    n\x20to\x20decot\n\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xfa\x01\x04\x0c\n\
    \r\n\x05\x04\t\x02\x04\x05\x12\x04\xfa\x01\r\x13\n\r\n\x05\x04\t\x02\x04\
    \x01\x12\x04\xfa\x01\x14\x20\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xfa\x01\
    #%\n\x0c\n\x02\x04\n\x12\x06\xfe\x01\0\x83\x02\x01\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xfe\x01\x08\x19\n\x0c\n\x04\x04\n\x02\0\x12\x04\xff\x01\x04#\n\
    \r\n\x05\x04\n\x02\0\x04\x12\x04\xff\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\
    \x05\x12\x04\xff\x01\r\x13\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xff\x01\x14\
    \x1e\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xff\x01!\"\n\x0c\n\x04\x04\n\x02\
    \x01\x12\x04\x80\x02\x04\"\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x80\x02\
    \x04\x0c\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x80\x02\r\x13\n\r\n\x05\x04\
    \n\x02\x01\x01\x12\x04\x80\x02\x14\x1d\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\x80\x02\x20!\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x82\x02\x04#\n\r\n\
    \x05\x04\n\x02\x02\x04\x12\x04\x82\x02\x04\x0c\n\r\n\x05\x04\n\x02\x02\
    \x05\x12\x04\x82\x02\r\x13\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x82\x02\
    \x14\x1e\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x82\x02!\"\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
