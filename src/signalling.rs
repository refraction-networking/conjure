// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `signalling.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PubKey)
pub struct PubKey {
    // message fields
    ///  A public key, as used by the station.
    // @@protoc_insertion_point(field:proto.PubKey.key)
    pub key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.PubKey.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<KeyType>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PubKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubKey {
    fn default() -> &'a PubKey {
        <PubKey as ::protobuf::Message>::default_instance()
    }
}

impl PubKey {
    pub fn new() -> PubKey {
        ::std::default::Default::default()
    }

    // optional bytes key = 1;

    pub fn key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .proto.KeyType type = 2;

    pub fn type_(&self) -> KeyType {
        match self.type_ {
            Some(e) => e.enum_value_or(KeyType::AES_GCM_128),
            None => KeyType::AES_GCM_128,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: KeyType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &PubKey| { &m.key },
            |m: &mut PubKey| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PubKey| { &m.type_ },
            |m: &mut PubKey| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubKey>(
            "PubKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubKey {
    const NAME: &'static str = "PubKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubKey {
        PubKey::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubKey {
        static instance: PubKey = PubKey {
            key: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PubKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.TLSDecoySpec)
pub struct TLSDecoySpec {
    // message fields
    ///  The hostname/SNI to use for this host
    ///
    ///  The hostname is the only required field, although other
    ///  fields are expected to be present in most cases.
    // @@protoc_insertion_point(field:proto.TLSDecoySpec.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    ///  The 32-bit ipv4 address, in network byte order
    ///
    ///  If the IPv4 address is absent, then it may be resolved via
    ///  DNS by the client, or the client may discard this decoy spec
    ///  if local DNS is untrusted, or the service may be multihomed.
    // @@protoc_insertion_point(field:proto.TLSDecoySpec.ipv4addr)
    pub ipv4addr: ::std::option::Option<u32>,
    ///  The 128-bit ipv6 address, in network byte order
    // @@protoc_insertion_point(field:proto.TLSDecoySpec.ipv6addr)
    pub ipv6addr: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  The Tapdance station public key to use when contacting this
    ///  decoy
    ///
    ///  If omitted, the default station public key (if any) is used.
    // @@protoc_insertion_point(field:proto.TLSDecoySpec.pubkey)
    pub pubkey: ::protobuf::MessageField<PubKey>,
    ///  The maximum duration, in milliseconds, to maintain an open
    ///  connection to this decoy (because the decoy may close the
    ///  connection itself after this length of time)
    ///
    ///  If omitted, a default of 30,000 milliseconds is assumed.
    // @@protoc_insertion_point(field:proto.TLSDecoySpec.timeout)
    pub timeout: ::std::option::Option<u32>,
    ///  The maximum TCP window size to attempt to use for this decoy.
    ///
    ///  If omitted, a default of 15360 is assumed.
    ///
    ///  TODO: the default is based on the current heuristic of only
    ///  using decoys that permit windows of 15KB or larger.  If this
    ///  heuristic changes, then this default doesn't make sense.
    // @@protoc_insertion_point(field:proto.TLSDecoySpec.tcpwin)
    pub tcpwin: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.TLSDecoySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TLSDecoySpec {
    fn default() -> &'a TLSDecoySpec {
        <TLSDecoySpec as ::protobuf::Message>::default_instance()
    }
}

impl TLSDecoySpec {
    pub fn new() -> TLSDecoySpec {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 ipv4addr = 2;

    pub fn ipv4addr(&self) -> u32 {
        self.ipv4addr.unwrap_or(0)
    }

    pub fn clear_ipv4addr(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
    }

    pub fn has_ipv4addr(&self) -> bool {
        self.ipv4addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4addr(&mut self, v: u32) {
        self.ipv4addr = ::std::option::Option::Some(v);
    }

    // optional bytes ipv6addr = 6;

    pub fn ipv6addr(&self) -> &[u8] {
        match self.ipv6addr.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ipv6addr(&mut self) {
        self.ipv6addr = ::std::option::Option::None;
    }

    pub fn has_ipv6addr(&self) -> bool {
        self.ipv6addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ipv6addr.is_none() {
            self.ipv6addr = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ipv6addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6addr(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6addr.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 4;

    pub fn timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }

    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }

    // optional uint32 tcpwin = 5;

    pub fn tcpwin(&self) -> u32 {
        self.tcpwin.unwrap_or(0)
    }

    pub fn clear_tcpwin(&mut self) {
        self.tcpwin = ::std::option::Option::None;
    }

    pub fn has_tcpwin(&self) -> bool {
        self.tcpwin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpwin(&mut self, v: u32) {
        self.tcpwin = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &TLSDecoySpec| { &m.hostname },
            |m: &mut TLSDecoySpec| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv4addr",
            |m: &TLSDecoySpec| { &m.ipv4addr },
            |m: &mut TLSDecoySpec| { &mut m.ipv4addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv6addr",
            |m: &TLSDecoySpec| { &m.ipv6addr },
            |m: &mut TLSDecoySpec| { &mut m.ipv6addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubKey>(
            "pubkey",
            |m: &TLSDecoySpec| { &m.pubkey },
            |m: &mut TLSDecoySpec| { &mut m.pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout",
            |m: &TLSDecoySpec| { &m.timeout },
            |m: &mut TLSDecoySpec| { &mut m.timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcpwin",
            |m: &TLSDecoySpec| { &m.tcpwin },
            |m: &mut TLSDecoySpec| { &mut m.tcpwin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TLSDecoySpec>(
            "TLSDecoySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TLSDecoySpec {
    const NAME: &'static str = "TLSDecoySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.ipv4addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                50 => {
                    self.ipv6addr = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pubkey)?;
                },
                32 => {
                    self.timeout = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tcpwin = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ipv4addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tcpwin {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ipv4addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.pubkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tcpwin {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TLSDecoySpec {
        TLSDecoySpec::new()
    }

    fn clear(&mut self) {
        self.hostname = ::std::option::Option::None;
        self.ipv4addr = ::std::option::Option::None;
        self.ipv6addr = ::std::option::Option::None;
        self.pubkey.clear();
        self.timeout = ::std::option::Option::None;
        self.tcpwin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TLSDecoySpec {
        static instance: TLSDecoySpec = TLSDecoySpec {
            hostname: ::std::option::Option::None,
            ipv4addr: ::std::option::Option::None,
            ipv6addr: ::std::option::Option::None,
            pubkey: ::protobuf::MessageField::none(),
            timeout: ::std::option::Option::None,
            tcpwin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TLSDecoySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TLSDecoySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TLSDecoySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TLSDecoySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ClientConf)
pub struct ClientConf {
    // message fields
    // @@protoc_insertion_point(field:proto.ClientConf.decoy_list)
    pub decoy_list: ::protobuf::MessageField<DecoyList>,
    // @@protoc_insertion_point(field:proto.ClientConf.generation)
    pub generation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ClientConf.default_pubkey)
    pub default_pubkey: ::protobuf::MessageField<PubKey>,
    // @@protoc_insertion_point(field:proto.ClientConf.phantom_subnets_list)
    pub phantom_subnets_list: ::protobuf::MessageField<PhantomSubnetsList>,
    // @@protoc_insertion_point(field:proto.ClientConf.conjure_pubkey)
    pub conjure_pubkey: ::protobuf::MessageField<PubKey>,
    // @@protoc_insertion_point(field:proto.ClientConf.dns_reg_conf)
    pub dns_reg_conf: ::protobuf::MessageField<DnsRegConf>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ClientConf.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientConf {
    fn default() -> &'a ClientConf {
        <ClientConf as ::protobuf::Message>::default_instance()
    }
}

impl ClientConf {
    pub fn new() -> ClientConf {
        ::std::default::Default::default()
    }

    // optional uint32 generation = 2;

    pub fn generation(&self) -> u32 {
        self.generation.unwrap_or(0)
    }

    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: u32) {
        self.generation = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DecoyList>(
            "decoy_list",
            |m: &ClientConf| { &m.decoy_list },
            |m: &mut ClientConf| { &mut m.decoy_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generation",
            |m: &ClientConf| { &m.generation },
            |m: &mut ClientConf| { &mut m.generation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubKey>(
            "default_pubkey",
            |m: &ClientConf| { &m.default_pubkey },
            |m: &mut ClientConf| { &mut m.default_pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PhantomSubnetsList>(
            "phantom_subnets_list",
            |m: &ClientConf| { &m.phantom_subnets_list },
            |m: &mut ClientConf| { &mut m.phantom_subnets_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubKey>(
            "conjure_pubkey",
            |m: &ClientConf| { &m.conjure_pubkey },
            |m: &mut ClientConf| { &mut m.conjure_pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DnsRegConf>(
            "dns_reg_conf",
            |m: &ClientConf| { &m.dns_reg_conf },
            |m: &mut ClientConf| { &mut m.dns_reg_conf },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientConf>(
            "ClientConf",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientConf {
    const NAME: &'static str = "ClientConf";

    fn is_initialized(&self) -> bool {
        for v in &self.decoy_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phantom_subnets_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conjure_pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dns_reg_conf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.decoy_list)?;
                },
                16 => {
                    self.generation = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_pubkey)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.phantom_subnets_list)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.conjure_pubkey)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dns_reg_conf)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.decoy_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.default_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.phantom_subnets_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.conjure_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dns_reg_conf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.decoy_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.generation {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.default_pubkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.phantom_subnets_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.conjure_pubkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.dns_reg_conf.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientConf {
        ClientConf::new()
    }

    fn clear(&mut self) {
        self.decoy_list.clear();
        self.generation = ::std::option::Option::None;
        self.default_pubkey.clear();
        self.phantom_subnets_list.clear();
        self.conjure_pubkey.clear();
        self.dns_reg_conf.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientConf {
        static instance: ClientConf = ClientConf {
            decoy_list: ::protobuf::MessageField::none(),
            generation: ::std::option::Option::None,
            default_pubkey: ::protobuf::MessageField::none(),
            phantom_subnets_list: ::protobuf::MessageField::none(),
            conjure_pubkey: ::protobuf::MessageField::none(),
            dns_reg_conf: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientConf {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientConf").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientConf {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Configuration for DNS registrar
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DnsRegConf)
pub struct DnsRegConf {
    // message fields
    // @@protoc_insertion_point(field:proto.DnsRegConf.dns_reg_method)
    pub dns_reg_method: ::std::option::Option<::protobuf::EnumOrUnknown<DnsRegMethod>>,
    // @@protoc_insertion_point(field:proto.DnsRegConf.target)
    pub target: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DnsRegConf.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DnsRegConf.pubkey)
    pub pubkey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DnsRegConf.utls_distribution)
    pub utls_distribution: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DnsRegConf.stun_server)
    pub stun_server: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DnsRegConf.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DnsRegConf {
    fn default() -> &'a DnsRegConf {
        <DnsRegConf as ::protobuf::Message>::default_instance()
    }
}

impl DnsRegConf {
    pub fn new() -> DnsRegConf {
        ::std::default::Default::default()
    }

    // required .proto.DnsRegMethod dns_reg_method = 1;

    pub fn dns_reg_method(&self) -> DnsRegMethod {
        match self.dns_reg_method {
            Some(e) => e.enum_value_or(DnsRegMethod::UDP),
            None => DnsRegMethod::UDP,
        }
    }

    pub fn clear_dns_reg_method(&mut self) {
        self.dns_reg_method = ::std::option::Option::None;
    }

    pub fn has_dns_reg_method(&self) -> bool {
        self.dns_reg_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dns_reg_method(&mut self, v: DnsRegMethod) {
        self.dns_reg_method = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string target = 2;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string domain = 3;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes pubkey = 4;

    pub fn pubkey(&self) -> &[u8] {
        match self.pubkey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pubkey(&mut self) {
        self.pubkey = ::std::option::Option::None;
    }

    pub fn has_pubkey(&self) -> bool {
        self.pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pubkey.is_none() {
            self.pubkey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        self.pubkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string utls_distribution = 5;

    pub fn utls_distribution(&self) -> &str {
        match self.utls_distribution.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_utls_distribution(&mut self) {
        self.utls_distribution = ::std::option::Option::None;
    }

    pub fn has_utls_distribution(&self) -> bool {
        self.utls_distribution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utls_distribution(&mut self, v: ::std::string::String) {
        self.utls_distribution = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utls_distribution(&mut self) -> &mut ::std::string::String {
        if self.utls_distribution.is_none() {
            self.utls_distribution = ::std::option::Option::Some(::std::string::String::new());
        }
        self.utls_distribution.as_mut().unwrap()
    }

    // Take field
    pub fn take_utls_distribution(&mut self) -> ::std::string::String {
        self.utls_distribution.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stun_server = 6;

    pub fn stun_server(&self) -> &str {
        match self.stun_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stun_server(&mut self) {
        self.stun_server = ::std::option::Option::None;
    }

    pub fn has_stun_server(&self) -> bool {
        self.stun_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_server(&mut self, v: ::std::string::String) {
        self.stun_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stun_server(&mut self) -> &mut ::std::string::String {
        if self.stun_server.is_none() {
            self.stun_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stun_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_stun_server(&mut self) -> ::std::string::String {
        self.stun_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dns_reg_method",
            |m: &DnsRegConf| { &m.dns_reg_method },
            |m: &mut DnsRegConf| { &mut m.dns_reg_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &DnsRegConf| { &m.target },
            |m: &mut DnsRegConf| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "domain",
            |m: &DnsRegConf| { &m.domain },
            |m: &mut DnsRegConf| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pubkey",
            |m: &DnsRegConf| { &m.pubkey },
            |m: &mut DnsRegConf| { &mut m.pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utls_distribution",
            |m: &DnsRegConf| { &m.utls_distribution },
            |m: &mut DnsRegConf| { &mut m.utls_distribution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stun_server",
            |m: &DnsRegConf| { &m.stun_server },
            |m: &mut DnsRegConf| { &mut m.stun_server },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DnsRegConf>(
            "DnsRegConf",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DnsRegConf {
    const NAME: &'static str = "DnsRegConf";

    fn is_initialized(&self) -> bool {
        if self.dns_reg_method.is_none() {
            return false;
        }
        if self.domain.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dns_reg_method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.pubkey = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.utls_distribution = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.stun_server = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dns_reg_method {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.pubkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.utls_distribution.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.stun_server.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dns_reg_method {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.domain.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.pubkey.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.utls_distribution.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.stun_server.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DnsRegConf {
        DnsRegConf::new()
    }

    fn clear(&mut self) {
        self.dns_reg_method = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.pubkey = ::std::option::Option::None;
        self.utls_distribution = ::std::option::Option::None;
        self.stun_server = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DnsRegConf {
        static instance: DnsRegConf = DnsRegConf {
            dns_reg_method: ::std::option::Option::None,
            target: ::std::option::Option::None,
            domain: ::std::option::Option::None,
            pubkey: ::std::option::Option::None,
            utls_distribution: ::std::option::Option::None,
            stun_server: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DnsRegConf {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DnsRegConf").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DnsRegConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsRegConf {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DecoyList)
pub struct DecoyList {
    // message fields
    // @@protoc_insertion_point(field:proto.DecoyList.tls_decoys)
    pub tls_decoys: ::std::vec::Vec<TLSDecoySpec>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DecoyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DecoyList {
    fn default() -> &'a DecoyList {
        <DecoyList as ::protobuf::Message>::default_instance()
    }
}

impl DecoyList {
    pub fn new() -> DecoyList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tls_decoys",
            |m: &DecoyList| { &m.tls_decoys },
            |m: &mut DecoyList| { &mut m.tls_decoys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DecoyList>(
            "DecoyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DecoyList {
    const NAME: &'static str = "DecoyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tls_decoys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tls_decoys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tls_decoys {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DecoyList {
        DecoyList::new()
    }

    fn clear(&mut self) {
        self.tls_decoys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DecoyList {
        static instance: DecoyList = DecoyList {
            tls_decoys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DecoyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DecoyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DecoyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecoyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PhantomSubnetsList)
pub struct PhantomSubnetsList {
    // message fields
    // @@protoc_insertion_point(field:proto.PhantomSubnetsList.weighted_subnets)
    pub weighted_subnets: ::std::vec::Vec<PhantomSubnets>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PhantomSubnetsList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhantomSubnetsList {
    fn default() -> &'a PhantomSubnetsList {
        <PhantomSubnetsList as ::protobuf::Message>::default_instance()
    }
}

impl PhantomSubnetsList {
    pub fn new() -> PhantomSubnetsList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weighted_subnets",
            |m: &PhantomSubnetsList| { &m.weighted_subnets },
            |m: &mut PhantomSubnetsList| { &mut m.weighted_subnets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhantomSubnetsList>(
            "PhantomSubnetsList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhantomSubnetsList {
    const NAME: &'static str = "PhantomSubnetsList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.weighted_subnets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.weighted_subnets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.weighted_subnets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhantomSubnetsList {
        PhantomSubnetsList::new()
    }

    fn clear(&mut self) {
        self.weighted_subnets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhantomSubnetsList {
        static instance: PhantomSubnetsList = PhantomSubnetsList {
            weighted_subnets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhantomSubnetsList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhantomSubnetsList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhantomSubnetsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhantomSubnetsList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PhantomSubnets)
pub struct PhantomSubnets {
    // message fields
    // @@protoc_insertion_point(field:proto.PhantomSubnets.weight)
    pub weight: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.PhantomSubnets.subnets)
    pub subnets: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PhantomSubnets.randomize_dst_port)
    pub randomize_dst_port: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PhantomSubnets.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhantomSubnets {
    fn default() -> &'a PhantomSubnets {
        <PhantomSubnets as ::protobuf::Message>::default_instance()
    }
}

impl PhantomSubnets {
    pub fn new() -> PhantomSubnets {
        ::std::default::Default::default()
    }

    // optional uint32 weight = 1;

    pub fn weight(&self) -> u32 {
        self.weight.unwrap_or(0)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // optional bool randomize_dst_port = 3;

    pub fn randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.unwrap_or(false)
    }

    pub fn clear_randomize_dst_port(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
    }

    pub fn has_randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomize_dst_port(&mut self, v: bool) {
        self.randomize_dst_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &PhantomSubnets| { &m.weight },
            |m: &mut PhantomSubnets| { &mut m.weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subnets",
            |m: &PhantomSubnets| { &m.subnets },
            |m: &mut PhantomSubnets| { &mut m.subnets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "randomize_dst_port",
            |m: &PhantomSubnets| { &m.randomize_dst_port },
            |m: &mut PhantomSubnets| { &mut m.randomize_dst_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhantomSubnets>(
            "PhantomSubnets",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhantomSubnets {
    const NAME: &'static str = "PhantomSubnets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.weight = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.subnets.push(is.read_string()?);
                },
                24 => {
                    self.randomize_dst_port = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.subnets {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.randomize_dst_port {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.weight {
            os.write_uint32(1, v)?;
        }
        for v in &self.subnets {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.randomize_dst_port {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhantomSubnets {
        PhantomSubnets::new()
    }

    fn clear(&mut self) {
        self.weight = ::std::option::Option::None;
        self.subnets.clear();
        self.randomize_dst_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhantomSubnets {
        static instance: PhantomSubnets = PhantomSubnets {
            weight: ::std::option::Option::None,
            subnets: ::std::vec::Vec::new(),
            randomize_dst_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhantomSubnets {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhantomSubnets").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhantomSubnets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhantomSubnets {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Deflated ICE Candidate by seed2sdp package
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.WebRTCICECandidate)
pub struct WebRTCICECandidate {
    // message fields
    ///  IP is represented in its 16-byte form
    // @@protoc_insertion_point(field:proto.WebRTCICECandidate.ip_upper)
    pub ip_upper: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.WebRTCICECandidate.ip_lower)
    pub ip_lower: ::std::option::Option<u64>,
    ///  Composed info includes port, tcptype (unset if not tcp), candidate type (host, srflx, prflx), protocol (TCP/UDP), and component (RTP/RTCP)
    // @@protoc_insertion_point(field:proto.WebRTCICECandidate.composed_info)
    pub composed_info: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.WebRTCICECandidate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebRTCICECandidate {
    fn default() -> &'a WebRTCICECandidate {
        <WebRTCICECandidate as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCICECandidate {
    pub fn new() -> WebRTCICECandidate {
        ::std::default::Default::default()
    }

    // required uint64 ip_upper = 1;

    pub fn ip_upper(&self) -> u64 {
        self.ip_upper.unwrap_or(0)
    }

    pub fn clear_ip_upper(&mut self) {
        self.ip_upper = ::std::option::Option::None;
    }

    pub fn has_ip_upper(&self) -> bool {
        self.ip_upper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_upper(&mut self, v: u64) {
        self.ip_upper = ::std::option::Option::Some(v);
    }

    // required uint64 ip_lower = 2;

    pub fn ip_lower(&self) -> u64 {
        self.ip_lower.unwrap_or(0)
    }

    pub fn clear_ip_lower(&mut self) {
        self.ip_lower = ::std::option::Option::None;
    }

    pub fn has_ip_lower(&self) -> bool {
        self.ip_lower.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_lower(&mut self, v: u64) {
        self.ip_lower = ::std::option::Option::Some(v);
    }

    // required uint32 composed_info = 3;

    pub fn composed_info(&self) -> u32 {
        self.composed_info.unwrap_or(0)
    }

    pub fn clear_composed_info(&mut self) {
        self.composed_info = ::std::option::Option::None;
    }

    pub fn has_composed_info(&self) -> bool {
        self.composed_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composed_info(&mut self, v: u32) {
        self.composed_info = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_upper",
            |m: &WebRTCICECandidate| { &m.ip_upper },
            |m: &mut WebRTCICECandidate| { &mut m.ip_upper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_lower",
            |m: &WebRTCICECandidate| { &m.ip_lower },
            |m: &mut WebRTCICECandidate| { &mut m.ip_lower },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "composed_info",
            |m: &WebRTCICECandidate| { &m.composed_info },
            |m: &mut WebRTCICECandidate| { &mut m.composed_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebRTCICECandidate>(
            "WebRTCICECandidate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebRTCICECandidate {
    const NAME: &'static str = "WebRTCICECandidate";

    fn is_initialized(&self) -> bool {
        if self.ip_upper.is_none() {
            return false;
        }
        if self.ip_lower.is_none() {
            return false;
        }
        if self.composed_info.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ip_upper = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.ip_lower = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.composed_info = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip_upper {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.ip_lower {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.composed_info {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip_upper {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ip_lower {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.composed_info {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebRTCICECandidate {
        WebRTCICECandidate::new()
    }

    fn clear(&mut self) {
        self.ip_upper = ::std::option::Option::None;
        self.ip_lower = ::std::option::Option::None;
        self.composed_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebRTCICECandidate {
        static instance: WebRTCICECandidate = WebRTCICECandidate {
            ip_upper: ::std::option::Option::None,
            ip_lower: ::std::option::Option::None,
            composed_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebRTCICECandidate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebRTCICECandidate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebRTCICECandidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCICECandidate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Deflated SDP for WebRTC by seed2sdp package
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.WebRTCSDP)
pub struct WebRTCSDP {
    // message fields
    // @@protoc_insertion_point(field:proto.WebRTCSDP.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.WebRTCSDP.candidates)
    pub candidates: ::std::vec::Vec<WebRTCICECandidate>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.WebRTCSDP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebRTCSDP {
    fn default() -> &'a WebRTCSDP {
        <WebRTCSDP as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCSDP {
    pub fn new() -> WebRTCSDP {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &WebRTCSDP| { &m.type_ },
            |m: &mut WebRTCSDP| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "candidates",
            |m: &WebRTCSDP| { &m.candidates },
            |m: &mut WebRTCSDP| { &mut m.candidates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebRTCSDP>(
            "WebRTCSDP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebRTCSDP {
    const NAME: &'static str = "WebRTCSDP";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        for v in &self.candidates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.candidates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.candidates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        for v in &self.candidates {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebRTCSDP {
        WebRTCSDP::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.candidates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebRTCSDP {
        static instance: WebRTCSDP = WebRTCSDP {
            type_: ::std::option::Option::None,
            candidates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebRTCSDP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebRTCSDP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebRTCSDP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCSDP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WebRTCSignal includes a deflated SDP and a seed
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.WebRTCSignal)
pub struct WebRTCSignal {
    // message fields
    // @@protoc_insertion_point(field:proto.WebRTCSignal.seed)
    pub seed: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebRTCSignal.sdp)
    pub sdp: ::protobuf::MessageField<WebRTCSDP>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.WebRTCSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebRTCSignal {
    fn default() -> &'a WebRTCSignal {
        <WebRTCSignal as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCSignal {
    pub fn new() -> WebRTCSignal {
        ::std::default::Default::default()
    }

    // required string seed = 1;

    pub fn seed(&self) -> &str {
        match self.seed.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_seed(&mut self) {
        self.seed = ::std::option::Option::None;
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: ::std::string::String) {
        self.seed = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed(&mut self) -> &mut ::std::string::String {
        if self.seed.is_none() {
            self.seed = ::std::option::Option::Some(::std::string::String::new());
        }
        self.seed.as_mut().unwrap()
    }

    // Take field
    pub fn take_seed(&mut self) -> ::std::string::String {
        self.seed.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seed",
            |m: &WebRTCSignal| { &m.seed },
            |m: &mut WebRTCSignal| { &mut m.seed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebRTCSDP>(
            "sdp",
            |m: &WebRTCSignal| { &m.sdp },
            |m: &mut WebRTCSignal| { &mut m.sdp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebRTCSignal>(
            "WebRTCSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebRTCSignal {
    const NAME: &'static str = "WebRTCSignal";

    fn is_initialized(&self) -> bool {
        if self.seed.is_none() {
            return false;
        }
        if self.sdp.is_none() {
            return false;
        }
        for v in &self.sdp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.seed = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sdp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seed.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sdp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seed.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sdp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebRTCSignal {
        WebRTCSignal::new()
    }

    fn clear(&mut self) {
        self.seed = ::std::option::Option::None;
        self.sdp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebRTCSignal {
        static instance: WebRTCSignal = WebRTCSignal {
            seed: ::std::option::Option::None,
            sdp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebRTCSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebRTCSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebRTCSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Addr)
pub struct Addr {
    // message fields
    // @@protoc_insertion_point(field:proto.Addr.IP)
    pub IP: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.Addr.Port)
    pub Port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Addr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Addr {
    fn default() -> &'a Addr {
        <Addr as ::protobuf::Message>::default_instance()
    }
}

impl Addr {
    pub fn new() -> Addr {
        ::std::default::Default::default()
    }

    // optional bytes IP = 1;

    pub fn IP(&self) -> &[u8] {
        match self.IP.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_IP(&mut self) {
        self.IP = ::std::option::Option::None;
    }

    pub fn has_IP(&self) -> bool {
        self.IP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_IP(&mut self, v: ::std::vec::Vec<u8>) {
        self.IP = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IP(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.IP.is_none() {
            self.IP = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.IP.as_mut().unwrap()
    }

    // Take field
    pub fn take_IP(&mut self) -> ::std::vec::Vec<u8> {
        self.IP.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 Port = 2;

    pub fn Port(&self) -> u32 {
        self.Port.unwrap_or(0)
    }

    pub fn clear_Port(&mut self) {
        self.Port = ::std::option::Option::None;
    }

    pub fn has_Port(&self) -> bool {
        self.Port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Port(&mut self, v: u32) {
        self.Port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "IP",
            |m: &Addr| { &m.IP },
            |m: &mut Addr| { &mut m.IP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Port",
            |m: &Addr| { &m.Port },
            |m: &mut Addr| { &mut m.Port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Addr>(
            "Addr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Addr {
    const NAME: &'static str = "Addr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.IP = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.Port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.IP.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.Port {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.IP.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.Port {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Addr {
        Addr::new()
    }

    fn clear(&mut self) {
        self.IP = ::std::option::Option::None;
        self.Port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Addr {
        static instance: Addr = Addr {
            IP: ::std::option::Option::None,
            Port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Addr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Addr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Addr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Addr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DTLSTransportParams)
pub struct DTLSTransportParams {
    // message fields
    // @@protoc_insertion_point(field:proto.DTLSTransportParams.src_addr4)
    pub src_addr4: ::protobuf::MessageField<Addr>,
    // @@protoc_insertion_point(field:proto.DTLSTransportParams.src_addr6)
    pub src_addr6: ::protobuf::MessageField<Addr>,
    // @@protoc_insertion_point(field:proto.DTLSTransportParams.randomize_dst_port)
    pub randomize_dst_port: ::std::option::Option<bool>,
    ///  Unordered sets the reliability of the DTLS stream to unordered
    // @@protoc_insertion_point(field:proto.DTLSTransportParams.unordered)
    pub unordered: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DTLSTransportParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DTLSTransportParams {
    fn default() -> &'a DTLSTransportParams {
        <DTLSTransportParams as ::protobuf::Message>::default_instance()
    }
}

impl DTLSTransportParams {
    pub fn new() -> DTLSTransportParams {
        ::std::default::Default::default()
    }

    // optional bool randomize_dst_port = 3;

    pub fn randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.unwrap_or(false)
    }

    pub fn clear_randomize_dst_port(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
    }

    pub fn has_randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomize_dst_port(&mut self, v: bool) {
        self.randomize_dst_port = ::std::option::Option::Some(v);
    }

    // optional bool unordered = 4;

    pub fn unordered(&self) -> bool {
        self.unordered.unwrap_or(false)
    }

    pub fn clear_unordered(&mut self) {
        self.unordered = ::std::option::Option::None;
    }

    pub fn has_unordered(&self) -> bool {
        self.unordered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unordered(&mut self, v: bool) {
        self.unordered = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Addr>(
            "src_addr4",
            |m: &DTLSTransportParams| { &m.src_addr4 },
            |m: &mut DTLSTransportParams| { &mut m.src_addr4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Addr>(
            "src_addr6",
            |m: &DTLSTransportParams| { &m.src_addr6 },
            |m: &mut DTLSTransportParams| { &mut m.src_addr6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "randomize_dst_port",
            |m: &DTLSTransportParams| { &m.randomize_dst_port },
            |m: &mut DTLSTransportParams| { &mut m.randomize_dst_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unordered",
            |m: &DTLSTransportParams| { &m.unordered },
            |m: &mut DTLSTransportParams| { &mut m.unordered },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DTLSTransportParams>(
            "DTLSTransportParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DTLSTransportParams {
    const NAME: &'static str = "DTLSTransportParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_addr4)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_addr6)?;
                },
                24 => {
                    self.randomize_dst_port = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.unordered = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.src_addr4.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.src_addr6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.randomize_dst_port {
            my_size += 1 + 1;
        }
        if let Some(v) = self.unordered {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.src_addr4.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.src_addr6.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.randomize_dst_port {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.unordered {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DTLSTransportParams {
        DTLSTransportParams::new()
    }

    fn clear(&mut self) {
        self.src_addr4.clear();
        self.src_addr6.clear();
        self.randomize_dst_port = ::std::option::Option::None;
        self.unordered = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DTLSTransportParams {
        static instance: DTLSTransportParams = DTLSTransportParams {
            src_addr4: ::protobuf::MessageField::none(),
            src_addr6: ::protobuf::MessageField::none(),
            randomize_dst_port: ::std::option::Option::None,
            unordered: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DTLSTransportParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DTLSTransportParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DTLSTransportParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DTLSTransportParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StationToClient)
pub struct StationToClient {
    // message fields
    ///  Should accompany (at least) SESSION_INIT and CONFIRM_RECONNECT.
    // @@protoc_insertion_point(field:proto.StationToClient.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    ///  There might be a state transition. May be absent; absence should be
    ///  treated identically to NO_CHANGE.
    // @@protoc_insertion_point(field:proto.StationToClient.state_transition)
    pub state_transition: ::std::option::Option<::protobuf::EnumOrUnknown<S2C_Transition>>,
    ///  The station can send client config info piggybacked
    ///  on any message, as it sees fit
    // @@protoc_insertion_point(field:proto.StationToClient.config_info)
    pub config_info: ::protobuf::MessageField<ClientConf>,
    ///  If state_transition == S2C_ERROR, this field is the explanation.
    // @@protoc_insertion_point(field:proto.StationToClient.err_reason)
    pub err_reason: ::std::option::Option<::protobuf::EnumOrUnknown<ErrorReasonS2C>>,
    ///  Signals client to stop connecting for following amount of seconds
    // @@protoc_insertion_point(field:proto.StationToClient.tmp_backoff)
    pub tmp_backoff: ::std::option::Option<u32>,
    ///  Sent in SESSION_INIT, identifies the station that picked up
    // @@protoc_insertion_point(field:proto.StationToClient.station_id)
    pub station_id: ::std::option::Option<::std::string::String>,
    ///  Random-sized junk to defeat packet size fingerprinting.
    // @@protoc_insertion_point(field:proto.StationToClient.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StationToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StationToClient {
    fn default() -> &'a StationToClient {
        <StationToClient as ::protobuf::Message>::default_instance()
    }
}

impl StationToClient {
    pub fn new() -> StationToClient {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional .proto.S2C_Transition state_transition = 2;

    pub fn state_transition(&self) -> S2C_Transition {
        match self.state_transition {
            Some(e) => e.enum_value_or(S2C_Transition::S2C_NO_CHANGE),
            None => S2C_Transition::S2C_NO_CHANGE,
        }
    }

    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: S2C_Transition) {
        self.state_transition = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.ErrorReasonS2C err_reason = 4;

    pub fn err_reason(&self) -> ErrorReasonS2C {
        match self.err_reason {
            Some(e) => e.enum_value_or(ErrorReasonS2C::NO_ERROR),
            None => ErrorReasonS2C::NO_ERROR,
        }
    }

    pub fn clear_err_reason(&mut self) {
        self.err_reason = ::std::option::Option::None;
    }

    pub fn has_err_reason(&self) -> bool {
        self.err_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_err_reason(&mut self, v: ErrorReasonS2C) {
        self.err_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 tmp_backoff = 5;

    pub fn tmp_backoff(&self) -> u32 {
        self.tmp_backoff.unwrap_or(0)
    }

    pub fn clear_tmp_backoff(&mut self) {
        self.tmp_backoff = ::std::option::Option::None;
    }

    pub fn has_tmp_backoff(&self) -> bool {
        self.tmp_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tmp_backoff(&mut self, v: u32) {
        self.tmp_backoff = ::std::option::Option::Some(v);
    }

    // optional string station_id = 6;

    pub fn station_id(&self) -> &str {
        match self.station_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_station_id(&mut self) {
        self.station_id = ::std::option::Option::None;
    }

    pub fn has_station_id(&self) -> bool {
        self.station_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_id(&mut self, v: ::std::string::String) {
        self.station_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_station_id(&mut self) -> &mut ::std::string::String {
        if self.station_id.is_none() {
            self.station_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.station_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_station_id(&mut self) -> ::std::string::String {
        self.station_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes padding = 100;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &StationToClient| { &m.protocol_version },
            |m: &mut StationToClient| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_transition",
            |m: &StationToClient| { &m.state_transition },
            |m: &mut StationToClient| { &mut m.state_transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientConf>(
            "config_info",
            |m: &StationToClient| { &m.config_info },
            |m: &mut StationToClient| { &mut m.config_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "err_reason",
            |m: &StationToClient| { &m.err_reason },
            |m: &mut StationToClient| { &mut m.err_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tmp_backoff",
            |m: &StationToClient| { &m.tmp_backoff },
            |m: &mut StationToClient| { &mut m.tmp_backoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "station_id",
            |m: &StationToClient| { &m.station_id },
            |m: &mut StationToClient| { &mut m.station_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &StationToClient| { &m.padding },
            |m: &mut StationToClient| { &mut m.padding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StationToClient>(
            "StationToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StationToClient {
    const NAME: &'static str = "StationToClient";

    fn is_initialized(&self) -> bool {
        for v in &self.config_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.state_transition = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config_info)?;
                },
                32 => {
                    self.err_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.tmp_backoff = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.station_id = ::std::option::Option::Some(is.read_string()?);
                },
                802 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.config_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.err_reason {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.tmp_backoff {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.station_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.config_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.err_reason {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tmp_backoff {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.station_id.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(100, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StationToClient {
        StationToClient::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.config_info.clear();
        self.err_reason = ::std::option::Option::None;
        self.tmp_backoff = ::std::option::Option::None;
        self.station_id = ::std::option::Option::None;
        self.padding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StationToClient {
        static instance: StationToClient = StationToClient {
            protocol_version: ::std::option::Option::None,
            state_transition: ::std::option::Option::None,
            config_info: ::protobuf::MessageField::none(),
            err_reason: ::std::option::Option::None,
            tmp_backoff: ::std::option::Option::None,
            station_id: ::std::option::Option::None,
            padding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StationToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StationToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StationToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.RegistrationFlags)
pub struct RegistrationFlags {
    // message fields
    // @@protoc_insertion_point(field:proto.RegistrationFlags.upload_only)
    pub upload_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.RegistrationFlags.dark_decoy)
    pub dark_decoy: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.RegistrationFlags.proxy_header)
    pub proxy_header: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.RegistrationFlags.use_TIL)
    pub use_TIL: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.RegistrationFlags.prescanned)
    pub prescanned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.RegistrationFlags.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegistrationFlags {
    fn default() -> &'a RegistrationFlags {
        <RegistrationFlags as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationFlags {
    pub fn new() -> RegistrationFlags {
        ::std::default::Default::default()
    }

    // optional bool upload_only = 1;

    pub fn upload_only(&self) -> bool {
        self.upload_only.unwrap_or(false)
    }

    pub fn clear_upload_only(&mut self) {
        self.upload_only = ::std::option::Option::None;
    }

    pub fn has_upload_only(&self) -> bool {
        self.upload_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_only(&mut self, v: bool) {
        self.upload_only = ::std::option::Option::Some(v);
    }

    // optional bool dark_decoy = 2;

    pub fn dark_decoy(&self) -> bool {
        self.dark_decoy.unwrap_or(false)
    }

    pub fn clear_dark_decoy(&mut self) {
        self.dark_decoy = ::std::option::Option::None;
    }

    pub fn has_dark_decoy(&self) -> bool {
        self.dark_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dark_decoy(&mut self, v: bool) {
        self.dark_decoy = ::std::option::Option::Some(v);
    }

    // optional bool proxy_header = 3;

    pub fn proxy_header(&self) -> bool {
        self.proxy_header.unwrap_or(false)
    }

    pub fn clear_proxy_header(&mut self) {
        self.proxy_header = ::std::option::Option::None;
    }

    pub fn has_proxy_header(&self) -> bool {
        self.proxy_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_header(&mut self, v: bool) {
        self.proxy_header = ::std::option::Option::Some(v);
    }

    // optional bool use_TIL = 4;

    pub fn use_TIL(&self) -> bool {
        self.use_TIL.unwrap_or(false)
    }

    pub fn clear_use_TIL(&mut self) {
        self.use_TIL = ::std::option::Option::None;
    }

    pub fn has_use_TIL(&self) -> bool {
        self.use_TIL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_TIL(&mut self, v: bool) {
        self.use_TIL = ::std::option::Option::Some(v);
    }

    // optional bool prescanned = 5;

    pub fn prescanned(&self) -> bool {
        self.prescanned.unwrap_or(false)
    }

    pub fn clear_prescanned(&mut self) {
        self.prescanned = ::std::option::Option::None;
    }

    pub fn has_prescanned(&self) -> bool {
        self.prescanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prescanned(&mut self, v: bool) {
        self.prescanned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_only",
            |m: &RegistrationFlags| { &m.upload_only },
            |m: &mut RegistrationFlags| { &mut m.upload_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dark_decoy",
            |m: &RegistrationFlags| { &m.dark_decoy },
            |m: &mut RegistrationFlags| { &mut m.dark_decoy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proxy_header",
            |m: &RegistrationFlags| { &m.proxy_header },
            |m: &mut RegistrationFlags| { &mut m.proxy_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_TIL",
            |m: &RegistrationFlags| { &m.use_TIL },
            |m: &mut RegistrationFlags| { &mut m.use_TIL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prescanned",
            |m: &RegistrationFlags| { &m.prescanned },
            |m: &mut RegistrationFlags| { &mut m.prescanned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegistrationFlags>(
            "RegistrationFlags",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegistrationFlags {
    const NAME: &'static str = "RegistrationFlags";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upload_only = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.dark_decoy = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.proxy_header = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.use_TIL = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.prescanned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upload_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dark_decoy {
            my_size += 1 + 1;
        }
        if let Some(v) = self.proxy_header {
            my_size += 1 + 1;
        }
        if let Some(v) = self.use_TIL {
            my_size += 1 + 1;
        }
        if let Some(v) = self.prescanned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upload_only {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dark_decoy {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.proxy_header {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.use_TIL {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.prescanned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegistrationFlags {
        RegistrationFlags::new()
    }

    fn clear(&mut self) {
        self.upload_only = ::std::option::Option::None;
        self.dark_decoy = ::std::option::Option::None;
        self.proxy_header = ::std::option::Option::None;
        self.use_TIL = ::std::option::Option::None;
        self.prescanned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegistrationFlags {
        static instance: RegistrationFlags = RegistrationFlags {
            upload_only: ::std::option::Option::None,
            dark_decoy: ::std::option::Option::None,
            proxy_header: ::std::option::Option::None,
            use_TIL: ::std::option::Option::None,
            prescanned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegistrationFlags {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegistrationFlags").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegistrationFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationFlags {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ClientToStation)
pub struct ClientToStation {
    // message fields
    // @@protoc_insertion_point(field:proto.ClientToStation.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    ///  The client reports its decoy list's version number here, which the
    ///  station can use to decide whether to send an updated one. The station
    ///  should always send a list if this field is set to 0.
    // @@protoc_insertion_point(field:proto.ClientToStation.decoy_list_generation)
    pub decoy_list_generation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ClientToStation.state_transition)
    pub state_transition: ::std::option::Option<::protobuf::EnumOrUnknown<C2S_Transition>>,
    ///  The position in the overall session's upload sequence where the current
    ///  YIELD=>ACQUIRE switchover is happening.
    // @@protoc_insertion_point(field:proto.ClientToStation.upload_sync)
    pub upload_sync: ::std::option::Option<u64>,
    ///  High level client library version used for indicating feature support, or
    ///  lack therof.
    // @@protoc_insertion_point(field:proto.ClientToStation.client_lib_version)
    pub client_lib_version: ::std::option::Option<u32>,
    ///  Indicates whether the client will allow the registrar to provide alternative parameters that
    ///  may work better in substitute for the deterministically selected parameters. This only works
    ///  for bidirectional registration methods where the client receives a RegistrationResponse.
    // @@protoc_insertion_point(field:proto.ClientToStation.disable_registrar_overrides)
    pub disable_registrar_overrides: ::std::option::Option<bool>,
    ///  List of decoys that client have unsuccessfully tried in current session.
    ///  Could be sent in chunks
    // @@protoc_insertion_point(field:proto.ClientToStation.failed_decoys)
    pub failed_decoys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ClientToStation.stats)
    pub stats: ::protobuf::MessageField<SessionStats>,
    ///  NullTransport, MinTransport, Obfs4Transport, etc. Transport type we want from phantom proxy
    // @@protoc_insertion_point(field:proto.ClientToStation.transport)
    pub transport: ::std::option::Option<::protobuf::EnumOrUnknown<TransportType>>,
    // @@protoc_insertion_point(field:proto.ClientToStation.transport_params)
    pub transport_params: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  Station is only required to check this variable during session initialization.
    ///  If set, station must facilitate connection to said target by itself, i.e. write into squid
    ///  socket an HTTP/SOCKS/any other connection request.
    ///  covert_address must have exactly one ':' colon, that separates host (literal IP address or
    ///  resolvable hostname) and port
    ///  TODO: make it required for initialization, and stop connecting any client straight to squid?
    // @@protoc_insertion_point(field:proto.ClientToStation.covert_address)
    pub covert_address: ::std::option::Option<::std::string::String>,
    ///  Used in dark decoys to signal which dark decoy it will connect to.
    // @@protoc_insertion_point(field:proto.ClientToStation.masked_decoy_server_name)
    pub masked_decoy_server_name: ::std::option::Option<::std::string::String>,
    ///  Used to indicate to server if client is registering v4, v6 or both
    // @@protoc_insertion_point(field:proto.ClientToStation.v6_support)
    pub v6_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ClientToStation.v4_support)
    pub v4_support: ::std::option::Option<bool>,
    ///  A collection of optional flags for the registration.
    // @@protoc_insertion_point(field:proto.ClientToStation.flags)
    pub flags: ::protobuf::MessageField<RegistrationFlags>,
    ///  Transport Extensions
    ///  TODO(jmwample) - move to WebRTC specific transport params protobuf message.
    // @@protoc_insertion_point(field:proto.ClientToStation.webrtc_signal)
    pub webrtc_signal: ::protobuf::MessageField<WebRTCSignal>,
    ///  Random-sized junk to defeat packet size fingerprinting.
    // @@protoc_insertion_point(field:proto.ClientToStation.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ClientToStation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientToStation {
    fn default() -> &'a ClientToStation {
        <ClientToStation as ::protobuf::Message>::default_instance()
    }
}

impl ClientToStation {
    pub fn new() -> ClientToStation {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 decoy_list_generation = 2;

    pub fn decoy_list_generation(&self) -> u32 {
        self.decoy_list_generation.unwrap_or(0)
    }

    pub fn clear_decoy_list_generation(&mut self) {
        self.decoy_list_generation = ::std::option::Option::None;
    }

    pub fn has_decoy_list_generation(&self) -> bool {
        self.decoy_list_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_list_generation(&mut self, v: u32) {
        self.decoy_list_generation = ::std::option::Option::Some(v);
    }

    // optional .proto.C2S_Transition state_transition = 3;

    pub fn state_transition(&self) -> C2S_Transition {
        match self.state_transition {
            Some(e) => e.enum_value_or(C2S_Transition::C2S_NO_CHANGE),
            None => C2S_Transition::C2S_NO_CHANGE,
        }
    }

    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: C2S_Transition) {
        self.state_transition = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 upload_sync = 4;

    pub fn upload_sync(&self) -> u64 {
        self.upload_sync.unwrap_or(0)
    }

    pub fn clear_upload_sync(&mut self) {
        self.upload_sync = ::std::option::Option::None;
    }

    pub fn has_upload_sync(&self) -> bool {
        self.upload_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_sync(&mut self, v: u64) {
        self.upload_sync = ::std::option::Option::Some(v);
    }

    // optional uint32 client_lib_version = 5;

    pub fn client_lib_version(&self) -> u32 {
        self.client_lib_version.unwrap_or(0)
    }

    pub fn clear_client_lib_version(&mut self) {
        self.client_lib_version = ::std::option::Option::None;
    }

    pub fn has_client_lib_version(&self) -> bool {
        self.client_lib_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_lib_version(&mut self, v: u32) {
        self.client_lib_version = ::std::option::Option::Some(v);
    }

    // optional bool disable_registrar_overrides = 6;

    pub fn disable_registrar_overrides(&self) -> bool {
        self.disable_registrar_overrides.unwrap_or(false)
    }

    pub fn clear_disable_registrar_overrides(&mut self) {
        self.disable_registrar_overrides = ::std::option::Option::None;
    }

    pub fn has_disable_registrar_overrides(&self) -> bool {
        self.disable_registrar_overrides.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_registrar_overrides(&mut self, v: bool) {
        self.disable_registrar_overrides = ::std::option::Option::Some(v);
    }

    // optional .proto.TransportType transport = 12;

    pub fn transport(&self) -> TransportType {
        match self.transport {
            Some(e) => e.enum_value_or(TransportType::Null),
            None => TransportType::Null,
        }
    }

    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: TransportType) {
        self.transport = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string covert_address = 20;

    pub fn covert_address(&self) -> &str {
        match self.covert_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_covert_address(&mut self) {
        self.covert_address = ::std::option::Option::None;
    }

    pub fn has_covert_address(&self) -> bool {
        self.covert_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_covert_address(&mut self, v: ::std::string::String) {
        self.covert_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_covert_address(&mut self) -> &mut ::std::string::String {
        if self.covert_address.is_none() {
            self.covert_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.covert_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_covert_address(&mut self) -> ::std::string::String {
        self.covert_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string masked_decoy_server_name = 21;

    pub fn masked_decoy_server_name(&self) -> &str {
        match self.masked_decoy_server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_masked_decoy_server_name(&mut self) {
        self.masked_decoy_server_name = ::std::option::Option::None;
    }

    pub fn has_masked_decoy_server_name(&self) -> bool {
        self.masked_decoy_server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked_decoy_server_name(&mut self, v: ::std::string::String) {
        self.masked_decoy_server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked_decoy_server_name(&mut self) -> &mut ::std::string::String {
        if self.masked_decoy_server_name.is_none() {
            self.masked_decoy_server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.masked_decoy_server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked_decoy_server_name(&mut self) -> ::std::string::String {
        self.masked_decoy_server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool v6_support = 22;

    pub fn v6_support(&self) -> bool {
        self.v6_support.unwrap_or(false)
    }

    pub fn clear_v6_support(&mut self) {
        self.v6_support = ::std::option::Option::None;
    }

    pub fn has_v6_support(&self) -> bool {
        self.v6_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v6_support(&mut self, v: bool) {
        self.v6_support = ::std::option::Option::Some(v);
    }

    // optional bool v4_support = 23;

    pub fn v4_support(&self) -> bool {
        self.v4_support.unwrap_or(false)
    }

    pub fn clear_v4_support(&mut self) {
        self.v4_support = ::std::option::Option::None;
    }

    pub fn has_v4_support(&self) -> bool {
        self.v4_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v4_support(&mut self, v: bool) {
        self.v4_support = ::std::option::Option::Some(v);
    }

    // optional bytes padding = 100;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &ClientToStation| { &m.protocol_version },
            |m: &mut ClientToStation| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decoy_list_generation",
            |m: &ClientToStation| { &m.decoy_list_generation },
            |m: &mut ClientToStation| { &mut m.decoy_list_generation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_transition",
            |m: &ClientToStation| { &m.state_transition },
            |m: &mut ClientToStation| { &mut m.state_transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_sync",
            |m: &ClientToStation| { &m.upload_sync },
            |m: &mut ClientToStation| { &mut m.upload_sync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_lib_version",
            |m: &ClientToStation| { &m.client_lib_version },
            |m: &mut ClientToStation| { &mut m.client_lib_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_registrar_overrides",
            |m: &ClientToStation| { &m.disable_registrar_overrides },
            |m: &mut ClientToStation| { &mut m.disable_registrar_overrides },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failed_decoys",
            |m: &ClientToStation| { &m.failed_decoys },
            |m: &mut ClientToStation| { &mut m.failed_decoys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SessionStats>(
            "stats",
            |m: &ClientToStation| { &m.stats },
            |m: &mut ClientToStation| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport",
            |m: &ClientToStation| { &m.transport },
            |m: &mut ClientToStation| { &mut m.transport },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "transport_params",
            |m: &ClientToStation| { &m.transport_params },
            |m: &mut ClientToStation| { &mut m.transport_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "covert_address",
            |m: &ClientToStation| { &m.covert_address },
            |m: &mut ClientToStation| { &mut m.covert_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "masked_decoy_server_name",
            |m: &ClientToStation| { &m.masked_decoy_server_name },
            |m: &mut ClientToStation| { &mut m.masked_decoy_server_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "v6_support",
            |m: &ClientToStation| { &m.v6_support },
            |m: &mut ClientToStation| { &mut m.v6_support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "v4_support",
            |m: &ClientToStation| { &m.v4_support },
            |m: &mut ClientToStation| { &mut m.v4_support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RegistrationFlags>(
            "flags",
            |m: &ClientToStation| { &m.flags },
            |m: &mut ClientToStation| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebRTCSignal>(
            "webrtc_signal",
            |m: &ClientToStation| { &m.webrtc_signal },
            |m: &mut ClientToStation| { &mut m.webrtc_signal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &ClientToStation| { &m.padding },
            |m: &mut ClientToStation| { &mut m.padding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientToStation>(
            "ClientToStation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientToStation {
    const NAME: &'static str = "ClientToStation";

    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.webrtc_signal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.decoy_list_generation = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state_transition = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.upload_sync = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.client_lib_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.disable_registrar_overrides = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.failed_decoys.push(is.read_string()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                96 => {
                    self.transport = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transport_params)?;
                },
                162 => {
                    self.covert_address = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.masked_decoy_server_name = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.v6_support = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.v4_support = ::std::option::Option::Some(is.read_bool()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flags)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webrtc_signal)?;
                },
                802 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.decoy_list_generation {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.upload_sync {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.client_lib_version {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.disable_registrar_overrides {
            my_size += 1 + 1;
        }
        for value in &self.failed_decoys {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.transport_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.covert_address.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.masked_decoy_server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.v6_support {
            my_size += 2 + 1;
        }
        if let Some(v) = self.v4_support {
            my_size += 2 + 1;
        }
        if let Some(v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.webrtc_signal.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.decoy_list_generation {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.upload_sync {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.client_lib_version {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.disable_registrar_overrides {
            os.write_bool(6, v)?;
        }
        for v in &self.failed_decoys {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.transport_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.covert_address.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.masked_decoy_server_name.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.v6_support {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.v4_support {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.flags.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.webrtc_signal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(100, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientToStation {
        ClientToStation::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.decoy_list_generation = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.upload_sync = ::std::option::Option::None;
        self.client_lib_version = ::std::option::Option::None;
        self.disable_registrar_overrides = ::std::option::Option::None;
        self.failed_decoys.clear();
        self.stats.clear();
        self.transport = ::std::option::Option::None;
        self.transport_params.clear();
        self.covert_address = ::std::option::Option::None;
        self.masked_decoy_server_name = ::std::option::Option::None;
        self.v6_support = ::std::option::Option::None;
        self.v4_support = ::std::option::Option::None;
        self.flags.clear();
        self.webrtc_signal.clear();
        self.padding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientToStation {
        static instance: ClientToStation = ClientToStation {
            protocol_version: ::std::option::Option::None,
            decoy_list_generation: ::std::option::Option::None,
            state_transition: ::std::option::Option::None,
            upload_sync: ::std::option::Option::None,
            client_lib_version: ::std::option::Option::None,
            disable_registrar_overrides: ::std::option::Option::None,
            failed_decoys: ::std::vec::Vec::new(),
            stats: ::protobuf::MessageField::none(),
            transport: ::std::option::Option::None,
            transport_params: ::protobuf::MessageField::none(),
            covert_address: ::std::option::Option::None,
            masked_decoy_server_name: ::std::option::Option::None,
            v6_support: ::std::option::Option::None,
            v4_support: ::std::option::Option::None,
            flags: ::protobuf::MessageField::none(),
            webrtc_signal: ::protobuf::MessageField::none(),
            padding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientToStation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientToStation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientToStation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientToStation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PrefixTransportParams)
pub struct PrefixTransportParams {
    // message fields
    ///  Prefix Identifier
    // @@protoc_insertion_point(field:proto.PrefixTransportParams.prefix_id)
    pub prefix_id: ::std::option::Option<i32>,
    ///  Prefix bytes (optional - usually sent from station to client as override if allowed by C2S)
    ///  as the station cannot take this into account when attempting to identify a connection.
    // @@protoc_insertion_point(field:proto.PrefixTransportParams.prefix)
    pub prefix: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.PrefixTransportParams.custom_flush_policy)
    pub custom_flush_policy: ::std::option::Option<i32>,
    ///  Indicates whether the client has elected to use destination port randomization. Should be
    ///  checked against selected transport to ensure that destination port randomization is
    ///  supported.
    // @@protoc_insertion_point(field:proto.PrefixTransportParams.randomize_dst_port)
    pub randomize_dst_port: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PrefixTransportParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrefixTransportParams {
    fn default() -> &'a PrefixTransportParams {
        <PrefixTransportParams as ::protobuf::Message>::default_instance()
    }
}

impl PrefixTransportParams {
    pub fn new() -> PrefixTransportParams {
        ::std::default::Default::default()
    }

    // optional int32 prefix_id = 1;

    pub fn prefix_id(&self) -> i32 {
        self.prefix_id.unwrap_or(0)
    }

    pub fn clear_prefix_id(&mut self) {
        self.prefix_id = ::std::option::Option::None;
    }

    pub fn has_prefix_id(&self) -> bool {
        self.prefix_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix_id(&mut self, v: i32) {
        self.prefix_id = ::std::option::Option::Some(v);
    }

    // optional bytes prefix = 2;

    pub fn prefix(&self) -> &[u8] {
        match self.prefix.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_prefix(&mut self) {
        self.prefix = ::std::option::Option::None;
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.prefix.is_none() {
            self.prefix = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        self.prefix.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 custom_flush_policy = 3;

    pub fn custom_flush_policy(&self) -> i32 {
        self.custom_flush_policy.unwrap_or(0)
    }

    pub fn clear_custom_flush_policy(&mut self) {
        self.custom_flush_policy = ::std::option::Option::None;
    }

    pub fn has_custom_flush_policy(&self) -> bool {
        self.custom_flush_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_flush_policy(&mut self, v: i32) {
        self.custom_flush_policy = ::std::option::Option::Some(v);
    }

    // optional bool randomize_dst_port = 13;

    pub fn randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.unwrap_or(false)
    }

    pub fn clear_randomize_dst_port(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
    }

    pub fn has_randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomize_dst_port(&mut self, v: bool) {
        self.randomize_dst_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefix_id",
            |m: &PrefixTransportParams| { &m.prefix_id },
            |m: &mut PrefixTransportParams| { &mut m.prefix_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefix",
            |m: &PrefixTransportParams| { &m.prefix },
            |m: &mut PrefixTransportParams| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_flush_policy",
            |m: &PrefixTransportParams| { &m.custom_flush_policy },
            |m: &mut PrefixTransportParams| { &mut m.custom_flush_policy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "randomize_dst_port",
            |m: &PrefixTransportParams| { &m.randomize_dst_port },
            |m: &mut PrefixTransportParams| { &mut m.randomize_dst_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrefixTransportParams>(
            "PrefixTransportParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrefixTransportParams {
    const NAME: &'static str = "PrefixTransportParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prefix_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.prefix = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.custom_flush_policy = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.randomize_dst_port = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prefix_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.custom_flush_policy {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.randomize_dst_port {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.prefix_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.prefix.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.custom_flush_policy {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.randomize_dst_port {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrefixTransportParams {
        PrefixTransportParams::new()
    }

    fn clear(&mut self) {
        self.prefix_id = ::std::option::Option::None;
        self.prefix = ::std::option::Option::None;
        self.custom_flush_policy = ::std::option::Option::None;
        self.randomize_dst_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrefixTransportParams {
        static instance: PrefixTransportParams = PrefixTransportParams {
            prefix_id: ::std::option::Option::None,
            prefix: ::std::option::Option::None,
            custom_flush_policy: ::std::option::Option::None,
            randomize_dst_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrefixTransportParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrefixTransportParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrefixTransportParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrefixTransportParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.GenericTransportParams)
pub struct GenericTransportParams {
    // message fields
    ///  Indicates whether the client has elected to use destination port randomization. Should be
    ///  checked against selected transport to ensure that destination port randomization is
    ///  supported.
    // @@protoc_insertion_point(field:proto.GenericTransportParams.randomize_dst_port)
    pub randomize_dst_port: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.GenericTransportParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericTransportParams {
    fn default() -> &'a GenericTransportParams {
        <GenericTransportParams as ::protobuf::Message>::default_instance()
    }
}

impl GenericTransportParams {
    pub fn new() -> GenericTransportParams {
        ::std::default::Default::default()
    }

    // optional bool randomize_dst_port = 13;

    pub fn randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.unwrap_or(false)
    }

    pub fn clear_randomize_dst_port(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
    }

    pub fn has_randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomize_dst_port(&mut self, v: bool) {
        self.randomize_dst_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "randomize_dst_port",
            |m: &GenericTransportParams| { &m.randomize_dst_port },
            |m: &mut GenericTransportParams| { &mut m.randomize_dst_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericTransportParams>(
            "GenericTransportParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericTransportParams {
    const NAME: &'static str = "GenericTransportParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                104 => {
                    self.randomize_dst_port = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.randomize_dst_port {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.randomize_dst_port {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericTransportParams {
        GenericTransportParams::new()
    }

    fn clear(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericTransportParams {
        static instance: GenericTransportParams = GenericTransportParams {
            randomize_dst_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericTransportParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericTransportParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericTransportParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericTransportParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.C2SWrapper)
pub struct C2SWrapper {
    // message fields
    // @@protoc_insertion_point(field:proto.C2SWrapper.shared_secret)
    pub shared_secret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.C2SWrapper.registration_payload)
    pub registration_payload: ::protobuf::MessageField<ClientToStation>,
    // @@protoc_insertion_point(field:proto.C2SWrapper.registration_source)
    pub registration_source: ::std::option::Option<::protobuf::EnumOrUnknown<RegistrationSource>>,
    ///  client source address when receiving a registration
    // @@protoc_insertion_point(field:proto.C2SWrapper.registration_address)
    pub registration_address: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  Decoy address used when registering over Decoy registrar
    // @@protoc_insertion_point(field:proto.C2SWrapper.decoy_address)
    pub decoy_address: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  The next three fields allow an independent registrar (trusted by a station w/ a zmq keypair) to
    ///  share the registration overrides that it assigned to the client with the station(s).
    ///  Registration Respose is here to allow a parsed object with direct access to the fields within.
    ///  RegRespBytes provides a serialized verion of the Registration response so that the signature of
    ///  the Bidirectional registrar can be validated before a station applies any overrides present in
    ///  the Registration Response.
    ///
    ///  If you are reading this in the future and you want to extend the functionality here it might
    ///  make sense to make the RegistrationResponse that is sent to the client a distinct message from
    ///  the one that gets sent to the stations.
    // @@protoc_insertion_point(field:proto.C2SWrapper.registration_response)
    pub registration_response: ::protobuf::MessageField<RegistrationResponse>,
    // @@protoc_insertion_point(field:proto.C2SWrapper.RegRespBytes)
    pub RegRespBytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.C2SWrapper.RegRespSignature)
    pub RegRespSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.C2SWrapper.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a C2SWrapper {
    fn default() -> &'a C2SWrapper {
        <C2SWrapper as ::protobuf::Message>::default_instance()
    }
}

impl C2SWrapper {
    pub fn new() -> C2SWrapper {
        ::std::default::Default::default()
    }

    // optional bytes shared_secret = 1;

    pub fn shared_secret(&self) -> &[u8] {
        match self.shared_secret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_shared_secret(&mut self) {
        self.shared_secret = ::std::option::Option::None;
    }

    pub fn has_shared_secret(&self) -> bool {
        self.shared_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.shared_secret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shared_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.shared_secret.is_none() {
            self.shared_secret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.shared_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_shared_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.shared_secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .proto.RegistrationSource registration_source = 4;

    pub fn registration_source(&self) -> RegistrationSource {
        match self.registration_source {
            Some(e) => e.enum_value_or(RegistrationSource::Unspecified),
            None => RegistrationSource::Unspecified,
        }
    }

    pub fn clear_registration_source(&mut self) {
        self.registration_source = ::std::option::Option::None;
    }

    pub fn has_registration_source(&self) -> bool {
        self.registration_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_source(&mut self, v: RegistrationSource) {
        self.registration_source = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes registration_address = 6;

    pub fn registration_address(&self) -> &[u8] {
        match self.registration_address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_registration_address(&mut self) {
        self.registration_address = ::std::option::Option::None;
    }

    pub fn has_registration_address(&self) -> bool {
        self.registration_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.registration_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.registration_address.is_none() {
            self.registration_address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.registration_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_address(&mut self) -> ::std::vec::Vec<u8> {
        self.registration_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes decoy_address = 7;

    pub fn decoy_address(&self) -> &[u8] {
        match self.decoy_address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_decoy_address(&mut self) {
        self.decoy_address = ::std::option::Option::None;
    }

    pub fn has_decoy_address(&self) -> bool {
        self.decoy_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.decoy_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoy_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.decoy_address.is_none() {
            self.decoy_address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.decoy_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_decoy_address(&mut self) -> ::std::vec::Vec<u8> {
        self.decoy_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes RegRespBytes = 9;

    pub fn RegRespBytes(&self) -> &[u8] {
        match self.RegRespBytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_RegRespBytes(&mut self) {
        self.RegRespBytes = ::std::option::Option::None;
    }

    pub fn has_RegRespBytes(&self) -> bool {
        self.RegRespBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RegRespBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.RegRespBytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RegRespBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.RegRespBytes.is_none() {
            self.RegRespBytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.RegRespBytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_RegRespBytes(&mut self) -> ::std::vec::Vec<u8> {
        self.RegRespBytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes RegRespSignature = 10;

    pub fn RegRespSignature(&self) -> &[u8] {
        match self.RegRespSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_RegRespSignature(&mut self) {
        self.RegRespSignature = ::std::option::Option::None;
    }

    pub fn has_RegRespSignature(&self) -> bool {
        self.RegRespSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RegRespSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.RegRespSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RegRespSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.RegRespSignature.is_none() {
            self.RegRespSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.RegRespSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_RegRespSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.RegRespSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shared_secret",
            |m: &C2SWrapper| { &m.shared_secret },
            |m: &mut C2SWrapper| { &mut m.shared_secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientToStation>(
            "registration_payload",
            |m: &C2SWrapper| { &m.registration_payload },
            |m: &mut C2SWrapper| { &mut m.registration_payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registration_source",
            |m: &C2SWrapper| { &m.registration_source },
            |m: &mut C2SWrapper| { &mut m.registration_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registration_address",
            |m: &C2SWrapper| { &m.registration_address },
            |m: &mut C2SWrapper| { &mut m.registration_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decoy_address",
            |m: &C2SWrapper| { &m.decoy_address },
            |m: &mut C2SWrapper| { &mut m.decoy_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RegistrationResponse>(
            "registration_response",
            |m: &C2SWrapper| { &m.registration_response },
            |m: &mut C2SWrapper| { &mut m.registration_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "RegRespBytes",
            |m: &C2SWrapper| { &m.RegRespBytes },
            |m: &mut C2SWrapper| { &mut m.RegRespBytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "RegRespSignature",
            |m: &C2SWrapper| { &m.RegRespSignature },
            |m: &mut C2SWrapper| { &mut m.RegRespSignature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<C2SWrapper>(
            "C2SWrapper",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for C2SWrapper {
    const NAME: &'static str = "C2SWrapper";

    fn is_initialized(&self) -> bool {
        for v in &self.registration_payload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.registration_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shared_secret = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.registration_payload)?;
                },
                32 => {
                    self.registration_source = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.registration_address = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.decoy_address = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.registration_response)?;
                },
                74 => {
                    self.RegRespBytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                82 => {
                    self.RegRespSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shared_secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.registration_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.registration_source {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.registration_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.decoy_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.registration_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.RegRespBytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.RegRespSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shared_secret.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.registration_payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.registration_source {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.registration_address.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.decoy_address.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.registration_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.RegRespBytes.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.RegRespSignature.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> C2SWrapper {
        C2SWrapper::new()
    }

    fn clear(&mut self) {
        self.shared_secret = ::std::option::Option::None;
        self.registration_payload.clear();
        self.registration_source = ::std::option::Option::None;
        self.registration_address = ::std::option::Option::None;
        self.decoy_address = ::std::option::Option::None;
        self.registration_response.clear();
        self.RegRespBytes = ::std::option::Option::None;
        self.RegRespSignature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static C2SWrapper {
        static instance: C2SWrapper = C2SWrapper {
            shared_secret: ::std::option::Option::None,
            registration_payload: ::protobuf::MessageField::none(),
            registration_source: ::std::option::Option::None,
            registration_address: ::std::option::Option::None,
            decoy_address: ::std::option::Option::None,
            registration_response: ::protobuf::MessageField::none(),
            RegRespBytes: ::std::option::Option::None,
            RegRespSignature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for C2SWrapper {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("C2SWrapper").unwrap()).clone()
    }
}

impl ::std::fmt::Display for C2SWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for C2SWrapper {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SessionStats)
pub struct SessionStats {
    // message fields
    // @@protoc_insertion_point(field:proto.SessionStats.failed_decoys_amount)
    pub failed_decoys_amount: ::std::option::Option<u32>,
    ///  Applicable to whole session:
    // @@protoc_insertion_point(field:proto.SessionStats.total_time_to_connect)
    pub total_time_to_connect: ::std::option::Option<u32>,
    ///  Last (i.e. successful) decoy:
    // @@protoc_insertion_point(field:proto.SessionStats.rtt_to_station)
    pub rtt_to_station: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.SessionStats.tls_to_decoy)
    pub tls_to_decoy: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.SessionStats.tcp_to_decoy)
    pub tcp_to_decoy: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SessionStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SessionStats {
    fn default() -> &'a SessionStats {
        <SessionStats as ::protobuf::Message>::default_instance()
    }
}

impl SessionStats {
    pub fn new() -> SessionStats {
        ::std::default::Default::default()
    }

    // optional uint32 failed_decoys_amount = 20;

    pub fn failed_decoys_amount(&self) -> u32 {
        self.failed_decoys_amount.unwrap_or(0)
    }

    pub fn clear_failed_decoys_amount(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
    }

    pub fn has_failed_decoys_amount(&self) -> bool {
        self.failed_decoys_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_decoys_amount(&mut self, v: u32) {
        self.failed_decoys_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 total_time_to_connect = 31;

    pub fn total_time_to_connect(&self) -> u32 {
        self.total_time_to_connect.unwrap_or(0)
    }

    pub fn clear_total_time_to_connect(&mut self) {
        self.total_time_to_connect = ::std::option::Option::None;
    }

    pub fn has_total_time_to_connect(&self) -> bool {
        self.total_time_to_connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_time_to_connect(&mut self, v: u32) {
        self.total_time_to_connect = ::std::option::Option::Some(v);
    }

    // optional uint32 rtt_to_station = 33;

    pub fn rtt_to_station(&self) -> u32 {
        self.rtt_to_station.unwrap_or(0)
    }

    pub fn clear_rtt_to_station(&mut self) {
        self.rtt_to_station = ::std::option::Option::None;
    }

    pub fn has_rtt_to_station(&self) -> bool {
        self.rtt_to_station.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtt_to_station(&mut self, v: u32) {
        self.rtt_to_station = ::std::option::Option::Some(v);
    }

    // optional uint32 tls_to_decoy = 38;

    pub fn tls_to_decoy(&self) -> u32 {
        self.tls_to_decoy.unwrap_or(0)
    }

    pub fn clear_tls_to_decoy(&mut self) {
        self.tls_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tls_to_decoy(&self) -> bool {
        self.tls_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls_to_decoy(&mut self, v: u32) {
        self.tls_to_decoy = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_to_decoy = 39;

    pub fn tcp_to_decoy(&self) -> u32 {
        self.tcp_to_decoy.unwrap_or(0)
    }

    pub fn clear_tcp_to_decoy(&mut self) {
        self.tcp_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tcp_to_decoy(&self) -> bool {
        self.tcp_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_to_decoy(&mut self, v: u32) {
        self.tcp_to_decoy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failed_decoys_amount",
            |m: &SessionStats| { &m.failed_decoys_amount },
            |m: &mut SessionStats| { &mut m.failed_decoys_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_time_to_connect",
            |m: &SessionStats| { &m.total_time_to_connect },
            |m: &mut SessionStats| { &mut m.total_time_to_connect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtt_to_station",
            |m: &SessionStats| { &m.rtt_to_station },
            |m: &mut SessionStats| { &mut m.rtt_to_station },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tls_to_decoy",
            |m: &SessionStats| { &m.tls_to_decoy },
            |m: &mut SessionStats| { &mut m.tls_to_decoy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_to_decoy",
            |m: &SessionStats| { &m.tcp_to_decoy },
            |m: &mut SessionStats| { &mut m.tcp_to_decoy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionStats>(
            "SessionStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SessionStats {
    const NAME: &'static str = "SessionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                160 => {
                    self.failed_decoys_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.total_time_to_connect = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.rtt_to_station = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.tls_to_decoy = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.tcp_to_decoy = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.failed_decoys_amount {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.total_time_to_connect {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.rtt_to_station {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.tls_to_decoy {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.tcp_to_decoy {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.failed_decoys_amount {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.total_time_to_connect {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.rtt_to_station {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.tls_to_decoy {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.tcp_to_decoy {
            os.write_uint32(39, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SessionStats {
        SessionStats::new()
    }

    fn clear(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
        self.total_time_to_connect = ::std::option::Option::None;
        self.rtt_to_station = ::std::option::Option::None;
        self.tls_to_decoy = ::std::option::Option::None;
        self.tcp_to_decoy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SessionStats {
        static instance: SessionStats = SessionStats {
            failed_decoys_amount: ::std::option::Option::None,
            total_time_to_connect: ::std::option::Option::None,
            rtt_to_station: ::std::option::Option::None,
            tls_to_decoy: ::std::option::Option::None,
            tcp_to_decoy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SessionStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SessionStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StationToDetector)
pub struct StationToDetector {
    // message fields
    // @@protoc_insertion_point(field:proto.StationToDetector.phantom_ip)
    pub phantom_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StationToDetector.client_ip)
    pub client_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StationToDetector.timeout_ns)
    pub timeout_ns: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.StationToDetector.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<StationOperations>>,
    // @@protoc_insertion_point(field:proto.StationToDetector.dst_port)
    pub dst_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StationToDetector.src_port)
    pub src_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StationToDetector.proto)
    pub proto: ::std::option::Option<::protobuf::EnumOrUnknown<IPProto>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StationToDetector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StationToDetector {
    fn default() -> &'a StationToDetector {
        <StationToDetector as ::protobuf::Message>::default_instance()
    }
}

impl StationToDetector {
    pub fn new() -> StationToDetector {
        ::std::default::Default::default()
    }

    // optional string phantom_ip = 1;

    pub fn phantom_ip(&self) -> &str {
        match self.phantom_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phantom_ip(&mut self) {
        self.phantom_ip = ::std::option::Option::None;
    }

    pub fn has_phantom_ip(&self) -> bool {
        self.phantom_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phantom_ip(&mut self, v: ::std::string::String) {
        self.phantom_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phantom_ip(&mut self) -> &mut ::std::string::String {
        if self.phantom_ip.is_none() {
            self.phantom_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phantom_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_phantom_ip(&mut self) -> ::std::string::String {
        self.phantom_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string client_ip = 2;

    pub fn client_ip(&self) -> &str {
        match self.client_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_client_ip(&mut self) {
        self.client_ip = ::std::option::Option::None;
    }

    pub fn has_client_ip(&self) -> bool {
        self.client_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_ip(&mut self, v: ::std::string::String) {
        self.client_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_ip(&mut self) -> &mut ::std::string::String {
        if self.client_ip.is_none() {
            self.client_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.client_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_ip(&mut self) -> ::std::string::String {
        self.client_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timeout_ns = 3;

    pub fn timeout_ns(&self) -> u64 {
        self.timeout_ns.unwrap_or(0)
    }

    pub fn clear_timeout_ns(&mut self) {
        self.timeout_ns = ::std::option::Option::None;
    }

    pub fn has_timeout_ns(&self) -> bool {
        self.timeout_ns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ns(&mut self, v: u64) {
        self.timeout_ns = ::std::option::Option::Some(v);
    }

    // optional .proto.StationOperations operation = 4;

    pub fn operation(&self) -> StationOperations {
        match self.operation {
            Some(e) => e.enum_value_or(StationOperations::Unknown),
            None => StationOperations::Unknown,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: StationOperations) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 dst_port = 10;

    pub fn dst_port(&self) -> u32 {
        self.dst_port.unwrap_or(0)
    }

    pub fn clear_dst_port(&mut self) {
        self.dst_port = ::std::option::Option::None;
    }

    pub fn has_dst_port(&self) -> bool {
        self.dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_port(&mut self, v: u32) {
        self.dst_port = ::std::option::Option::Some(v);
    }

    // optional uint32 src_port = 11;

    pub fn src_port(&self) -> u32 {
        self.src_port.unwrap_or(0)
    }

    pub fn clear_src_port(&mut self) {
        self.src_port = ::std::option::Option::None;
    }

    pub fn has_src_port(&self) -> bool {
        self.src_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_port(&mut self, v: u32) {
        self.src_port = ::std::option::Option::Some(v);
    }

    // optional .proto.IPProto proto = 12;

    pub fn proto(&self) -> IPProto {
        match self.proto {
            Some(e) => e.enum_value_or(IPProto::Unk),
            None => IPProto::Unk,
        }
    }

    pub fn clear_proto(&mut self) {
        self.proto = ::std::option::Option::None;
    }

    pub fn has_proto(&self) -> bool {
        self.proto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proto(&mut self, v: IPProto) {
        self.proto = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phantom_ip",
            |m: &StationToDetector| { &m.phantom_ip },
            |m: &mut StationToDetector| { &mut m.phantom_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_ip",
            |m: &StationToDetector| { &m.client_ip },
            |m: &mut StationToDetector| { &mut m.client_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout_ns",
            |m: &StationToDetector| { &m.timeout_ns },
            |m: &mut StationToDetector| { &mut m.timeout_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &StationToDetector| { &m.operation },
            |m: &mut StationToDetector| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_port",
            |m: &StationToDetector| { &m.dst_port },
            |m: &mut StationToDetector| { &mut m.dst_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "src_port",
            |m: &StationToDetector| { &m.src_port },
            |m: &mut StationToDetector| { &mut m.src_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proto",
            |m: &StationToDetector| { &m.proto },
            |m: &mut StationToDetector| { &mut m.proto },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StationToDetector>(
            "StationToDetector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StationToDetector {
    const NAME: &'static str = "StationToDetector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phantom_ip = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.client_ip = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.timeout_ns = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.dst_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.src_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.proto = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phantom_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.client_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timeout_ns {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.dst_port {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.src_port {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.proto {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phantom_ip.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.client_ip.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.timeout_ns {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.operation {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.dst_port {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.src_port {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.proto {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StationToDetector {
        StationToDetector::new()
    }

    fn clear(&mut self) {
        self.phantom_ip = ::std::option::Option::None;
        self.client_ip = ::std::option::Option::None;
        self.timeout_ns = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.dst_port = ::std::option::Option::None;
        self.src_port = ::std::option::Option::None;
        self.proto = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StationToDetector {
        static instance: StationToDetector = StationToDetector {
            phantom_ip: ::std::option::Option::None,
            client_ip: ::std::option::Option::None,
            timeout_ns: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            dst_port: ::std::option::Option::None,
            src_port: ::std::option::Option::None,
            proto: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StationToDetector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StationToDetector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StationToDetector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToDetector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Adding message response from Station to Client for bidirectional API
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.RegistrationResponse)
pub struct RegistrationResponse {
    // message fields
    // @@protoc_insertion_point(field:proto.RegistrationResponse.ipv4addr)
    pub ipv4addr: ::std::option::Option<u32>,
    ///  The 128-bit ipv6 address, in network byte order
    // @@protoc_insertion_point(field:proto.RegistrationResponse.ipv6addr)
    pub ipv6addr: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  Respond with randomized port
    // @@protoc_insertion_point(field:proto.RegistrationResponse.dst_port)
    pub dst_port: ::std::option::Option<u32>,
    ///  Future: station provides client with secret, want chanel present
    ///  Leave null for now
    // @@protoc_insertion_point(field:proto.RegistrationResponse.serverRandom)
    pub serverRandom: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  If registration wrong, populate this error string
    // @@protoc_insertion_point(field:proto.RegistrationResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    ///  ClientConf field (optional)
    // @@protoc_insertion_point(field:proto.RegistrationResponse.clientConf)
    pub clientConf: ::protobuf::MessageField<ClientConf>,
    ///  Transport Params to if `allow_registrar_overrides` is set.
    // @@protoc_insertion_point(field:proto.RegistrationResponse.transport_params)
    pub transport_params: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  PhantomsSupportPortRand is a flag that indicates whether the selected phantoms are able to
    ///  handle phantom connections to randomized ports.
    // @@protoc_insertion_point(field:proto.RegistrationResponse.phantoms_support_port_rand)
    pub phantoms_support_port_rand: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.RegistrationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegistrationResponse {
    fn default() -> &'a RegistrationResponse {
        <RegistrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationResponse {
    pub fn new() -> RegistrationResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ipv4addr = 1;

    pub fn ipv4addr(&self) -> u32 {
        self.ipv4addr.unwrap_or(0)
    }

    pub fn clear_ipv4addr(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
    }

    pub fn has_ipv4addr(&self) -> bool {
        self.ipv4addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4addr(&mut self, v: u32) {
        self.ipv4addr = ::std::option::Option::Some(v);
    }

    // optional bytes ipv6addr = 2;

    pub fn ipv6addr(&self) -> &[u8] {
        match self.ipv6addr.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ipv6addr(&mut self) {
        self.ipv6addr = ::std::option::Option::None;
    }

    pub fn has_ipv6addr(&self) -> bool {
        self.ipv6addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ipv6addr.is_none() {
            self.ipv6addr = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ipv6addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6addr(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6addr.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 dst_port = 3;

    pub fn dst_port(&self) -> u32 {
        self.dst_port.unwrap_or(0)
    }

    pub fn clear_dst_port(&mut self) {
        self.dst_port = ::std::option::Option::None;
    }

    pub fn has_dst_port(&self) -> bool {
        self.dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_port(&mut self, v: u32) {
        self.dst_port = ::std::option::Option::Some(v);
    }

    // optional bytes serverRandom = 4;

    pub fn serverRandom(&self) -> &[u8] {
        match self.serverRandom.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serverRandom(&mut self) {
        self.serverRandom = ::std::option::Option::None;
    }

    pub fn has_serverRandom(&self) -> bool {
        self.serverRandom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverRandom(&mut self, v: ::std::vec::Vec<u8>) {
        self.serverRandom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverRandom(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serverRandom.is_none() {
            self.serverRandom = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serverRandom.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverRandom(&mut self) -> ::std::vec::Vec<u8> {
        self.serverRandom.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string error = 5;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool phantoms_support_port_rand = 11;

    pub fn phantoms_support_port_rand(&self) -> bool {
        self.phantoms_support_port_rand.unwrap_or(false)
    }

    pub fn clear_phantoms_support_port_rand(&mut self) {
        self.phantoms_support_port_rand = ::std::option::Option::None;
    }

    pub fn has_phantoms_support_port_rand(&self) -> bool {
        self.phantoms_support_port_rand.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phantoms_support_port_rand(&mut self, v: bool) {
        self.phantoms_support_port_rand = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv4addr",
            |m: &RegistrationResponse| { &m.ipv4addr },
            |m: &mut RegistrationResponse| { &mut m.ipv4addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv6addr",
            |m: &RegistrationResponse| { &m.ipv6addr },
            |m: &mut RegistrationResponse| { &mut m.ipv6addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_port",
            |m: &RegistrationResponse| { &m.dst_port },
            |m: &mut RegistrationResponse| { &mut m.dst_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverRandom",
            |m: &RegistrationResponse| { &m.serverRandom },
            |m: &mut RegistrationResponse| { &mut m.serverRandom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &RegistrationResponse| { &m.error },
            |m: &mut RegistrationResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientConf>(
            "clientConf",
            |m: &RegistrationResponse| { &m.clientConf },
            |m: &mut RegistrationResponse| { &mut m.clientConf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "transport_params",
            |m: &RegistrationResponse| { &m.transport_params },
            |m: &mut RegistrationResponse| { &mut m.transport_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phantoms_support_port_rand",
            |m: &RegistrationResponse| { &m.phantoms_support_port_rand },
            |m: &mut RegistrationResponse| { &mut m.phantoms_support_port_rand },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegistrationResponse>(
            "RegistrationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegistrationResponse {
    const NAME: &'static str = "RegistrationResponse";

    fn is_initialized(&self) -> bool {
        for v in &self.clientConf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ipv4addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.ipv6addr = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.dst_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.serverRandom = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientConf)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transport_params)?;
                },
                88 => {
                    self.phantoms_support_port_rand = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ipv4addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.dst_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.serverRandom.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.clientConf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transport_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.phantoms_support_port_rand {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ipv4addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.dst_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.serverRandom.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.clientConf.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.transport_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.phantoms_support_port_rand {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegistrationResponse {
        RegistrationResponse::new()
    }

    fn clear(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
        self.ipv6addr = ::std::option::Option::None;
        self.dst_port = ::std::option::Option::None;
        self.serverRandom = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.clientConf.clear();
        self.transport_params.clear();
        self.phantoms_support_port_rand = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegistrationResponse {
        static instance: RegistrationResponse = RegistrationResponse {
            ipv4addr: ::std::option::Option::None,
            ipv6addr: ::std::option::Option::None,
            dst_port: ::std::option::Option::None,
            serverRandom: ::std::option::Option::None,
            error: ::std::option::Option::None,
            clientConf: ::protobuf::MessageField::none(),
            transport_params: ::protobuf::MessageField::none(),
            phantoms_support_port_rand: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegistrationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegistrationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegistrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  response from dns
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DnsResponse)
pub struct DnsResponse {
    // message fields
    // @@protoc_insertion_point(field:proto.DnsResponse.success)
    pub success: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.DnsResponse.clientconf_outdated)
    pub clientconf_outdated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.DnsResponse.bidirectional_response)
    pub bidirectional_response: ::protobuf::MessageField<RegistrationResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DnsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DnsResponse {
    fn default() -> &'a DnsResponse {
        <DnsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DnsResponse {
    pub fn new() -> DnsResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional bool clientconf_outdated = 2;

    pub fn clientconf_outdated(&self) -> bool {
        self.clientconf_outdated.unwrap_or(false)
    }

    pub fn clear_clientconf_outdated(&mut self) {
        self.clientconf_outdated = ::std::option::Option::None;
    }

    pub fn has_clientconf_outdated(&self) -> bool {
        self.clientconf_outdated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientconf_outdated(&mut self, v: bool) {
        self.clientconf_outdated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &DnsResponse| { &m.success },
            |m: &mut DnsResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientconf_outdated",
            |m: &DnsResponse| { &m.clientconf_outdated },
            |m: &mut DnsResponse| { &mut m.clientconf_outdated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RegistrationResponse>(
            "bidirectional_response",
            |m: &DnsResponse| { &m.bidirectional_response },
            |m: &mut DnsResponse| { &mut m.bidirectional_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DnsResponse>(
            "DnsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DnsResponse {
    const NAME: &'static str = "DnsResponse";

    fn is_initialized(&self) -> bool {
        for v in &self.bidirectional_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.clientconf_outdated = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bidirectional_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        if let Some(v) = self.clientconf_outdated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bidirectional_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.clientconf_outdated {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bidirectional_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DnsResponse {
        DnsResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.clientconf_outdated = ::std::option::Option::None;
        self.bidirectional_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DnsResponse {
        static instance: DnsResponse = DnsResponse {
            success: ::std::option::Option::None,
            clientconf_outdated: ::std::option::Option::None,
            bidirectional_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DnsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DnsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DnsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.KeyType)
pub enum KeyType {
    // @@protoc_insertion_point(enum_value:proto.KeyType.AES_GCM_128)
    AES_GCM_128 = 90,
    // @@protoc_insertion_point(enum_value:proto.KeyType.AES_GCM_256)
    AES_GCM_256 = 91,
}

impl ::protobuf::Enum for KeyType {
    const NAME: &'static str = "KeyType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyType> {
        match value {
            90 => ::std::option::Option::Some(KeyType::AES_GCM_128),
            91 => ::std::option::Option::Some(KeyType::AES_GCM_256),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeyType] = &[
        KeyType::AES_GCM_128,
        KeyType::AES_GCM_256,
    ];
}

impl ::protobuf::EnumFull for KeyType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeyType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            KeyType::AES_GCM_128 => 0,
            KeyType::AES_GCM_256 => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for KeyType {
    fn default() -> Self {
        KeyType::AES_GCM_128
    }
}

impl KeyType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeyType>("KeyType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.DnsRegMethod)
pub enum DnsRegMethod {
    // @@protoc_insertion_point(enum_value:proto.DnsRegMethod.UDP)
    UDP = 1,
    // @@protoc_insertion_point(enum_value:proto.DnsRegMethod.DOT)
    DOT = 2,
    // @@protoc_insertion_point(enum_value:proto.DnsRegMethod.DOH)
    DOH = 3,
}

impl ::protobuf::Enum for DnsRegMethod {
    const NAME: &'static str = "DnsRegMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DnsRegMethod> {
        match value {
            1 => ::std::option::Option::Some(DnsRegMethod::UDP),
            2 => ::std::option::Option::Some(DnsRegMethod::DOT),
            3 => ::std::option::Option::Some(DnsRegMethod::DOH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DnsRegMethod] = &[
        DnsRegMethod::UDP,
        DnsRegMethod::DOT,
        DnsRegMethod::DOH,
    ];
}

impl ::protobuf::EnumFull for DnsRegMethod {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DnsRegMethod").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DnsRegMethod::UDP => 0,
            DnsRegMethod::DOT => 1,
            DnsRegMethod::DOH => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DnsRegMethod {
    fn default() -> Self {
        DnsRegMethod::UDP
    }
}

impl DnsRegMethod {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DnsRegMethod>("DnsRegMethod")
    }
}

///  State transitions of the client
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.C2S_Transition)
pub enum C2S_Transition {
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_NO_CHANGE)
    C2S_NO_CHANGE = 0,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_SESSION_INIT)
    C2S_SESSION_INIT = 1,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_SESSION_COVERT_INIT)
    C2S_SESSION_COVERT_INIT = 11,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_EXPECT_RECONNECT)
    C2S_EXPECT_RECONNECT = 2,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_SESSION_CLOSE)
    C2S_SESSION_CLOSE = 3,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_YIELD_UPLOAD)
    C2S_YIELD_UPLOAD = 4,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_ACQUIRE_UPLOAD)
    C2S_ACQUIRE_UPLOAD = 5,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_EXPECT_UPLOADONLY_RECONN)
    C2S_EXPECT_UPLOADONLY_RECONN = 6,
    // @@protoc_insertion_point(enum_value:proto.C2S_Transition.C2S_ERROR)
    C2S_ERROR = 255,
}

impl ::protobuf::Enum for C2S_Transition {
    const NAME: &'static str = "C2S_Transition";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<C2S_Transition> {
        match value {
            0 => ::std::option::Option::Some(C2S_Transition::C2S_NO_CHANGE),
            1 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_INIT),
            11 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_RECONNECT),
            3 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_CLOSE),
            4 => ::std::option::Option::Some(C2S_Transition::C2S_YIELD_UPLOAD),
            5 => ::std::option::Option::Some(C2S_Transition::C2S_ACQUIRE_UPLOAD),
            6 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN),
            255 => ::std::option::Option::Some(C2S_Transition::C2S_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [C2S_Transition] = &[
        C2S_Transition::C2S_NO_CHANGE,
        C2S_Transition::C2S_SESSION_INIT,
        C2S_Transition::C2S_SESSION_COVERT_INIT,
        C2S_Transition::C2S_EXPECT_RECONNECT,
        C2S_Transition::C2S_SESSION_CLOSE,
        C2S_Transition::C2S_YIELD_UPLOAD,
        C2S_Transition::C2S_ACQUIRE_UPLOAD,
        C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN,
        C2S_Transition::C2S_ERROR,
    ];
}

impl ::protobuf::EnumFull for C2S_Transition {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("C2S_Transition").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            C2S_Transition::C2S_NO_CHANGE => 0,
            C2S_Transition::C2S_SESSION_INIT => 1,
            C2S_Transition::C2S_SESSION_COVERT_INIT => 2,
            C2S_Transition::C2S_EXPECT_RECONNECT => 3,
            C2S_Transition::C2S_SESSION_CLOSE => 4,
            C2S_Transition::C2S_YIELD_UPLOAD => 5,
            C2S_Transition::C2S_ACQUIRE_UPLOAD => 6,
            C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN => 7,
            C2S_Transition::C2S_ERROR => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for C2S_Transition {
    fn default() -> Self {
        C2S_Transition::C2S_NO_CHANGE
    }
}

impl C2S_Transition {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<C2S_Transition>("C2S_Transition")
    }
}

///  State transitions of the server
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.S2C_Transition)
pub enum S2C_Transition {
    // @@protoc_insertion_point(enum_value:proto.S2C_Transition.S2C_NO_CHANGE)
    S2C_NO_CHANGE = 0,
    // @@protoc_insertion_point(enum_value:proto.S2C_Transition.S2C_SESSION_INIT)
    S2C_SESSION_INIT = 1,
    // @@protoc_insertion_point(enum_value:proto.S2C_Transition.S2C_SESSION_COVERT_INIT)
    S2C_SESSION_COVERT_INIT = 11,
    // @@protoc_insertion_point(enum_value:proto.S2C_Transition.S2C_CONFIRM_RECONNECT)
    S2C_CONFIRM_RECONNECT = 2,
    // @@protoc_insertion_point(enum_value:proto.S2C_Transition.S2C_SESSION_CLOSE)
    S2C_SESSION_CLOSE = 3,
    // @@protoc_insertion_point(enum_value:proto.S2C_Transition.S2C_ERROR)
    S2C_ERROR = 255,
}

impl ::protobuf::Enum for S2C_Transition {
    const NAME: &'static str = "S2C_Transition";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<S2C_Transition> {
        match value {
            0 => ::std::option::Option::Some(S2C_Transition::S2C_NO_CHANGE),
            1 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_INIT),
            11 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(S2C_Transition::S2C_CONFIRM_RECONNECT),
            3 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_CLOSE),
            255 => ::std::option::Option::Some(S2C_Transition::S2C_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [S2C_Transition] = &[
        S2C_Transition::S2C_NO_CHANGE,
        S2C_Transition::S2C_SESSION_INIT,
        S2C_Transition::S2C_SESSION_COVERT_INIT,
        S2C_Transition::S2C_CONFIRM_RECONNECT,
        S2C_Transition::S2C_SESSION_CLOSE,
        S2C_Transition::S2C_ERROR,
    ];
}

impl ::protobuf::EnumFull for S2C_Transition {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("S2C_Transition").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            S2C_Transition::S2C_NO_CHANGE => 0,
            S2C_Transition::S2C_SESSION_INIT => 1,
            S2C_Transition::S2C_SESSION_COVERT_INIT => 2,
            S2C_Transition::S2C_CONFIRM_RECONNECT => 3,
            S2C_Transition::S2C_SESSION_CLOSE => 4,
            S2C_Transition::S2C_ERROR => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for S2C_Transition {
    fn default() -> Self {
        S2C_Transition::S2C_NO_CHANGE
    }
}

impl S2C_Transition {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<S2C_Transition>("S2C_Transition")
    }
}

///  Should accompany all S2C_ERROR messages.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.ErrorReasonS2C)
pub enum ErrorReasonS2C {
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.NO_ERROR)
    NO_ERROR = 0,
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.COVERT_STREAM)
    COVERT_STREAM = 1,
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.CLIENT_REPORTED)
    CLIENT_REPORTED = 2,
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.CLIENT_PROTOCOL)
    CLIENT_PROTOCOL = 3,
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.STATION_INTERNAL)
    STATION_INTERNAL = 4,
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.DECOY_OVERLOAD)
    DECOY_OVERLOAD = 5,
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.CLIENT_STREAM)
    CLIENT_STREAM = 100,
    // @@protoc_insertion_point(enum_value:proto.ErrorReasonS2C.CLIENT_TIMEOUT)
    CLIENT_TIMEOUT = 101,
}

impl ::protobuf::Enum for ErrorReasonS2C {
    const NAME: &'static str = "ErrorReasonS2C";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorReasonS2C> {
        match value {
            0 => ::std::option::Option::Some(ErrorReasonS2C::NO_ERROR),
            1 => ::std::option::Option::Some(ErrorReasonS2C::COVERT_STREAM),
            2 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_REPORTED),
            3 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_PROTOCOL),
            4 => ::std::option::Option::Some(ErrorReasonS2C::STATION_INTERNAL),
            5 => ::std::option::Option::Some(ErrorReasonS2C::DECOY_OVERLOAD),
            100 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_STREAM),
            101 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ErrorReasonS2C] = &[
        ErrorReasonS2C::NO_ERROR,
        ErrorReasonS2C::COVERT_STREAM,
        ErrorReasonS2C::CLIENT_REPORTED,
        ErrorReasonS2C::CLIENT_PROTOCOL,
        ErrorReasonS2C::STATION_INTERNAL,
        ErrorReasonS2C::DECOY_OVERLOAD,
        ErrorReasonS2C::CLIENT_STREAM,
        ErrorReasonS2C::CLIENT_TIMEOUT,
    ];
}

impl ::protobuf::EnumFull for ErrorReasonS2C {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ErrorReasonS2C").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ErrorReasonS2C::NO_ERROR => 0,
            ErrorReasonS2C::COVERT_STREAM => 1,
            ErrorReasonS2C::CLIENT_REPORTED => 2,
            ErrorReasonS2C::CLIENT_PROTOCOL => 3,
            ErrorReasonS2C::STATION_INTERNAL => 4,
            ErrorReasonS2C::DECOY_OVERLOAD => 5,
            ErrorReasonS2C::CLIENT_STREAM => 6,
            ErrorReasonS2C::CLIENT_TIMEOUT => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ErrorReasonS2C {
    fn default() -> Self {
        ErrorReasonS2C::NO_ERROR
    }
}

impl ErrorReasonS2C {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ErrorReasonS2C>("ErrorReasonS2C")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.TransportType)
pub enum TransportType {
    // @@protoc_insertion_point(enum_value:proto.TransportType.Null)
    Null = 0,
    // @@protoc_insertion_point(enum_value:proto.TransportType.Min)
    Min = 1,
    // @@protoc_insertion_point(enum_value:proto.TransportType.Obfs4)
    Obfs4 = 2,
    // @@protoc_insertion_point(enum_value:proto.TransportType.DTLS)
    DTLS = 3,
    // @@protoc_insertion_point(enum_value:proto.TransportType.Prefix)
    Prefix = 4,
    // @@protoc_insertion_point(enum_value:proto.TransportType.uTLS)
    uTLS = 5,
    // @@protoc_insertion_point(enum_value:proto.TransportType.Format)
    Format = 6,
    // @@protoc_insertion_point(enum_value:proto.TransportType.WASM)
    WASM = 7,
    // @@protoc_insertion_point(enum_value:proto.TransportType.FTE)
    FTE = 8,
    // @@protoc_insertion_point(enum_value:proto.TransportType.Quic)
    Quic = 9,
    // @@protoc_insertion_point(enum_value:proto.TransportType.Webrtc)
    Webrtc = 99,
}

impl ::protobuf::Enum for TransportType {
    const NAME: &'static str = "TransportType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransportType> {
        match value {
            0 => ::std::option::Option::Some(TransportType::Null),
            1 => ::std::option::Option::Some(TransportType::Min),
            2 => ::std::option::Option::Some(TransportType::Obfs4),
            3 => ::std::option::Option::Some(TransportType::DTLS),
            4 => ::std::option::Option::Some(TransportType::Prefix),
            5 => ::std::option::Option::Some(TransportType::uTLS),
            6 => ::std::option::Option::Some(TransportType::Format),
            7 => ::std::option::Option::Some(TransportType::WASM),
            8 => ::std::option::Option::Some(TransportType::FTE),
            9 => ::std::option::Option::Some(TransportType::Quic),
            99 => ::std::option::Option::Some(TransportType::Webrtc),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TransportType] = &[
        TransportType::Null,
        TransportType::Min,
        TransportType::Obfs4,
        TransportType::DTLS,
        TransportType::Prefix,
        TransportType::uTLS,
        TransportType::Format,
        TransportType::WASM,
        TransportType::FTE,
        TransportType::Quic,
        TransportType::Webrtc,
    ];
}

impl ::protobuf::EnumFull for TransportType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TransportType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TransportType::Null => 0,
            TransportType::Min => 1,
            TransportType::Obfs4 => 2,
            TransportType::DTLS => 3,
            TransportType::Prefix => 4,
            TransportType::uTLS => 5,
            TransportType::Format => 6,
            TransportType::WASM => 7,
            TransportType::FTE => 8,
            TransportType::Quic => 9,
            TransportType::Webrtc => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TransportType {
    fn default() -> Self {
        TransportType::Null
    }
}

impl TransportType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransportType>("TransportType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.RegistrationSource)
pub enum RegistrationSource {
    // @@protoc_insertion_point(enum_value:proto.RegistrationSource.Unspecified)
    Unspecified = 0,
    // @@protoc_insertion_point(enum_value:proto.RegistrationSource.Detector)
    Detector = 1,
    // @@protoc_insertion_point(enum_value:proto.RegistrationSource.API)
    API = 2,
    // @@protoc_insertion_point(enum_value:proto.RegistrationSource.DetectorPrescan)
    DetectorPrescan = 3,
    // @@protoc_insertion_point(enum_value:proto.RegistrationSource.BidirectionalAPI)
    BidirectionalAPI = 4,
    // @@protoc_insertion_point(enum_value:proto.RegistrationSource.DNS)
    DNS = 5,
    // @@protoc_insertion_point(enum_value:proto.RegistrationSource.BidirectionalDNS)
    BidirectionalDNS = 6,
}

impl ::protobuf::Enum for RegistrationSource {
    const NAME: &'static str = "RegistrationSource";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RegistrationSource> {
        match value {
            0 => ::std::option::Option::Some(RegistrationSource::Unspecified),
            1 => ::std::option::Option::Some(RegistrationSource::Detector),
            2 => ::std::option::Option::Some(RegistrationSource::API),
            3 => ::std::option::Option::Some(RegistrationSource::DetectorPrescan),
            4 => ::std::option::Option::Some(RegistrationSource::BidirectionalAPI),
            5 => ::std::option::Option::Some(RegistrationSource::DNS),
            6 => ::std::option::Option::Some(RegistrationSource::BidirectionalDNS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RegistrationSource] = &[
        RegistrationSource::Unspecified,
        RegistrationSource::Detector,
        RegistrationSource::API,
        RegistrationSource::DetectorPrescan,
        RegistrationSource::BidirectionalAPI,
        RegistrationSource::DNS,
        RegistrationSource::BidirectionalDNS,
    ];
}

impl ::protobuf::EnumFull for RegistrationSource {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RegistrationSource").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RegistrationSource {
    fn default() -> Self {
        RegistrationSource::Unspecified
    }
}

impl RegistrationSource {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RegistrationSource>("RegistrationSource")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.StationOperations)
pub enum StationOperations {
    // @@protoc_insertion_point(enum_value:proto.StationOperations.Unknown)
    Unknown = 0,
    // @@protoc_insertion_point(enum_value:proto.StationOperations.New)
    New = 1,
    // @@protoc_insertion_point(enum_value:proto.StationOperations.Update)
    Update = 2,
    // @@protoc_insertion_point(enum_value:proto.StationOperations.Clear)
    Clear = 3,
}

impl ::protobuf::Enum for StationOperations {
    const NAME: &'static str = "StationOperations";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StationOperations> {
        match value {
            0 => ::std::option::Option::Some(StationOperations::Unknown),
            1 => ::std::option::Option::Some(StationOperations::New),
            2 => ::std::option::Option::Some(StationOperations::Update),
            3 => ::std::option::Option::Some(StationOperations::Clear),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [StationOperations] = &[
        StationOperations::Unknown,
        StationOperations::New,
        StationOperations::Update,
        StationOperations::Clear,
    ];
}

impl ::protobuf::EnumFull for StationOperations {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("StationOperations").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for StationOperations {
    fn default() -> Self {
        StationOperations::Unknown
    }
}

impl StationOperations {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StationOperations>("StationOperations")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.IPProto)
pub enum IPProto {
    // @@protoc_insertion_point(enum_value:proto.IPProto.Unk)
    Unk = 0,
    // @@protoc_insertion_point(enum_value:proto.IPProto.Tcp)
    Tcp = 1,
    // @@protoc_insertion_point(enum_value:proto.IPProto.Udp)
    Udp = 2,
}

impl ::protobuf::Enum for IPProto {
    const NAME: &'static str = "IPProto";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IPProto> {
        match value {
            0 => ::std::option::Option::Some(IPProto::Unk),
            1 => ::std::option::Option::Some(IPProto::Tcp),
            2 => ::std::option::Option::Some(IPProto::Udp),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [IPProto] = &[
        IPProto::Unk,
        IPProto::Tcp,
        IPProto::Udp,
    ];
}

impl ::protobuf::EnumFull for IPProto {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("IPProto").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for IPProto {
    fn default() -> Self {
        IPProto::Unk
    }
}

impl IPProto {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<IPProto>("IPProto")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10signalling.proto\x12\x05proto\x1a\x19google/protobuf/any.proto\">\
    \n\x06PubKey\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\"\n\x04ty\
    pe\x18\x02\x20\x01(\x0e2\x0e.proto.KeyTypeR\x04type\"\xbb\x01\n\x0cTLSDe\
    coySpec\x12\x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostname\x12\x1a\n\
    \x08ipv4addr\x18\x02\x20\x01(\x07R\x08ipv4addr\x12\x1a\n\x08ipv6addr\x18\
    \x06\x20\x01(\x0cR\x08ipv6addr\x12%\n\x06pubkey\x18\x03\x20\x01(\x0b2\r.\
    proto.PubKeyR\x06pubkey\x12\x18\n\x07timeout\x18\x04\x20\x01(\rR\x07time\
    out\x12\x16\n\x06tcpwin\x18\x05\x20\x01(\rR\x06tcpwin\"\xcb\x02\n\nClien\
    tConf\x12/\n\ndecoy_list\x18\x01\x20\x01(\x0b2\x10.proto.DecoyListR\tdec\
    oyList\x12\x1e\n\ngeneration\x18\x02\x20\x01(\rR\ngeneration\x124\n\x0ed\
    efault_pubkey\x18\x03\x20\x01(\x0b2\r.proto.PubKeyR\rdefaultPubkey\x12K\
    \n\x14phantom_subnets_list\x18\x04\x20\x01(\x0b2\x19.proto.PhantomSubnet\
    sListR\x12phantomSubnetsList\x124\n\x0econjure_pubkey\x18\x05\x20\x01(\
    \x0b2\r.proto.PubKeyR\rconjurePubkey\x123\n\x0cdns_reg_conf\x18\x06\x20\
    \x01(\x0b2\x11.proto.DnsRegConfR\ndnsRegConf\"\xdd\x01\n\nDnsRegConf\x12\
    9\n\x0edns_reg_method\x18\x01\x20\x02(\x0e2\x13.proto.DnsRegMethodR\x0cd\
    nsRegMethod\x12\x16\n\x06target\x18\x02\x20\x01(\tR\x06target\x12\x16\n\
    \x06domain\x18\x03\x20\x02(\tR\x06domain\x12\x16\n\x06pubkey\x18\x04\x20\
    \x01(\x0cR\x06pubkey\x12+\n\x11utls_distribution\x18\x05\x20\x01(\tR\x10\
    utlsDistribution\x12\x1f\n\x0bstun_server\x18\x06\x20\x01(\tR\nstunServe\
    r\"?\n\tDecoyList\x122\n\ntls_decoys\x18\x01\x20\x03(\x0b2\x13.proto.TLS\
    DecoySpecR\ttlsDecoys\"V\n\x12PhantomSubnetsList\x12@\n\x10weighted_subn\
    ets\x18\x01\x20\x03(\x0b2\x15.proto.PhantomSubnetsR\x0fweightedSubnets\"\
    p\n\x0ePhantomSubnets\x12\x16\n\x06weight\x18\x01\x20\x01(\rR\x06weight\
    \x12\x18\n\x07subnets\x18\x02\x20\x03(\tR\x07subnets\x12,\n\x12randomize\
    _dst_port\x18\x03\x20\x01(\x08R\x10randomizeDstPort\"o\n\x12WebRTCICECan\
    didate\x12\x19\n\x08ip_upper\x18\x01\x20\x02(\x04R\x07ipUpper\x12\x19\n\
    \x08ip_lower\x18\x02\x20\x02(\x04R\x07ipLower\x12#\n\rcomposed_info\x18\
    \x03\x20\x02(\rR\x0ccomposedInfo\"Z\n\tWebRTCSDP\x12\x12\n\x04type\x18\
    \x01\x20\x02(\rR\x04type\x129\n\ncandidates\x18\x02\x20\x03(\x0b2\x19.pr\
    oto.WebRTCICECandidateR\ncandidates\"F\n\x0cWebRTCSignal\x12\x12\n\x04se\
    ed\x18\x01\x20\x02(\tR\x04seed\x12\"\n\x03sdp\x18\x02\x20\x02(\x0b2\x10.\
    proto.WebRTCSDPR\x03sdp\"*\n\x04Addr\x12\x0e\n\x02IP\x18\x01\x20\x01(\
    \x0cR\x02IP\x12\x12\n\x04Port\x18\x02\x20\x01(\rR\x04Port\"\xb5\x01\n\
    \x13DTLSTransportParams\x12(\n\tsrc_addr4\x18\x01\x20\x01(\x0b2\x0b.prot\
    o.AddrR\x08srcAddr4\x12(\n\tsrc_addr6\x18\x02\x20\x01(\x0b2\x0b.proto.Ad\
    drR\x08srcAddr6\x12,\n\x12randomize_dst_port\x18\x03\x20\x01(\x08R\x10ra\
    ndomizeDstPort\x12\x1c\n\tunordered\x18\x04\x20\x01(\x08R\tunordered\"\
    \xc2\x02\n\x0fStationToClient\x12)\n\x10protocol_version\x18\x01\x20\x01\
    (\rR\x0fprotocolVersion\x12@\n\x10state_transition\x18\x02\x20\x01(\x0e2\
    \x15.proto.S2C_TransitionR\x0fstateTransition\x122\n\x0bconfig_info\x18\
    \x03\x20\x01(\x0b2\x11.proto.ClientConfR\nconfigInfo\x124\n\nerr_reason\
    \x18\x04\x20\x01(\x0e2\x15.proto.ErrorReasonS2CR\terrReason\x12\x1f\n\
    \x0btmp_backoff\x18\x05\x20\x01(\rR\ntmpBackoff\x12\x1d\n\nstation_id\
    \x18\x06\x20\x01(\tR\tstationId\x12\x18\n\x07padding\x18d\x20\x01(\x0cR\
    \x07padding\"\xaf\x01\n\x11RegistrationFlags\x12\x1f\n\x0bupload_only\
    \x18\x01\x20\x01(\x08R\nuploadOnly\x12\x1d\n\ndark_decoy\x18\x02\x20\x01\
    (\x08R\tdarkDecoy\x12!\n\x0cproxy_header\x18\x03\x20\x01(\x08R\x0bproxyH\
    eader\x12\x17\n\x07use_TIL\x18\x04\x20\x01(\x08R\x06useTIL\x12\x1e\n\npr\
    escanned\x18\x05\x20\x01(\x08R\nprescanned\"\xa8\x06\n\x0fClientToStatio\
    n\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\x0fprotocolVersion\x122\
    \n\x15decoy_list_generation\x18\x02\x20\x01(\rR\x13decoyListGeneration\
    \x12@\n\x10state_transition\x18\x03\x20\x01(\x0e2\x15.proto.C2S_Transiti\
    onR\x0fstateTransition\x12\x1f\n\x0bupload_sync\x18\x04\x20\x01(\x04R\nu\
    ploadSync\x12,\n\x12client_lib_version\x18\x05\x20\x01(\rR\x10clientLibV\
    ersion\x12>\n\x1bdisable_registrar_overrides\x18\x06\x20\x01(\x08R\x19di\
    sableRegistrarOverrides\x12#\n\rfailed_decoys\x18\n\x20\x03(\tR\x0cfaile\
    dDecoys\x12)\n\x05stats\x18\x0b\x20\x01(\x0b2\x13.proto.SessionStatsR\
    \x05stats\x122\n\ttransport\x18\x0c\x20\x01(\x0e2\x14.proto.TransportTyp\
    eR\ttransport\x12?\n\x10transport_params\x18\r\x20\x01(\x0b2\x14.google.\
    protobuf.AnyR\x0ftransportParams\x12%\n\x0ecovert_address\x18\x14\x20\
    \x01(\tR\rcovertAddress\x127\n\x18masked_decoy_server_name\x18\x15\x20\
    \x01(\tR\x15maskedDecoyServerName\x12\x1d\n\nv6_support\x18\x16\x20\x01(\
    \x08R\tv6Support\x12\x1d\n\nv4_support\x18\x17\x20\x01(\x08R\tv4Support\
    \x12.\n\x05flags\x18\x18\x20\x01(\x0b2\x18.proto.RegistrationFlagsR\x05f\
    lags\x128\n\rwebrtc_signal\x18\x1f\x20\x01(\x0b2\x13.proto.WebRTCSignalR\
    \x0cwebrtcSignal\x12\x18\n\x07padding\x18d\x20\x01(\x0cR\x07padding\"\
    \xaa\x01\n\x15PrefixTransportParams\x12\x1b\n\tprefix_id\x18\x01\x20\x01\
    (\x05R\x08prefixId\x12\x16\n\x06prefix\x18\x02\x20\x01(\x0cR\x06prefix\
    \x12.\n\x13custom_flush_policy\x18\x03\x20\x01(\x05R\x11customFlushPolic\
    y\x12,\n\x12randomize_dst_port\x18\r\x20\x01(\x08R\x10randomizeDstPort\"\
    F\n\x16GenericTransportParams\x12,\n\x12randomize_dst_port\x18\r\x20\x01\
    (\x08R\x10randomizeDstPort\"\xc2\x03\n\nC2SWrapper\x12#\n\rshared_secret\
    \x18\x01\x20\x01(\x0cR\x0csharedSecret\x12I\n\x14registration_payload\
    \x18\x03\x20\x01(\x0b2\x16.proto.ClientToStationR\x13registrationPayload\
    \x12J\n\x13registration_source\x18\x04\x20\x01(\x0e2\x19.proto.Registrat\
    ionSourceR\x12registrationSource\x121\n\x14registration_address\x18\x06\
    \x20\x01(\x0cR\x13registrationAddress\x12#\n\rdecoy_address\x18\x07\x20\
    \x01(\x0cR\x0cdecoyAddress\x12P\n\x15registration_response\x18\x08\x20\
    \x01(\x0b2\x1b.proto.RegistrationResponseR\x14registrationResponse\x12\"\
    \n\x0cRegRespBytes\x18\t\x20\x01(\x0cR\x0cRegRespBytes\x12*\n\x10RegResp\
    Signature\x18\n\x20\x01(\x0cR\x10RegRespSignature\"\xdd\x01\n\x0cSession\
    Stats\x120\n\x14failed_decoys_amount\x18\x14\x20\x01(\rR\x12failedDecoys\
    Amount\x121\n\x15total_time_to_connect\x18\x1f\x20\x01(\rR\x12totalTimeT\
    oConnect\x12$\n\x0ertt_to_station\x18!\x20\x01(\rR\x0crttToStation\x12\
    \x20\n\x0ctls_to_decoy\x18&\x20\x01(\rR\ntlsToDecoy\x12\x20\n\x0ctcp_to_\
    decoy\x18'\x20\x01(\rR\ntcpToDecoy\"\x82\x02\n\x11StationToDetector\x12\
    \x1d\n\nphantom_ip\x18\x01\x20\x01(\tR\tphantomIp\x12\x1b\n\tclient_ip\
    \x18\x02\x20\x01(\tR\x08clientIp\x12\x1d\n\ntimeout_ns\x18\x03\x20\x01(\
    \x04R\ttimeoutNs\x126\n\toperation\x18\x04\x20\x01(\x0e2\x18.proto.Stati\
    onOperationsR\toperation\x12\x19\n\x08dst_port\x18\n\x20\x01(\rR\x07dstP\
    ort\x12\x19\n\x08src_port\x18\x0b\x20\x01(\rR\x07srcPort\x12$\n\x05proto\
    \x18\x0c\x20\x01(\x0e2\x0e.proto.IPProtoR\x05proto\"\xd4\x02\n\x14Regist\
    rationResponse\x12\x1a\n\x08ipv4addr\x18\x01\x20\x01(\x07R\x08ipv4addr\
    \x12\x1a\n\x08ipv6addr\x18\x02\x20\x01(\x0cR\x08ipv6addr\x12\x19\n\x08ds\
    t_port\x18\x03\x20\x01(\rR\x07dstPort\x12\"\n\x0cserverRandom\x18\x04\
    \x20\x01(\x0cR\x0cserverRandom\x12\x14\n\x05error\x18\x05\x20\x01(\tR\
    \x05error\x121\n\nclientConf\x18\x06\x20\x01(\x0b2\x11.proto.ClientConfR\
    \nclientConf\x12?\n\x10transport_params\x18\n\x20\x01(\x0b2\x14.google.p\
    rotobuf.AnyR\x0ftransportParams\x12;\n\x1aphantoms_support_port_rand\x18\
    \x0b\x20\x01(\x08R\x17phantomsSupportPortRand\"\xac\x01\n\x0bDnsResponse\
    \x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\x12/\n\x13clientc\
    onf_outdated\x18\x02\x20\x01(\x08R\x12clientconfOutdated\x12R\n\x16bidir\
    ectional_response\x18\x03\x20\x01(\x0b2\x1b.proto.RegistrationResponseR\
    \x15bidirectionalResponse*+\n\x07KeyType\x12\x0f\n\x0bAES_GCM_128\x10Z\
    \x12\x0f\n\x0bAES_GCM_256\x10[*)\n\x0cDnsRegMethod\x12\x07\n\x03UDP\x10\
    \x01\x12\x07\n\x03DOT\x10\x02\x12\x07\n\x03DOH\x10\x03*\xe7\x01\n\x0eC2S\
    _Transition\x12\x11\n\rC2S_NO_CHANGE\x10\0\x12\x14\n\x10C2S_SESSION_INIT\
    \x10\x01\x12\x1b\n\x17C2S_SESSION_COVERT_INIT\x10\x0b\x12\x18\n\x14C2S_E\
    XPECT_RECONNECT\x10\x02\x12\x15\n\x11C2S_SESSION_CLOSE\x10\x03\x12\x14\n\
    \x10C2S_YIELD_UPLOAD\x10\x04\x12\x16\n\x12C2S_ACQUIRE_UPLOAD\x10\x05\x12\
    \x20\n\x1cC2S_EXPECT_UPLOADONLY_RECONN\x10\x06\x12\x0e\n\tC2S_ERROR\x10\
    \xff\x01*\x98\x01\n\x0eS2C_Transition\x12\x11\n\rS2C_NO_CHANGE\x10\0\x12\
    \x14\n\x10S2C_SESSION_INIT\x10\x01\x12\x1b\n\x17S2C_SESSION_COVERT_INIT\
    \x10\x0b\x12\x19\n\x15S2C_CONFIRM_RECONNECT\x10\x02\x12\x15\n\x11S2C_SES\
    SION_CLOSE\x10\x03\x12\x0e\n\tS2C_ERROR\x10\xff\x01*\xac\x01\n\x0eErrorR\
    easonS2C\x12\x0c\n\x08NO_ERROR\x10\0\x12\x11\n\rCOVERT_STREAM\x10\x01\
    \x12\x13\n\x0fCLIENT_REPORTED\x10\x02\x12\x13\n\x0fCLIENT_PROTOCOL\x10\
    \x03\x12\x14\n\x10STATION_INTERNAL\x10\x04\x12\x12\n\x0eDECOY_OVERLOAD\
    \x10\x05\x12\x11\n\rCLIENT_STREAM\x10d\x12\x12\n\x0eCLIENT_TIMEOUT\x10e*\
    \x82\x01\n\rTransportType\x12\x08\n\x04Null\x10\0\x12\x07\n\x03Min\x10\
    \x01\x12\t\n\x05Obfs4\x10\x02\x12\x08\n\x04DTLS\x10\x03\x12\n\n\x06Prefi\
    x\x10\x04\x12\x08\n\x04uTLS\x10\x05\x12\n\n\x06Format\x10\x06\x12\x08\n\
    \x04WASM\x10\x07\x12\x07\n\x03FTE\x10\x08\x12\x08\n\x04Quic\x10\t\x12\n\
    \n\x06Webrtc\x10c*\x86\x01\n\x12RegistrationSource\x12\x0f\n\x0bUnspecif\
    ied\x10\0\x12\x0c\n\x08Detector\x10\x01\x12\x07\n\x03API\x10\x02\x12\x13\
    \n\x0fDetectorPrescan\x10\x03\x12\x14\n\x10BidirectionalAPI\x10\x04\x12\
    \x07\n\x03DNS\x10\x05\x12\x14\n\x10BidirectionalDNS\x10\x06*@\n\x11Stati\
    onOperations\x12\x0b\n\x07Unknown\x10\0\x12\x07\n\x03New\x10\x01\x12\n\n\
    \x06Update\x10\x02\x12\t\n\x05Clear\x10\x03*$\n\x07IPProto\x12\x07\n\x03\
    Unk\x10\0\x12\x07\n\x03Tcp\x10\x01\x12\x07\n\x03Udp\x10\x02J\xe1\x94\x01\
    \n\x07\x12\x05\0\0\xb6\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\xb0\x01\
    \n\x01\x02\x12\x03\x06\0\x0e2\xa5\x01\x20TODO:\x20We're\x20using\x20prot\
    o2\x20because\x20it's\x20the\x20default\x20on\x20Ubuntu\x2016.04.\n\x20A\
    t\x20some\x20point\x20we\x20will\x20want\x20to\x20migrate\x20to\x20proto\
    3,\x20but\x20we\x20are\x20not\n\x20using\x20any\x20proto3\x20features\
    \x20yet.\n\n\t\n\x02\x03\0\x12\x03\x08\0#\n\n\n\x02\x05\0\x12\x04\n\0\r\
    \x01\n\n\n\x03\x05\0\x01\x12\x03\n\x05\x0c\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03\x0b\x04\x15\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x0b\x04\x0f\n\x0c\n\
    \x05\x05\0\x02\0\x02\x12\x03\x0b\x12\x14\n\x20\n\x04\x05\0\x02\x01\x12\
    \x03\x0c\x04\x15\"\x13\x20not\x20supported\x20atm\n\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x0c\x04\x0f\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\
    \x0c\x12\x14\n\n\n\x02\x04\0\x12\x04\x0f\0\x14\x01\n\n\n\x03\x04\0\x01\
    \x12\x03\x0f\x08\x0e\n4\n\x04\x04\0\x02\0\x12\x03\x11\x04\x1b\x1a'\x20A\
    \x20public\x20key,\x20as\x20used\x20by\x20the\x20station.\n\n\x0c\n\x05\
    \x04\0\x02\0\x04\x12\x03\x11\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    \x11\r\x12\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x11\x13\x16\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03\x11\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03\
    \x13\x04\x1e\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x13\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x01\x06\x12\x03\x13\r\x14\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x13\x15\x19\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x13\x1c\x1d\n\
    \n\n\x02\x04\x01\x12\x04\x16\0<\x01\n\n\n\x03\x04\x01\x01\x12\x03\x16\
    \x08\x14\n\xa1\x01\n\x04\x04\x01\x02\0\x12\x03\x1b\x04!\x1a\x93\x01\x20T\
    he\x20hostname/SNI\x20to\x20use\x20for\x20this\x20host\n\n\x20The\x20hos\
    tname\x20is\x20the\x20only\x20required\x20field,\x20although\x20other\n\
    \x20fields\x20are\x20expected\x20to\x20be\x20present\x20in\x20most\x20ca\
    ses.\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x1b\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03\x1b\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\
    \x1b\x14\x1c\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1b\x1f\x20\n\xf7\x01\
    \n\x04\x04\x01\x02\x01\x12\x03\"\x04\"\x1a\xe9\x01\x20The\x2032-bit\x20i\
    pv4\x20address,\x20in\x20network\x20byte\x20order\n\n\x20If\x20the\x20IP\
    v4\x20address\x20is\x20absent,\x20then\x20it\x20may\x20be\x20resolved\
    \x20via\n\x20DNS\x20by\x20the\x20client,\x20or\x20the\x20client\x20may\
    \x20discard\x20this\x20decoy\x20spec\n\x20if\x20local\x20DNS\x20is\x20un\
    trusted,\x20or\x20the\x20service\x20may\x20be\x20multihomed.\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x04\x12\x03\"\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\
    \x05\x12\x03\"\r\x14\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\"\x15\x1d\n\
    \x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\"\x20!\n>\n\x04\x04\x01\x02\x02\
    \x12\x03%\x04\x20\x1a1\x20The\x20128-bit\x20ipv6\x20address,\x20in\x20ne\
    twork\x20byte\x20order\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03%\x04\
    \x0c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03%\r\x12\n\x0c\n\x05\x04\x01\
    \x02\x02\x01\x12\x03%\x13\x1b\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03%\
    \x1e\x1f\n\x91\x01\n\x04\x04\x01\x02\x03\x12\x03+\x04\x1f\x1a\x83\x01\
    \x20The\x20Tapdance\x20station\x20public\x20key\x20to\x20use\x20when\x20\
    contacting\x20this\n\x20decoy\n\n\x20If\x20omitted,\x20the\x20default\
    \x20station\x20public\x20key\x20(if\x20any)\x20is\x20used.\n\n\x0c\n\x05\
    \x04\x01\x02\x03\x04\x12\x03+\x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x06\
    \x12\x03+\r\x13\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03+\x14\x1a\n\x0c\n\
    \x05\x04\x01\x02\x03\x03\x12\x03+\x1d\x1e\n\xee\x01\n\x04\x04\x01\x02\
    \x04\x12\x032\x04\x20\x1a\xe0\x01\x20The\x20maximum\x20duration,\x20in\
    \x20milliseconds,\x20to\x20maintain\x20an\x20open\n\x20connection\x20to\
    \x20this\x20decoy\x20(because\x20the\x20decoy\x20may\x20close\x20the\n\
    \x20connection\x20itself\x20after\x20this\x20length\x20of\x20time)\n\n\
    \x20If\x20omitted,\x20a\x20default\x20of\x2030,000\x20milliseconds\x20is\
    \x20assumed.\n\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x032\x04\x0c\n\x0c\n\
    \x05\x04\x01\x02\x04\x05\x12\x032\r\x13\n\x0c\n\x05\x04\x01\x02\x04\x01\
    \x12\x032\x14\x1b\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x032\x1e\x1f\n\xb0\
    \x02\n\x04\x04\x01\x02\x05\x12\x03;\x04\x1f\x1a\xa2\x02\x20The\x20maximu\
    m\x20TCP\x20window\x20size\x20to\x20attempt\x20to\x20use\x20for\x20this\
    \x20decoy.\n\n\x20If\x20omitted,\x20a\x20default\x20of\x2015360\x20is\
    \x20assumed.\n\n\x20TODO:\x20the\x20default\x20is\x20based\x20on\x20the\
    \x20current\x20heuristic\x20of\x20only\n\x20using\x20decoys\x20that\x20p\
    ermit\x20windows\x20of\x2015KB\x20or\x20larger.\x20\x20If\x20this\n\x20h\
    euristic\x20changes,\x20then\x20this\x20default\x20doesn't\x20make\x20se\
    nse.\n\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03;\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\x05\x05\x12\x03;\r\x13\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03;\
    \x14\x1a\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03;\x1d\x1e\n\x83\x08\n\
    \x02\x04\x02\x12\x04S\0Z\x012\xf6\x07\x20In\x20version\x201,\x20the\x20r\
    equest\x20is\x20very\x20simple:\x20when\n\x20the\x20client\x20sends\x20a\
    \x20MSG_PROTO\x20to\x20the\x20station,\x20if\x20the\n\x20generation\x20n\
    umber\x20is\x20present,\x20then\x20this\x20request\x20includes\n\x20(in\
    \x20addition\x20to\x20whatever\x20other\x20operations\x20are\x20part\x20\
    of\x20the\n\x20request)\x20a\x20request\x20for\x20the\x20station\x20to\
    \x20send\x20a\x20copy\x20of\n\x20the\x20current\x20decoy\x20set\x20that\
    \x20has\x20a\x20generation\x20number\x20greater\n\x20than\x20the\x20gene\
    ration\x20number\x20in\x20its\x20request.\n\n\x20If\x20the\x20response\
    \x20contains\x20a\x20DecoyListUpdate\x20with\x20a\x20generation\x20numbe\
    r\x20equal\n\x20to\x20that\x20which\x20the\x20client\x20sent,\x20then\
    \x20the\x20client\x20is\x20\"caught\x20up\"\x20with\n\x20the\x20station\
    \x20and\x20the\x20response\x20contains\x20no\x20new\x20information\n\x20\
    (and\x20all\x20other\x20fields\x20may\x20be\x20omitted\x20or\x20empty).\
    \x20\x20Otherwise,\n\x20the\x20station\x20will\x20send\x20the\x20latest\
    \x20configuration\x20information,\n\x20along\x20with\x20its\x20generatio\
    n\x20number.\n\n\x20The\x20station\x20can\x20also\x20send\x20ClientConf\
    \x20messages\n\x20(as\x20part\x20of\x20Station2Client\x20messages)\x20wh\
    enever\x20it\x20wants.\n\x20The\x20client\x20is\x20expected\x20to\x20rea\
    ct\x20as\x20if\x20it\x20had\x20requested\n\x20such\x20messages\x20--\x20\
    possibly\x20by\x20ignoring\x20them,\x20if\x20the\x20client\n\x20is\x20al\
    ready\x20up-to-date\x20according\x20to\x20the\x20generation\x20number.\n\
    \n\n\n\x03\x04\x02\x01\x12\x03S\x08\x12\n\x0b\n\x04\x04\x02\x02\0\x12\
    \x03T\x04&\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03T\x04\x0c\n\x0c\n\x05\
    \x04\x02\x02\0\x06\x12\x03T\r\x16\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03T\
    \x17!\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03T$%\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03U\x04#\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03U\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03U\r\x13\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03U\x14\x1e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03U!\"\n\
    \x0b\n\x04\x04\x02\x02\x02\x12\x03V\x04'\n\x0c\n\x05\x04\x02\x02\x02\x04\
    \x12\x03V\x04\x0c\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03V\r\x13\n\x0c\n\
    \x05\x04\x02\x02\x02\x01\x12\x03V\x14\"\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03V%&\n\x0b\n\x04\x04\x02\x02\x03\x12\x03W\x049\n\x0c\n\x05\x04\
    \x02\x02\x03\x04\x12\x03W\x04\x0c\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\
    \x03W\r\x1f\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03W\x204\n\x0c\n\x05\
    \x04\x02\x02\x03\x03\x12\x03W78\n\x0b\n\x04\x04\x02\x02\x04\x12\x03X\x04\
    '\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03X\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x04\x06\x12\x03X\r\x13\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03X\x14\
    \"\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03X%&\n\x0b\n\x04\x04\x02\x02\
    \x05\x12\x03Y\x04)\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03Y\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x05\x06\x12\x03Y\r\x17\n\x0c\n\x05\x04\x02\x02\
    \x05\x01\x12\x03Y\x18$\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03Y'(\n-\n\
    \x02\x04\x03\x12\x04]\0d\x01\x1a!\x20Configuration\x20for\x20DNS\x20regi\
    strar\n\n\n\n\x03\x04\x03\x01\x12\x03]\x08\x12\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x03^\x04-\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03^\x04\x0c\n\x0c\n\
    \x05\x04\x03\x02\0\x06\x12\x03^\r\x19\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03^\x1a(\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03^+,\n\x0b\n\x04\x04\x03\
    \x02\x01\x12\x03_\x04\x1f\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03_\x04\
    \x0c\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03_\r\x13\n\x0c\n\x05\x04\x03\
    \x02\x01\x01\x12\x03_\x14\x1a\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03_\
    \x1d\x1e\n\x0b\n\x04\x04\x03\x02\x02\x12\x03`\x04\x1f\n\x0c\n\x05\x04\
    \x03\x02\x02\x04\x12\x03`\x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x03`\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03`\x14\x1a\n\x0c\n\x05\
    \x04\x03\x02\x02\x03\x12\x03`\x1d\x1e\n\x0b\n\x04\x04\x03\x02\x03\x12\
    \x03a\x04\x1e\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03a\x04\x0c\n\x0c\n\
    \x05\x04\x03\x02\x03\x05\x12\x03a\r\x12\n\x0c\n\x05\x04\x03\x02\x03\x01\
    \x12\x03a\x13\x19\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03a\x1c\x1d\n\x0b\
    \n\x04\x04\x03\x02\x04\x12\x03b\x04*\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\
    \x03b\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03b\r\x13\n\x0c\n\x05\
    \x04\x03\x02\x04\x01\x12\x03b\x14%\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\
    \x03b()\n\x0b\n\x04\x04\x03\x02\x05\x12\x03c\x04$\n\x0c\n\x05\x04\x03\
    \x02\x05\x04\x12\x03c\x04\x0c\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03c\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03c\x14\x1f\n\x0c\n\x05\x04\
    \x03\x02\x05\x03\x12\x03c\"#\n\n\n\x02\x05\x01\x12\x04f\0j\x01\n\n\n\x03\
    \x05\x01\x01\x12\x03f\x05\x11\n\x0b\n\x04\x05\x01\x02\0\x12\x03g\x04\x0c\
    \n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03g\x04\x07\n\x0c\n\x05\x05\x01\x02\
    \0\x02\x12\x03g\n\x0b\n\x0b\n\x04\x05\x01\x02\x01\x12\x03h\x04\x0c\n\x0c\
    \n\x05\x05\x01\x02\x01\x01\x12\x03h\x04\x07\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03h\n\x0b\n\x0b\n\x04\x05\x01\x02\x02\x12\x03i\x04\x0c\n\x0c\n\
    \x05\x05\x01\x02\x02\x01\x12\x03i\x04\x07\n\x0c\n\x05\x05\x01\x02\x02\
    \x02\x12\x03i\n\x0b\n\n\n\x02\x04\x04\x12\x04l\0n\x01\n\n\n\x03\x04\x04\
    \x01\x12\x03l\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03m\x04)\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x03m\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\
    \x12\x03m\r\x19\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03m\x1a$\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03m'(\n\n\n\x02\x04\x05\x12\x04p\0r\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03p\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03q\x04\
    1\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03q\x04\x0c\n\x0c\n\x05\x04\x05\x02\
    \0\x06\x12\x03q\r\x1b\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03q\x1c,\n\x0c\
    \n\x05\x04\x05\x02\0\x03\x12\x03q/0\n\n\n\x02\x04\x06\x12\x04t\0x\x01\n\
    \n\n\x03\x04\x06\x01\x12\x03t\x08\x16\n\x0b\n\x04\x04\x06\x02\0\x12\x03u\
    \x04\x1f\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03u\x04\x0c\n\x0c\n\x05\x04\
    \x06\x02\0\x05\x12\x03u\r\x13\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03u\x14\
    \x1a\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03u\x1d\x1e\n\x0b\n\x04\x04\x06\
    \x02\x01\x12\x03v\x04\x20\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03v\x04\
    \x0c\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03v\r\x13\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03v\x14\x1b\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03v\
    \x1e\x1f\n\x0b\n\x04\x04\x06\x02\x02\x12\x03w\x04)\n\x0c\n\x05\x04\x06\
    \x02\x02\x04\x12\x03w\x04\x0c\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03w\r\
    \x11\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03w\x12$\n\x0c\n\x05\x04\x06\
    \x02\x02\x03\x12\x03w'(\n.\n\x02\x05\x02\x12\x05{\0\x85\x01\x01\x1a!\x20\
    State\x20transitions\x20of\x20the\x20client\n\n\n\n\x03\x05\x02\x01\x12\
    \x03{\x05\x13\n\x0b\n\x04\x05\x02\x02\0\x12\x03|\x04\x16\n\x0c\n\x05\x05\
    \x02\x02\0\x01\x12\x03|\x04\x11\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03|\
    \x14\x15\n\"\n\x04\x05\x02\x02\x01\x12\x03}\x04\x19\"\x15\x20connect\x20\
    me\x20to\x20squid\n\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03}\x04\x14\n\
    \x0c\n\x05\x05\x02\x02\x01\x02\x12\x03}\x17\x18\n,\n\x04\x05\x02\x02\x02\
    \x12\x03~\x04!\"\x1f\x20connect\x20me\x20to\x20provided\x20covert\n\n\
    \x0c\n\x05\x05\x02\x02\x02\x01\x12\x03~\x04\x1b\n\x0c\n\x05\x05\x02\x02\
    \x02\x02\x12\x03~\x1e\x20\n\x0b\n\x04\x05\x02\x02\x03\x12\x03\x7f\x04\
    \x1d\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03\x7f\x04\x18\n\x0c\n\x05\x05\
    \x02\x02\x03\x02\x12\x03\x7f\x1b\x1c\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\
    \x80\x01\x04\x1a\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\x80\x01\x04\x15\n\
    \r\n\x05\x05\x02\x02\x04\x02\x12\x04\x80\x01\x18\x19\n\x0c\n\x04\x05\x02\
    \x02\x05\x12\x04\x81\x01\x04\x19\n\r\n\x05\x05\x02\x02\x05\x01\x12\x04\
    \x81\x01\x04\x14\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\x81\x01\x17\x18\n\
    \x0c\n\x04\x05\x02\x02\x06\x12\x04\x82\x01\x04\x1b\n\r\n\x05\x05\x02\x02\
    \x06\x01\x12\x04\x82\x01\x04\x16\n\r\n\x05\x05\x02\x02\x06\x02\x12\x04\
    \x82\x01\x19\x1a\n\x0c\n\x04\x05\x02\x02\x07\x12\x04\x83\x01\x04%\n\r\n\
    \x05\x05\x02\x02\x07\x01\x12\x04\x83\x01\x04\x20\n\r\n\x05\x05\x02\x02\
    \x07\x02\x12\x04\x83\x01#$\n\x0c\n\x04\x05\x02\x02\x08\x12\x04\x84\x01\
    \x04\x14\n\r\n\x05\x05\x02\x02\x08\x01\x12\x04\x84\x01\x04\r\n\r\n\x05\
    \x05\x02\x02\x08\x02\x12\x04\x84\x01\x10\x13\n/\n\x02\x05\x03\x12\x06\
    \x88\x01\0\x90\x01\x01\x1a!\x20State\x20transitions\x20of\x20the\x20serv\
    er\n\n\x0b\n\x03\x05\x03\x01\x12\x04\x88\x01\x05\x13\n\x0c\n\x04\x05\x03\
    \x02\0\x12\x04\x89\x01\x04\x16\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\x89\
    \x01\x04\x11\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\x89\x01\x14\x15\n\"\n\
    \x04\x05\x03\x02\x01\x12\x04\x8a\x01\x04\x19\"\x14\x20connected\x20to\
    \x20squid\n\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\x8a\x01\x04\x14\n\r\n\
    \x05\x05\x03\x02\x01\x02\x12\x04\x8a\x01\x17\x18\n(\n\x04\x05\x03\x02\
    \x02\x12\x04\x8b\x01\x04!\"\x1a\x20connected\x20to\x20covert\x20host\n\n\
    \r\n\x05\x05\x03\x02\x02\x01\x12\x04\x8b\x01\x04\x1b\n\r\n\x05\x05\x03\
    \x02\x02\x02\x12\x04\x8b\x01\x1e\x20\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\
    \x8c\x01\x04\x1e\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\x8c\x01\x04\x19\n\
    \r\n\x05\x05\x03\x02\x03\x02\x12\x04\x8c\x01\x1c\x1d\n\x0c\n\x04\x05\x03\
    \x02\x04\x12\x04\x8d\x01\x04\x1a\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\
    \x8d\x01\x04\x15\n\r\n\x05\x05\x03\x02\x04\x02\x12\x04\x8d\x01\x18\x19\n\
    S\n\x04\x05\x03\x02\x05\x12\x04\x8f\x01\x04\x14\x1aE\x20TODO\x20should\
    \x20probably\x20also\x20allow\x20EXPECT_RECONNECT\x20here,\x20for\x20Dit\
    toTap\n\n\r\n\x05\x05\x03\x02\x05\x01\x12\x04\x8f\x01\x04\r\n\r\n\x05\
    \x05\x03\x02\x05\x02\x12\x04\x8f\x01\x10\x13\n8\n\x02\x05\x04\x12\x06\
    \x93\x01\0\x9d\x01\x01\x1a*\x20Should\x20accompany\x20all\x20S2C_ERROR\
    \x20messages.\n\n\x0b\n\x03\x05\x04\x01\x12\x04\x93\x01\x05\x13\n\x0c\n\
    \x04\x05\x04\x02\0\x12\x04\x94\x01\x04\x11\n\r\n\x05\x05\x04\x02\0\x01\
    \x12\x04\x94\x01\x04\x0c\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\x94\x01\x0f\
    \x10\n*\n\x04\x05\x04\x02\x01\x12\x04\x95\x01\x04\x16\"\x1c\x20Squid\x20\
    TCP\x20connection\x20broke\n\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\x95\
    \x01\x04\x11\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\x95\x01\x14\x15\n7\n\
    \x04\x05\x04\x02\x02\x12\x04\x96\x01\x04\x18\")\x20You\x20told\x20me\x20\
    something\x20was\x20wrong,\x20client\n\n\r\n\x05\x05\x04\x02\x02\x01\x12\
    \x04\x96\x01\x04\x13\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\x96\x01\x16\
    \x17\n@\n\x04\x05\x04\x02\x03\x12\x04\x97\x01\x04\x18\"2\x20You\x20messe\
    d\x20up,\x20client\x20(e.g.\x20sent\x20a\x20bad\x20protobuf)\n\n\r\n\x05\
    \x05\x04\x02\x03\x01\x12\x04\x97\x01\x04\x13\n\r\n\x05\x05\x04\x02\x03\
    \x02\x12\x04\x97\x01\x16\x17\n\x17\n\x04\x05\x04\x02\x04\x12\x04\x98\x01\
    \x04\x19\"\t\x20I\x20broke\n\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\x98\
    \x01\x04\x14\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\x98\x01\x17\x18\nE\n\
    \x04\x05\x04\x02\x05\x12\x04\x99\x01\x04\x17\"7\x20Everything's\x20fine,\
    \x20but\x20don't\x20use\x20this\x20decoy\x20right\x20now\n\n\r\n\x05\x05\
    \x04\x02\x05\x01\x12\x04\x99\x01\x04\x12\n\r\n\x05\x05\x04\x02\x05\x02\
    \x12\x04\x99\x01\x15\x16\nD\n\x04\x05\x04\x02\x06\x12\x04\x9b\x01\x04\
    \x18\"6\x20My\x20stream\x20to\x20you\x20broke.\x20(This\x20is\x20impossi\
    ble\x20to\x20send)\n\n\r\n\x05\x05\x04\x02\x06\x01\x12\x04\x9b\x01\x04\
    \x11\n\r\n\x05\x05\x04\x02\x06\x02\x12\x04\x9b\x01\x14\x17\nA\n\x04\x05\
    \x04\x02\x07\x12\x04\x9c\x01\x04\x19\"3\x20You\x20never\x20came\x20back.\
    \x20(This\x20is\x20impossible\x20to\x20send)\n\n\r\n\x05\x05\x04\x02\x07\
    \x01\x12\x04\x9c\x01\x04\x12\n\r\n\x05\x05\x04\x02\x07\x02\x12\x04\x9c\
    \x01\x15\x18\n\x0c\n\x02\x05\x05\x12\x06\x9f\x01\0\xab\x01\x01\n\x0b\n\
    \x03\x05\x05\x01\x12\x04\x9f\x01\x05\x12\n\x0c\n\x04\x05\x05\x02\0\x12\
    \x04\xa0\x01\x04\r\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xa0\x01\x04\x08\n\
    \r\n\x05\x05\x05\x02\0\x02\x12\x04\xa0\x01\x0b\x0c\n`\n\x04\x05\x05\x02\
    \x01\x12\x04\xa1\x01\x04\x0c\"R\x20Send\x20a\x2032-byte\x20HMAC\x20id\
    \x20to\x20let\x20the\x20station\x20distinguish\x20registrations\x20to\
    \x20same\x20host\n\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xa1\x01\x04\x07\
    \n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xa1\x01\n\x0b\n\x0c\n\x04\x05\x05\
    \x02\x02\x12\x04\xa2\x01\x04\x0e\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\
    \xa2\x01\x04\t\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xa2\x01\x0c\r\n#\n\
    \x04\x05\x05\x02\x03\x12\x04\xa3\x01\x04\r\"\x15\x20UDP\x20transport:\
    \x20DTLS\n\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\xa3\x01\x04\x08\n\r\n\
    \x05\x05\x05\x02\x03\x02\x12\x04\xa3\x01\x0b\x0c\n:\n\x04\x05\x05\x02\
    \x04\x12\x04\xa4\x01\x04\x0f\",\x20dynamic\x20prefix\x20transport\x20(an\
    d\x20updated\x20Min)\n\n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\xa4\x01\x04\
    \n\n\r\n\x05\x05\x05\x02\x04\x02\x12\x04\xa4\x01\r\x0e\n$\n\x04\x05\x05\
    \x02\x05\x12\x04\xa5\x01\x04\r\"\x16\x20uTLS\x20based\x20transport\n\n\r\
    \n\x05\x05\x05\x02\x05\x01\x12\x04\xa5\x01\x04\x08\n\r\n\x05\x05\x05\x02\
    \x05\x02\x12\x04\xa5\x01\x0b\x0c\n?\n\x04\x05\x05\x02\x06\x12\x04\xa6\
    \x01\x04\x0f\"1\x20Formatting\x20transport\x20-\x20format\x20first,\x20f\
    ormat\x20all\n\n\r\n\x05\x05\x05\x02\x06\x01\x12\x04\xa6\x01\x04\n\n\r\n\
    \x05\x05\x05\x02\x06\x02\x12\x04\xa6\x01\r\x0e\n\x1b\n\x04\x05\x05\x02\
    \x07\x12\x04\xa7\x01\x04\r\"\r\x20WebAssembly\n\n\r\n\x05\x05\x05\x02\
    \x07\x01\x12\x04\xa7\x01\x04\x08\n\r\n\x05\x05\x05\x02\x07\x02\x12\x04\
    \xa7\x01\x0b\x0c\n.\n\x04\x05\x05\x02\x08\x12\x04\xa8\x01\x04\x0c\"\x20\
    \x20Format\x20transforming\x20encryption\n\n\r\n\x05\x05\x05\x02\x08\x01\
    \x12\x04\xa8\x01\x04\x07\n\r\n\x05\x05\x05\x02\x08\x02\x12\x04\xa8\x01\n\
    \x0b\n\x1f\n\x04\x05\x05\x02\t\x12\x04\xa9\x01\x04\r\"\x11\x20quic\x20tr\
    ansport?\n\n\r\n\x05\x05\x05\x02\t\x01\x12\x04\xa9\x01\x04\x08\n\r\n\x05\
    \x05\x05\x02\t\x02\x12\x04\xa9\x01\x0b\x0c\n1\n\x04\x05\x05\x02\n\x12\
    \x04\xaa\x01\x04\x10\"#\x20UDP\x20transport:\x20WebRTC\x20DataChannel\n\
    \n\r\n\x05\x05\x05\x02\n\x01\x12\x04\xaa\x01\x04\n\n\r\n\x05\x05\x05\x02\
    \n\x02\x12\x04\xaa\x01\r\x0f\n:\n\x02\x04\x07\x12\x06\xae\x01\0\xb4\x01\
    \x01\x1a,\x20Deflated\x20ICE\x20Candidate\x20by\x20seed2sdp\x20package\n\
    \n\x0b\n\x03\x04\x07\x01\x12\x04\xae\x01\x08\x1a\n5\n\x04\x04\x07\x02\0\
    \x12\x04\xb0\x01\x04!\x1a'\x20IP\x20is\x20represented\x20in\x20its\x2016\
    -byte\x20form\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xb0\x01\x04\x0c\n\r\
    \n\x05\x04\x07\x02\0\x05\x12\x04\xb0\x01\r\x13\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\xb0\x01\x14\x1c\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xb0\x01\
    \x1f\x20\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xb1\x01\x04!\n\r\n\x05\x04\
    \x07\x02\x01\x04\x12\x04\xb1\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x01\x05\
    \x12\x04\xb1\x01\r\x13\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xb1\x01\x14\
    \x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xb1\x01\x1f\x20\n\x9b\x01\n\
    \x04\x04\x07\x02\x02\x12\x04\xb3\x01\x04&\x1a\x8c\x01\x20Composed\x20inf\
    o\x20includes\x20port,\x20tcptype\x20(unset\x20if\x20not\x20tcp),\x20can\
    didate\x20type\x20(host,\x20srflx,\x20prflx),\x20protocol\x20(TCP/UDP),\
    \x20and\x20component\x20(RTP/RTCP)\n\n\r\n\x05\x04\x07\x02\x02\x04\x12\
    \x04\xb3\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\xb3\x01\r\x13\
    \n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xb3\x01\x14!\n\r\n\x05\x04\x07\
    \x02\x02\x03\x12\x04\xb3\x01$%\n;\n\x02\x04\x08\x12\x06\xb7\x01\0\xba\
    \x01\x01\x1a-\x20Deflated\x20SDP\x20for\x20WebRTC\x20by\x20seed2sdp\x20p\
    ackage\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xb7\x01\x08\x11\n\x0c\n\x04\x04\
    \x08\x02\0\x12\x04\xb8\x01\x04\x1d\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\
    \xb8\x01\x04\x0c\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xb8\x01\r\x13\n\r\n\
    \x05\x04\x08\x02\0\x01\x12\x04\xb8\x01\x14\x18\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xb8\x01\x1b\x1c\n2\n\x04\x04\x08\x02\x01\x12\x04\xb9\x01\
    \x04/\"$\x20there\x20could\x20be\x20multiple\x20candidates\n\n\r\n\x05\
    \x04\x08\x02\x01\x04\x12\x04\xb9\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x01\
    \x06\x12\x04\xb9\x01\r\x1f\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xb9\x01\
    \x20*\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xb9\x01-.\n?\n\x02\x04\t\x12\
    \x06\xbd\x01\0\xc0\x01\x01\x1a1\x20WebRTCSignal\x20includes\x20a\x20defl\
    ated\x20SDP\x20and\x20a\x20seed\n\n\x0b\n\x03\x04\t\x01\x12\x04\xbd\x01\
    \x08\x14\n\x0c\n\x04\x04\t\x02\0\x12\x04\xbe\x01\x04\x1d\n\r\n\x05\x04\t\
    \x02\0\x04\x12\x04\xbe\x01\x04\x0c\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xbe\
    \x01\r\x13\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xbe\x01\x14\x18\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\xbe\x01\x1b\x1c\n\x0c\n\x04\x04\t\x02\x01\x12\
    \x04\xbf\x01\x04\x1f\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xbf\x01\x04\x0c\
    \n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xbf\x01\r\x16\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\xbf\x01\x17\x1a\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xbf\
    \x01\x1d\x1e\n\x0c\n\x02\x04\n\x12\x06\xc2\x01\0\xc5\x01\x01\n\x0b\n\x03\
    \x04\n\x01\x12\x04\xc2\x01\x08\x0c\n\x0c\n\x04\x04\n\x02\0\x12\x04\xc3\
    \x01\x04\x1a\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xc3\x01\x04\x0c\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\xc3\x01\r\x12\n\r\n\x05\x04\n\x02\0\x01\x12\x04\
    \xc3\x01\x13\x15\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xc3\x01\x18\x19\n\x0c\
    \n\x04\x04\n\x02\x01\x12\x04\xc4\x01\x04\x1d\n\r\n\x05\x04\n\x02\x01\x04\
    \x12\x04\xc4\x01\x04\x0c\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xc4\x01\r\
    \x13\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xc4\x01\x14\x18\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\xc4\x01\x1b\x1c\n\x0c\n\x02\x04\x0b\x12\x06\xc7\x01\
    \0\xcd\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xc7\x01\x08\x1b\n\x0c\n\
    \x04\x04\x0b\x02\0\x12\x04\xc8\x01\x04\x20\n\r\n\x05\x04\x0b\x02\0\x04\
    \x12\x04\xc8\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xc8\x01\r\
    \x11\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xc8\x01\x12\x1b\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\xc8\x01\x1e\x1f\n\x0c\n\x04\x04\x0b\x02\x01\x12\
    \x04\xc9\x01\x04\x20\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xc9\x01\x04\
    \x0c\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xc9\x01\r\x11\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\xc9\x01\x12\x1b\n\r\n\x05\x04\x0b\x02\x01\x03\
    \x12\x04\xc9\x01\x1e\x1f\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xca\x01\x04\
    )\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xca\x01\x04\x0c\n\r\n\x05\x04\
    \x0b\x02\x02\x05\x12\x04\xca\x01\r\x11\n\r\n\x05\x04\x0b\x02\x02\x01\x12\
    \x04\xca\x01\x12$\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xca\x01'(\nN\n\
    \x04\x04\x0b\x02\x03\x12\x04\xcc\x01\x04\x20\x1a@\x20Unordered\x20sets\
    \x20the\x20reliability\x20of\x20the\x20DTLS\x20stream\x20to\x20unordered\
    \n\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\xcc\x01\x04\x0c\n\r\n\x05\x04\
    \x0b\x02\x03\x05\x12\x04\xcc\x01\r\x11\n\r\n\x05\x04\x0b\x02\x03\x01\x12\
    \x04\xcc\x01\x12\x1b\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xcc\x01\x1e\
    \x1f\n\x0c\n\x02\x04\x0c\x12\x06\xcf\x01\0\xe6\x01\x01\n\x0b\n\x03\x04\
    \x0c\x01\x12\x04\xcf\x01\x08\x17\nO\n\x04\x04\x0c\x02\0\x12\x04\xd1\x01\
    \x04)\x1aA\x20Should\x20accompany\x20(at\x20least)\x20SESSION_INIT\x20an\
    d\x20CONFIRM_RECONNECT.\n\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xd1\x01\
    \x04\x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xd1\x01\r\x13\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\xd1\x01\x14$\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\
    \xd1\x01'(\nv\n\x04\x04\x0c\x02\x01\x12\x04\xd5\x01\x041\x1ah\x20There\
    \x20might\x20be\x20a\x20state\x20transition.\x20May\x20be\x20absent;\x20\
    absence\x20should\x20be\n\x20treated\x20identically\x20to\x20NO_CHANGE.\
    \n\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xd5\x01\x04\x0c\n\r\n\x05\x04\
    \x0c\x02\x01\x06\x12\x04\xd5\x01\r\x1b\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xd5\x01\x1c,\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xd5\x01/0\nc\n\
    \x04\x04\x0c\x02\x02\x12\x04\xd9\x01\x04(\x1aU\x20The\x20station\x20can\
    \x20send\x20client\x20config\x20info\x20piggybacked\n\x20on\x20any\x20me\
    ssage,\x20as\x20it\x20sees\x20fit\n\n\r\n\x05\x04\x0c\x02\x02\x04\x12\
    \x04\xd9\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\xd9\x01\r\x17\
    \n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xd9\x01\x18#\n\r\n\x05\x04\x0c\
    \x02\x02\x03\x12\x04\xd9\x01&'\nP\n\x04\x04\x0c\x02\x03\x12\x04\xdc\x01\
    \x04+\x1aB\x20If\x20state_transition\x20==\x20S2C_ERROR,\x20this\x20fiel\
    d\x20is\x20the\x20explanation.\n\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\
    \xdc\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x03\x06\x12\x04\xdc\x01\r\x1b\n\r\
    \n\x05\x04\x0c\x02\x03\x01\x12\x04\xdc\x01\x1c&\n\r\n\x05\x04\x0c\x02\
    \x03\x03\x12\x04\xdc\x01)*\nQ\n\x04\x04\x0c\x02\x04\x12\x04\xdf\x01\x04$\
    \x1aC\x20Signals\x20client\x20to\x20stop\x20connecting\x20for\x20followi\
    ng\x20amount\x20of\x20seconds\n\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\
    \xdf\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\xdf\x01\r\x13\n\r\
    \n\x05\x04\x0c\x02\x04\x01\x12\x04\xdf\x01\x14\x1f\n\r\n\x05\x04\x0c\x02\
    \x04\x03\x12\x04\xdf\x01\"#\nK\n\x04\x04\x0c\x02\x05\x12\x04\xe2\x01\x04\
    #\x1a=\x20Sent\x20in\x20SESSION_INIT,\x20identifies\x20the\x20station\
    \x20that\x20picked\x20up\n\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xe2\x01\
    \x04\x0c\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xe2\x01\r\x13\n\r\n\x05\
    \x04\x0c\x02\x05\x01\x12\x04\xe2\x01\x14\x1e\n\r\n\x05\x04\x0c\x02\x05\
    \x03\x12\x04\xe2\x01!\"\nG\n\x04\x04\x0c\x02\x06\x12\x04\xe5\x01\x04!\
    \x1a9\x20Random-sized\x20junk\x20to\x20defeat\x20packet\x20size\x20finge\
    rprinting.\n\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\xe5\x01\x04\x0c\n\r\n\
    \x05\x04\x0c\x02\x06\x05\x12\x04\xe5\x01\r\x12\n\r\n\x05\x04\x0c\x02\x06\
    \x01\x12\x04\xe5\x01\x13\x1a\n\r\n\x05\x04\x0c\x02\x06\x03\x12\x04\xe5\
    \x01\x1d\x20\n\x0c\n\x02\x04\r\x12\x06\xe8\x01\0\xee\x01\x01\n\x0b\n\x03\
    \x04\r\x01\x12\x04\xe8\x01\x08\x19\n\x0c\n\x04\x04\r\x02\0\x12\x04\xe9\
    \x01\x08&\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\0\x05\x12\x04\xe9\x01\x11\x15\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\xe9\x01\x16!\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xe9\x01$%\n\x0c\n\
    \x04\x04\r\x02\x01\x12\x04\xea\x01\x08%\n\r\n\x05\x04\r\x02\x01\x04\x12\
    \x04\xea\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xea\x01\x11\x15\
    \n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xea\x01\x16\x20\n\r\n\x05\x04\r\x02\
    \x01\x03\x12\x04\xea\x01#$\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xeb\x01\x08\
    '\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xeb\x01\x08\x10\n\r\n\x05\x04\r\
    \x02\x02\x05\x12\x04\xeb\x01\x11\x15\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\
    \xeb\x01\x16\"\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xeb\x01%&\n\x0c\n\x04\
    \x04\r\x02\x03\x12\x04\xec\x01\x04\x1e\n\r\n\x05\x04\r\x02\x03\x04\x12\
    \x04\xec\x01\x04\x0c\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xec\x01\r\x11\n\
    \r\n\x05\x04\r\x02\x03\x01\x12\x04\xec\x01\x12\x19\n\r\n\x05\x04\r\x02\
    \x03\x03\x12\x04\xec\x01\x1c\x1d\n\x0c\n\x04\x04\r\x02\x04\x12\x04\xed\
    \x01\x04!\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xed\x01\x04\x0c\n\r\n\x05\
    \x04\r\x02\x04\x05\x12\x04\xed\x01\r\x11\n\r\n\x05\x04\r\x02\x04\x01\x12\
    \x04\xed\x01\x12\x1c\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xed\x01\x1f\x20\
    \n\x0c\n\x02\x04\x0e\x12\x06\xf0\x01\0\xaa\x02\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xf0\x01\x08\x17\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xf1\x01\
    \x04)\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xf1\x01\x04\x0c\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\xf1\x01\r\x13\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xf1\x01\x14$\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xf1\x01'(\n\xd0\x01\n\
    \x04\x04\x0e\x02\x01\x12\x04\xf6\x01\x04.\x1a\xc1\x01\x20The\x20client\
    \x20reports\x20its\x20decoy\x20list's\x20version\x20number\x20here,\x20w\
    hich\x20the\n\x20station\x20can\x20use\x20to\x20decide\x20whether\x20to\
    \x20send\x20an\x20updated\x20one.\x20The\x20station\n\x20should\x20alway\
    s\x20send\x20a\x20list\x20if\x20this\x20field\x20is\x20set\x20to\x200.\n\
    \n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xf6\x01\x04\x0c\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\xf6\x01\r\x13\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \xf6\x01\x14)\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xf6\x01,-\n\x0c\n\
    \x04\x04\x0e\x02\x02\x12\x04\xf8\x01\x041\n\r\n\x05\x04\x0e\x02\x02\x04\
    \x12\x04\xf8\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\xf8\x01\r\
    \x1b\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xf8\x01\x1c,\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\xf8\x01/0\n\x80\x01\n\x04\x04\x0e\x02\x03\x12\
    \x04\xfc\x01\x04$\x1ar\x20The\x20position\x20in\x20the\x20overall\x20ses\
    sion's\x20upload\x20sequence\x20where\x20the\x20current\n\x20YIELD=>ACQU\
    IRE\x20switchover\x20is\x20happening.\n\n\r\n\x05\x04\x0e\x02\x03\x04\
    \x12\x04\xfc\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xfc\x01\r\
    \x13\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xfc\x01\x14\x1f\n\r\n\x05\x04\
    \x0e\x02\x03\x03\x12\x04\xfc\x01\"#\ng\n\x04\x04\x0e\x02\x04\x12\x04\x80\
    \x02\x04+\x1aY\x20High\x20level\x20client\x20library\x20version\x20used\
    \x20for\x20indicating\x20feature\x20support,\x20or\n\x20lack\x20therof.\
    \n\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\x80\x02\x04\x0c\n\r\n\x05\x04\
    \x0e\x02\x04\x05\x12\x04\x80\x02\r\x13\n\r\n\x05\x04\x0e\x02\x04\x01\x12\
    \x04\x80\x02\x14&\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x80\x02)*\n\xa5\
    \x02\n\x04\x04\x0e\x02\x05\x12\x04\x85\x02\x042\x1a\x96\x02\x20Indicates\
    \x20whether\x20the\x20client\x20will\x20allow\x20the\x20registrar\x20to\
    \x20provide\x20alternative\x20parameters\x20that\n\x20may\x20work\x20bet\
    ter\x20in\x20substitute\x20for\x20the\x20deterministically\x20selected\
    \x20parameters.\x20This\x20only\x20works\n\x20for\x20bidirectional\x20re\
    gistration\x20methods\x20where\x20the\x20client\x20receives\x20a\x20Regi\
    strationResponse.\n\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\x85\x02\x04\
    \x0c\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\x85\x02\r\x11\n\r\n\x05\x04\
    \x0e\x02\x05\x01\x12\x04\x85\x02\x12-\n\r\n\x05\x04\x0e\x02\x05\x03\x12\
    \x04\x85\x0201\nq\n\x04\x04\x0e\x02\x06\x12\x04\x89\x02\x04'\x1ac\x20Lis\
    t\x20of\x20decoys\x20that\x20client\x20have\x20unsuccessfully\x20tried\
    \x20in\x20current\x20session.\n\x20Could\x20be\x20sent\x20in\x20chunks\n\
    \n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\x89\x02\x04\x0c\n\r\n\x05\x04\x0e\
    \x02\x06\x05\x12\x04\x89\x02\r\x13\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\
    \x89\x02\x14!\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\x89\x02$&\n\x0c\n\
    \x04\x04\x0e\x02\x07\x12\x04\x8b\x02\x04%\n\r\n\x05\x04\x0e\x02\x07\x04\
    \x12\x04\x8b\x02\x04\x0c\n\r\n\x05\x04\x0e\x02\x07\x06\x12\x04\x8b\x02\r\
    \x19\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\x8b\x02\x1a\x1f\n\r\n\x05\x04\
    \x0e\x02\x07\x03\x12\x04\x8b\x02\"$\nk\n\x04\x04\x0e\x02\x08\x12\x04\x8e\
    \x02\x04*\x1a]\x20NullTransport,\x20MinTransport,\x20Obfs4Transport,\x20\
    etc.\x20Transport\x20type\x20we\x20want\x20from\x20phantom\x20proxy\n\n\
    \r\n\x05\x04\x0e\x02\x08\x04\x12\x04\x8e\x02\x04\x0c\n\r\n\x05\x04\x0e\
    \x02\x08\x06\x12\x04\x8e\x02\r\x1a\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\
    \x8e\x02\x1b$\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\x8e\x02')\n\x0c\n\
    \x04\x04\x0e\x02\t\x12\x04\x90\x02\x047\n\r\n\x05\x04\x0e\x02\t\x04\x12\
    \x04\x90\x02\x04\x0c\n\r\n\x05\x04\x0e\x02\t\x06\x12\x04\x90\x02\r\x20\n\
    \r\n\x05\x04\x0e\x02\t\x01\x12\x04\x90\x02!1\n\r\n\x05\x04\x0e\x02\t\x03\
    \x12\x04\x90\x0246\n\xc8\x03\n\x04\x04\x0e\x02\n\x12\x04\x98\x02\x04(\
    \x1a\xb9\x03\x20Station\x20is\x20only\x20required\x20to\x20check\x20this\
    \x20variable\x20during\x20session\x20initialization.\n\x20If\x20set,\x20\
    station\x20must\x20facilitate\x20connection\x20to\x20said\x20target\x20b\
    y\x20itself,\x20i.e.\x20write\x20into\x20squid\n\x20socket\x20an\x20HTTP\
    /SOCKS/any\x20other\x20connection\x20request.\n\x20covert_address\x20mus\
    t\x20have\x20exactly\x20one\x20':'\x20colon,\x20that\x20separates\x20hos\
    t\x20(literal\x20IP\x20address\x20or\n\x20resolvable\x20hostname)\x20and\
    \x20port\n\x20TODO:\x20make\x20it\x20required\x20for\x20initialization,\
    \x20and\x20stop\x20connecting\x20any\x20client\x20straight\x20to\x20squi\
    d?\n\n\r\n\x05\x04\x0e\x02\n\x04\x12\x04\x98\x02\x04\x0c\n\r\n\x05\x04\
    \x0e\x02\n\x05\x12\x04\x98\x02\r\x13\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\
    \x98\x02\x14\"\n\r\n\x05\x04\x0e\x02\n\x03\x12\x04\x98\x02%'\nR\n\x04\
    \x04\x0e\x02\x0b\x12\x04\x9b\x02\x042\x1aD\x20Used\x20in\x20dark\x20deco\
    ys\x20to\x20signal\x20which\x20dark\x20decoy\x20it\x20will\x20connect\
    \x20to.\n\n\r\n\x05\x04\x0e\x02\x0b\x04\x12\x04\x9b\x02\x04\x0c\n\r\n\
    \x05\x04\x0e\x02\x0b\x05\x12\x04\x9b\x02\r\x13\n\r\n\x05\x04\x0e\x02\x0b\
    \x01\x12\x04\x9b\x02\x14,\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\x9b\x02/\
    1\nR\n\x04\x04\x0e\x02\x0c\x12\x04\x9e\x02\x04\"\x1aD\x20Used\x20to\x20i\
    ndicate\x20to\x20server\x20if\x20client\x20is\x20registering\x20v4,\x20v\
    6\x20or\x20both\n\n\r\n\x05\x04\x0e\x02\x0c\x04\x12\x04\x9e\x02\x04\x0c\
    \n\r\n\x05\x04\x0e\x02\x0c\x05\x12\x04\x9e\x02\r\x11\n\r\n\x05\x04\x0e\
    \x02\x0c\x01\x12\x04\x9e\x02\x12\x1c\n\r\n\x05\x04\x0e\x02\x0c\x03\x12\
    \x04\x9e\x02\x1f!\n\x0c\n\x04\x04\x0e\x02\r\x12\x04\x9f\x02\x04\"\n\r\n\
    \x05\x04\x0e\x02\r\x04\x12\x04\x9f\x02\x04\x0c\n\r\n\x05\x04\x0e\x02\r\
    \x05\x12\x04\x9f\x02\r\x11\n\r\n\x05\x04\x0e\x02\r\x01\x12\x04\x9f\x02\
    \x12\x1c\n\r\n\x05\x04\x0e\x02\r\x03\x12\x04\x9f\x02\x1f!\nD\n\x04\x04\
    \x0e\x02\x0e\x12\x04\xa2\x02\x04*\x1a6\x20A\x20collection\x20of\x20optio\
    nal\x20flags\x20for\x20the\x20registration.\n\n\r\n\x05\x04\x0e\x02\x0e\
    \x04\x12\x04\xa2\x02\x04\x0c\n\r\n\x05\x04\x0e\x02\x0e\x06\x12\x04\xa2\
    \x02\r\x1e\n\r\n\x05\x04\x0e\x02\x0e\x01\x12\x04\xa2\x02\x1f$\n\r\n\x05\
    \x04\x0e\x02\x0e\x03\x12\x04\xa2\x02')\nq\n\x04\x04\x0e\x02\x0f\x12\x04\
    \xa6\x02\x04-\x1ac\x20Transport\x20Extensions\n\x20TODO(jmwample)\x20-\
    \x20move\x20to\x20WebRTC\x20specific\x20transport\x20params\x20protobuf\
    \x20message.\n\n\r\n\x05\x04\x0e\x02\x0f\x04\x12\x04\xa6\x02\x04\x0c\n\r\
    \n\x05\x04\x0e\x02\x0f\x06\x12\x04\xa6\x02\r\x19\n\r\n\x05\x04\x0e\x02\
    \x0f\x01\x12\x04\xa6\x02\x1a'\n\r\n\x05\x04\x0e\x02\x0f\x03\x12\x04\xa6\
    \x02*,\nG\n\x04\x04\x0e\x02\x10\x12\x04\xa9\x02\x04!\x1a9\x20Random-size\
    d\x20junk\x20to\x20defeat\x20packet\x20size\x20fingerprinting.\n\n\r\n\
    \x05\x04\x0e\x02\x10\x04\x12\x04\xa9\x02\x04\x0c\n\r\n\x05\x04\x0e\x02\
    \x10\x05\x12\x04\xa9\x02\r\x12\n\r\n\x05\x04\x0e\x02\x10\x01\x12\x04\xa9\
    \x02\x13\x1a\n\r\n\x05\x04\x0e\x02\x10\x03\x12\x04\xa9\x02\x1d\x20\n\x0c\
    \n\x02\x04\x0f\x12\x06\xad\x02\0\xbf\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\xad\x02\x08\x1d\n!\n\x04\x04\x0f\x02\0\x12\x04\xaf\x02\x04!\x1a\x13\
    \x20Prefix\x20Identifier\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xaf\x02\
    \x04\x0c\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xaf\x02\r\x12\n\r\n\x05\x04\
    \x0f\x02\0\x01\x12\x04\xaf\x02\x13\x1c\n\r\n\x05\x04\x0f\x02\0\x03\x12\
    \x04\xaf\x02\x1f\x20\n\xc4\x01\n\x04\x04\x0f\x02\x01\x12\x04\xb3\x02\x04\
    \x1e\x1a\xb5\x01\x20Prefix\x20bytes\x20(optional\x20-\x20usually\x20sent\
    \x20from\x20station\x20to\x20client\x20as\x20override\x20if\x20allowed\
    \x20by\x20C2S)\n\x20as\x20the\x20station\x20cannot\x20take\x20this\x20in\
    to\x20account\x20when\x20attempting\x20to\x20identify\x20a\x20connection\
    .\n\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xb3\x02\x04\x0c\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\xb3\x02\r\x12\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xb3\x02\x13\x19\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xb3\x02\x1c\
    \x1d\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xb4\x02\x04+\n\r\n\x05\x04\x0f\
    \x02\x02\x04\x12\x04\xb4\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\x02\x05\x12\
    \x04\xb4\x02\r\x12\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xb4\x02\x13&\n\
    \r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xb4\x02)*\n\xed\x02\n\x04\x04\x0f\
    \x02\x03\x12\x04\xbe\x02\x04*\x1a\xbc\x01\x20Indicates\x20whether\x20the\
    \x20client\x20has\x20elected\x20to\x20use\x20destination\x20port\x20rand\
    omization.\x20Should\x20be\n\x20checked\x20against\x20selected\x20transp\
    ort\x20to\x20ensure\x20that\x20destination\x20port\x20randomization\x20i\
    s\n\x20supported.\n2\x9f\x01\x20//\x20potential\x20future\x20fields\n\
    \x20obfuscator\x20ID\n\x20tagEncoder\x20ID\x20(&params?,\x20e.g.\x20form\
    at-base64\x20/\x20padding)\n\x20streamEncoder\x20ID\x20(&params?,\x20e.g\
    .\x20foramat-base64\x20/\x20padding)\n\n\r\n\x05\x04\x0f\x02\x03\x04\x12\
    \x04\xbe\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\xbe\x02\r\x11\
    \n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xbe\x02\x12$\n\r\n\x05\x04\x0f\
    \x02\x03\x03\x12\x04\xbe\x02')\n\x0c\n\x02\x04\x10\x12\x06\xc1\x02\0\xc6\
    \x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xc1\x02\x08\x1e\n\xcb\x01\n\x04\
    \x04\x10\x02\0\x12\x04\xc5\x02\x04*\x1a\xbc\x01\x20Indicates\x20whether\
    \x20the\x20client\x20has\x20elected\x20to\x20use\x20destination\x20port\
    \x20randomization.\x20Should\x20be\n\x20checked\x20against\x20selected\
    \x20transport\x20to\x20ensure\x20that\x20destination\x20port\x20randomiz\
    ation\x20is\n\x20supported.\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xc5\
    \x02\x04\x0c\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xc5\x02\r\x11\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xc5\x02\x12$\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xc5\x02')\n\x0c\n\x02\x05\x06\x12\x06\xc8\x02\0\xd0\x02\x01\n\x0b\n\
    \x03\x05\x06\x01\x12\x04\xc8\x02\x05\x17\n\x0c\n\x04\x05\x06\x02\0\x12\
    \x04\xc9\x02\x02\x12\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\xc9\x02\x02\r\n\
    \r\n\x05\x05\x06\x02\0\x02\x12\x04\xc9\x02\x10\x11\n\x0c\n\x04\x05\x06\
    \x02\x01\x12\x04\xca\x02\x08\x15\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\
    \xca\x02\x08\x10\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\xca\x02\x13\x14\n\
    \x0c\n\x04\x05\x06\x02\x02\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x05\x06\x02\
    \x02\x01\x12\x04\xcb\x02\x08\x0b\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\
    \xcb\x02\x0e\x0f\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\xcc\x02\x02\x16\n\r\
    \n\x05\x05\x06\x02\x03\x01\x12\x04\xcc\x02\x02\x11\n\r\n\x05\x05\x06\x02\
    \x03\x02\x12\x04\xcc\x02\x14\x15\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\xcd\
    \x02\x02\x17\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\xcd\x02\x02\x12\n\r\n\
    \x05\x05\x06\x02\x04\x02\x12\x04\xcd\x02\x15\x16\n\x0c\n\x04\x05\x06\x02\
    \x05\x12\x04\xce\x02\x02\n\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\xce\x02\
    \x02\x05\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xce\x02\x08\t\n\x0c\n\x04\
    \x05\x06\x02\x06\x12\x04\xcf\x02\x02\x17\n\r\n\x05\x05\x06\x02\x06\x01\
    \x12\x04\xcf\x02\x02\x12\n\r\n\x05\x05\x06\x02\x06\x02\x12\x04\xcf\x02\
    \x15\x16\n\x0c\n\x02\x04\x11\x12\x06\xd2\x02\0\xec\x02\x01\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\xd2\x02\x08\x12\n\x0c\n\x04\x04\x11\x02\0\x12\x04\
    \xd3\x02\x02#\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xd3\x02\x02\n\n\r\n\
    \x05\x04\x11\x02\0\x05\x12\x04\xd3\x02\x0b\x10\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xd3\x02\x11\x1e\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xd3\x02\
    !\"\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xd4\x02\x024\n\r\n\x05\x04\x11\
    \x02\x01\x04\x12\x04\xd4\x02\x02\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\
    \xd4\x02\x0b\x1a\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xd4\x02\x1b/\n\r\
    \n\x05\x04\x11\x02\x01\x03\x12\x04\xd4\x0223\n\x0c\n\x04\x04\x11\x02\x02\
    \x12\x04\xd5\x02\x026\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xd5\x02\x02\
    \n\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xd5\x02\x0b\x1d\n\r\n\x05\x04\
    \x11\x02\x02\x01\x12\x04\xd5\x02\x1e1\n\r\n\x05\x04\x11\x02\x02\x03\x12\
    \x04\xd5\x0245\nC\n\x04\x04\x11\x02\x03\x12\x04\xd8\x02\x02*\x1a5\x20cli\
    ent\x20source\x20address\x20when\x20receiving\x20a\x20registration\n\n\r\
    \n\x05\x04\x11\x02\x03\x04\x12\x04\xd8\x02\x02\n\n\r\n\x05\x04\x11\x02\
    \x03\x05\x12\x04\xd8\x02\x0b\x10\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\
    \xd8\x02\x11%\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xd8\x02()\nH\n\x04\
    \x04\x11\x02\x04\x12\x04\xdb\x02\x02#\x1a:\x20Decoy\x20address\x20used\
    \x20when\x20registering\x20over\x20Decoy\x20registrar\n\n\r\n\x05\x04\
    \x11\x02\x04\x04\x12\x04\xdb\x02\x02\n\n\r\n\x05\x04\x11\x02\x04\x05\x12\
    \x04\xdb\x02\x0b\x10\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xdb\x02\x11\
    \x1e\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xdb\x02!\"\n\xeb\x05\n\x04\
    \x04\x11\x02\x05\x12\x04\xe7\x02\x02:\x1a\xdc\x05\x20The\x20next\x20thre\
    e\x20fields\x20allow\x20an\x20independent\x20registrar\x20(trusted\x20by\
    \x20a\x20station\x20w/\x20a\x20zmq\x20keypair)\x20to\n\x20share\x20the\
    \x20registration\x20overrides\x20that\x20it\x20assigned\x20to\x20the\x20\
    client\x20with\x20the\x20station(s).\n\x20Registration\x20Respose\x20is\
    \x20here\x20to\x20allow\x20a\x20parsed\x20object\x20with\x20direct\x20ac\
    cess\x20to\x20the\x20fields\x20within.\n\x20RegRespBytes\x20provides\x20\
    a\x20serialized\x20verion\x20of\x20the\x20Registration\x20response\x20so\
    \x20that\x20the\x20signature\x20of\n\x20the\x20Bidirectional\x20registra\
    r\x20can\x20be\x20validated\x20before\x20a\x20station\x20applies\x20any\
    \x20overrides\x20present\x20in\n\x20the\x20Registration\x20Response.\n\n\
    \x20If\x20you\x20are\x20reading\x20this\x20in\x20the\x20future\x20and\
    \x20you\x20want\x20to\x20extend\x20the\x20functionality\x20here\x20it\
    \x20might\n\x20make\x20sense\x20to\x20make\x20the\x20RegistrationRespons\
    e\x20that\x20is\x20sent\x20to\x20the\x20client\x20a\x20distinct\x20messa\
    ge\x20from\n\x20the\x20one\x20that\x20gets\x20sent\x20to\x20the\x20stati\
    ons.\n\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xe7\x02\x02\n\n\r\n\x05\x04\
    \x11\x02\x05\x06\x12\x04\xe7\x02\x0b\x1f\n\r\n\x05\x04\x11\x02\x05\x01\
    \x12\x04\xe7\x02\x205\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xe7\x0289\n\
    \x0c\n\x04\x04\x11\x02\x06\x12\x04\xe8\x02\x02\"\n\r\n\x05\x04\x11\x02\
    \x06\x04\x12\x04\xe8\x02\x02\n\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xe8\
    \x02\x0b\x10\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xe8\x02\x11\x1d\n\r\n\
    \x05\x04\x11\x02\x06\x03\x12\x04\xe8\x02\x20!\n\x0c\n\x04\x04\x11\x02\
    \x07\x12\x04\xe9\x02\x02'\n\r\n\x05\x04\x11\x02\x07\x04\x12\x04\xe9\x02\
    \x02\n\n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xe9\x02\x0b\x10\n\r\n\x05\
    \x04\x11\x02\x07\x01\x12\x04\xe9\x02\x11!\n\r\n\x05\x04\x11\x02\x07\x03\
    \x12\x04\xe9\x02$&\n\x0c\n\x02\x04\x12\x12\x06\xee\x02\0\xfa\x02\x01\n\
    \x0b\n\x03\x04\x12\x01\x12\x04\xee\x02\x08\x14\n9\n\x04\x04\x12\x02\0\
    \x12\x04\xef\x02\x04.\"+\x20how\x20many\x20decoys\x20were\x20tried\x20be\
    fore\x20success\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xef\x02\x04\x0c\n\
    \r\n\x05\x04\x12\x02\0\x05\x12\x04\xef\x02\r\x13\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\xef\x02\x14(\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xef\x02+-\
    \nm\n\x04\x04\x12\x02\x01\x12\x04\xf4\x02\x04/\x1a\x1e\x20Applicable\x20\
    to\x20whole\x20session:\n\"\x1a\x20includes\x20failed\x20attempts\n2#\
    \x20Timings\x20below\x20are\x20in\x20milliseconds\n\n\r\n\x05\x04\x12\
    \x02\x01\x04\x12\x04\xf4\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x01\x05\x12\
    \x04\xf4\x02\r\x13\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xf4\x02\x14)\n\
    \r\n\x05\x04\x12\x02\x01\x03\x12\x04\xf4\x02,.\nR\n\x04\x04\x12\x02\x02\
    \x12\x04\xf7\x02\x04(\x1a\x1f\x20Last\x20(i.e.\x20successful)\x20decoy:\
    \n\"#\x20measured\x20during\x20initial\x20handshake\n\n\r\n\x05\x04\x12\
    \x02\x02\x04\x12\x04\xf7\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x02\x05\x12\
    \x04\xf7\x02\r\x13\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xf7\x02\x14\"\n\
    \r\n\x05\x04\x12\x02\x02\x03\x12\x04\xf7\x02%'\n%\n\x04\x04\x12\x02\x03\
    \x12\x04\xf8\x02\x04&\"\x17\x20includes\x20tcp\x20to\x20decoy\n\n\r\n\
    \x05\x04\x12\x02\x03\x04\x12\x04\xf8\x02\x04\x0c\n\r\n\x05\x04\x12\x02\
    \x03\x05\x12\x04\xf8\x02\r\x13\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xf8\
    \x02\x14\x20\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xf8\x02#%\nB\n\x04\
    \x04\x12\x02\x04\x12\x04\xf9\x02\x04&\"4\x20measured\x20when\x20establis\
    hing\x20tcp\x20connection\x20to\x20decot\n\n\r\n\x05\x04\x12\x02\x04\x04\
    \x12\x04\xf9\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xf9\x02\r\
    \x13\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xf9\x02\x14\x20\n\r\n\x05\x04\
    \x12\x02\x04\x03\x12\x04\xf9\x02#%\n\x0c\n\x02\x05\x07\x12\x06\xfc\x02\0\
    \x81\x03\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\xfc\x02\x05\x16\n\x0c\n\x04\
    \x05\x07\x02\0\x12\x04\xfd\x02\x04\x10\n\r\n\x05\x05\x07\x02\0\x01\x12\
    \x04\xfd\x02\x04\x0b\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\xfd\x02\x0e\x0f\
    \n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xfe\x02\x04\x0c\n\r\n\x05\x05\x07\
    \x02\x01\x01\x12\x04\xfe\x02\x04\x07\n\r\n\x05\x05\x07\x02\x01\x02\x12\
    \x04\xfe\x02\n\x0b\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\xff\x02\x04\x0f\n\
    \r\n\x05\x05\x07\x02\x02\x01\x12\x04\xff\x02\x04\n\n\r\n\x05\x05\x07\x02\
    \x02\x02\x12\x04\xff\x02\r\x0e\n\x0c\n\x04\x05\x07\x02\x03\x12\x04\x80\
    \x03\x04\x0e\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\x80\x03\x04\t\n\r\n\
    \x05\x05\x07\x02\x03\x02\x12\x04\x80\x03\x0c\r\n\x0c\n\x02\x05\x08\x12\
    \x06\x83\x03\0\x87\x03\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\x83\x03\x05\
    \x0c\n\x0c\n\x04\x05\x08\x02\0\x12\x04\x84\x03\x04\x0c\n\r\n\x05\x05\x08\
    \x02\0\x01\x12\x04\x84\x03\x04\x07\n\r\n\x05\x05\x08\x02\0\x02\x12\x04\
    \x84\x03\n\x0b\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\x85\x03\x04\x0c\n\r\n\
    \x05\x05\x08\x02\x01\x01\x12\x04\x85\x03\x04\x07\n\r\n\x05\x05\x08\x02\
    \x01\x02\x12\x04\x85\x03\n\x0b\n\x0c\n\x04\x05\x08\x02\x02\x12\x04\x86\
    \x03\x04\x0c\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\x86\x03\x04\x07\n\r\n\
    \x05\x05\x08\x02\x02\x02\x12\x04\x86\x03\n\x0b\n\x0c\n\x02\x04\x13\x12\
    \x06\x89\x03\0\x94\x03\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\x89\x03\x08\
    \x19\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x8a\x03\x04#\n\r\n\x05\x04\x13\
    \x02\0\x04\x12\x04\x8a\x03\x04\x0c\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\
    \x8a\x03\r\x13\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x8a\x03\x14\x1e\n\r\n\
    \x05\x04\x13\x02\0\x03\x12\x04\x8a\x03!\"\n\x0c\n\x04\x04\x13\x02\x01\
    \x12\x04\x8b\x03\x04\"\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\x8b\x03\x04\
    \x0c\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\x8b\x03\r\x13\n\r\n\x05\x04\
    \x13\x02\x01\x01\x12\x04\x8b\x03\x14\x1d\n\r\n\x05\x04\x13\x02\x01\x03\
    \x12\x04\x8b\x03\x20!\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x8d\x03\x04#\n\
    \r\n\x05\x04\x13\x02\x02\x04\x12\x04\x8d\x03\x04\x0c\n\r\n\x05\x04\x13\
    \x02\x02\x05\x12\x04\x8d\x03\r\x13\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\
    \x8d\x03\x14\x1e\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x8d\x03!\"\n\x0c\
    \n\x04\x04\x13\x02\x03\x12\x04\x8f\x03\x04-\n\r\n\x05\x04\x13\x02\x03\
    \x04\x12\x04\x8f\x03\x04\x0c\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\x8f\
    \x03\r\x1e\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\x8f\x03\x1f(\n\r\n\x05\
    \x04\x13\x02\x03\x03\x12\x04\x8f\x03+,\n\x0c\n\x04\x04\x13\x02\x04\x12\
    \x04\x91\x03\x04\"\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\x91\x03\x04\x0c\
    \n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\x91\x03\r\x13\n\r\n\x05\x04\x13\
    \x02\x04\x01\x12\x04\x91\x03\x14\x1c\n\r\n\x05\x04\x13\x02\x04\x03\x12\
    \x04\x91\x03\x1f!\n\x0c\n\x04\x04\x13\x02\x05\x12\x04\x92\x03\x04\"\n\r\
    \n\x05\x04\x13\x02\x05\x04\x12\x04\x92\x03\x04\x0c\n\r\n\x05\x04\x13\x02\
    \x05\x05\x12\x04\x92\x03\r\x13\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\x92\
    \x03\x14\x1c\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\x92\x03\x1f!\n\x0c\n\
    \x04\x04\x13\x02\x06\x12\x04\x93\x03\x04\x20\n\r\n\x05\x04\x13\x02\x06\
    \x04\x12\x04\x93\x03\x04\x0c\n\r\n\x05\x04\x13\x02\x06\x06\x12\x04\x93\
    \x03\r\x14\n\r\n\x05\x04\x13\x02\x06\x01\x12\x04\x93\x03\x15\x1a\n\r\n\
    \x05\x04\x13\x02\x06\x03\x12\x04\x93\x03\x1d\x1f\nT\n\x02\x04\x14\x12\
    \x06\x97\x03\0\xaf\x03\x01\x1aF\x20Adding\x20message\x20response\x20from\
    \x20Station\x20to\x20Client\x20for\x20bidirectional\x20API\n\n\x0b\n\x03\
    \x04\x14\x01\x12\x04\x97\x03\x08\x1c\n\x0c\n\x04\x04\x14\x02\0\x12\x04\
    \x98\x03\x02\x20\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x98\x03\x02\n\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\x98\x03\x0b\x12\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\x98\x03\x13\x1b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x98\x03\
    \x1e\x1f\n?\n\x04\x04\x14\x02\x01\x12\x04\x9a\x03\x02\x1e\x1a1\x20The\
    \x20128-bit\x20ipv6\x20address,\x20in\x20network\x20byte\x20order\n\n\r\
    \n\x05\x04\x14\x02\x01\x04\x12\x04\x9a\x03\x02\n\n\r\n\x05\x04\x14\x02\
    \x01\x05\x12\x04\x9a\x03\x0b\x10\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\
    \x9a\x03\x11\x19\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x9a\x03\x1c\x1d\n\
    ,\n\x04\x04\x14\x02\x02\x12\x04\x9d\x03\x02\x1f\x1a\x1e\x20Respond\x20wi\
    th\x20randomized\x20port\n\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\x9d\x03\
    \x02\n\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\x9d\x03\x0b\x11\n\r\n\x05\
    \x04\x14\x02\x02\x01\x12\x04\x9d\x03\x12\x1a\n\r\n\x05\x04\x14\x02\x02\
    \x03\x12\x04\x9d\x03\x1d\x1e\nd\n\x04\x04\x14\x02\x03\x12\x04\xa1\x03\
    \x02\"\x1aV\x20Future:\x20station\x20provides\x20client\x20with\x20secre\
    t,\x20want\x20chanel\x20present\n\x20Leave\x20null\x20for\x20now\n\n\r\n\
    \x05\x04\x14\x02\x03\x04\x12\x04\xa1\x03\x02\n\n\r\n\x05\x04\x14\x02\x03\
    \x05\x12\x04\xa1\x03\x0b\x10\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xa1\
    \x03\x11\x1d\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xa1\x03\x20!\nA\n\x04\
    \x04\x14\x02\x04\x12\x04\xa4\x03\x02\x1c\x1a3\x20If\x20registration\x20w\
    rong,\x20populate\x20this\x20error\x20string\n\n\r\n\x05\x04\x14\x02\x04\
    \x04\x12\x04\xa4\x03\x02\n\n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\xa4\x03\
    \x0b\x11\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xa4\x03\x12\x17\n\r\n\x05\
    \x04\x14\x02\x04\x03\x12\x04\xa4\x03\x1a\x1b\n+\n\x04\x04\x14\x02\x05\
    \x12\x04\xa7\x03\x02%\x1a\x1d\x20ClientConf\x20field\x20(optional)\n\n\r\
    \n\x05\x04\x14\x02\x05\x04\x12\x04\xa7\x03\x02\n\n\r\n\x05\x04\x14\x02\
    \x05\x06\x12\x04\xa7\x03\x0b\x15\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\
    \xa7\x03\x16\x20\n\r\n\x05\x04\x14\x02\x05\x03\x12\x04\xa7\x03#$\nJ\n\
    \x04\x04\x14\x02\x06\x12\x04\xaa\x03\x025\x1a<\x20Transport\x20Params\
    \x20to\x20if\x20`allow_registrar_overrides`\x20is\x20set.\n\n\r\n\x05\
    \x04\x14\x02\x06\x04\x12\x04\xaa\x03\x02\n\n\r\n\x05\x04\x14\x02\x06\x06\
    \x12\x04\xaa\x03\x0b\x1e\n\r\n\x05\x04\x14\x02\x06\x01\x12\x04\xaa\x03\
    \x1f/\n\r\n\x05\x04\x14\x02\x06\x03\x12\x04\xaa\x0324\n\x9c\x01\n\x04\
    \x04\x14\x02\x07\x12\x04\xae\x03\x020\x1a\x8d\x01\x20PhantomsSupportPort\
    Rand\x20is\x20a\x20flag\x20that\x20indicates\x20whether\x20the\x20select\
    ed\x20phantoms\x20are\x20able\x20to\n\x20handle\x20phantom\x20connection\
    s\x20to\x20randomized\x20ports.\n\n\r\n\x05\x04\x14\x02\x07\x04\x12\x04\
    \xae\x03\x02\n\n\r\n\x05\x04\x14\x02\x07\x05\x12\x04\xae\x03\x0b\x0f\n\r\
    \n\x05\x04\x14\x02\x07\x01\x12\x04\xae\x03\x10*\n\r\n\x05\x04\x14\x02\
    \x07\x03\x12\x04\xae\x03-/\n!\n\x02\x04\x15\x12\x06\xb2\x03\0\xb6\x03\
    \x01\x1a\x13\x20response\x20from\x20dns\n\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xb2\x03\x08\x13\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xb3\x03\x04\x1e\n\
    \r\n\x05\x04\x15\x02\0\x04\x12\x04\xb3\x03\x04\x0c\n\r\n\x05\x04\x15\x02\
    \0\x05\x12\x04\xb3\x03\r\x11\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xb3\x03\
    \x12\x19\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xb3\x03\x1c\x1d\n\x0c\n\x04\
    \x04\x15\x02\x01\x12\x04\xb4\x03\x04*\n\r\n\x05\x04\x15\x02\x01\x04\x12\
    \x04\xb4\x03\x04\x0c\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xb4\x03\r\x11\
    \n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xb4\x03\x12%\n\r\n\x05\x04\x15\
    \x02\x01\x03\x12\x04\xb4\x03()\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xb5\
    \x03\x04=\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xb5\x03\x04\x0c\n\r\n\
    \x05\x04\x15\x02\x02\x06\x12\x04\xb5\x03\r!\n\r\n\x05\x04\x15\x02\x02\
    \x01\x12\x04\xb5\x03\"8\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xb5\x03;<\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(22);
            messages.push(PubKey::generated_message_descriptor_data());
            messages.push(TLSDecoySpec::generated_message_descriptor_data());
            messages.push(ClientConf::generated_message_descriptor_data());
            messages.push(DnsRegConf::generated_message_descriptor_data());
            messages.push(DecoyList::generated_message_descriptor_data());
            messages.push(PhantomSubnetsList::generated_message_descriptor_data());
            messages.push(PhantomSubnets::generated_message_descriptor_data());
            messages.push(WebRTCICECandidate::generated_message_descriptor_data());
            messages.push(WebRTCSDP::generated_message_descriptor_data());
            messages.push(WebRTCSignal::generated_message_descriptor_data());
            messages.push(Addr::generated_message_descriptor_data());
            messages.push(DTLSTransportParams::generated_message_descriptor_data());
            messages.push(StationToClient::generated_message_descriptor_data());
            messages.push(RegistrationFlags::generated_message_descriptor_data());
            messages.push(ClientToStation::generated_message_descriptor_data());
            messages.push(PrefixTransportParams::generated_message_descriptor_data());
            messages.push(GenericTransportParams::generated_message_descriptor_data());
            messages.push(C2SWrapper::generated_message_descriptor_data());
            messages.push(SessionStats::generated_message_descriptor_data());
            messages.push(StationToDetector::generated_message_descriptor_data());
            messages.push(RegistrationResponse::generated_message_descriptor_data());
            messages.push(DnsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(KeyType::generated_enum_descriptor_data());
            enums.push(DnsRegMethod::generated_enum_descriptor_data());
            enums.push(C2S_Transition::generated_enum_descriptor_data());
            enums.push(S2C_Transition::generated_enum_descriptor_data());
            enums.push(ErrorReasonS2C::generated_enum_descriptor_data());
            enums.push(TransportType::generated_enum_descriptor_data());
            enums.push(RegistrationSource::generated_enum_descriptor_data());
            enums.push(StationOperations::generated_enum_descriptor_data());
            enums.push(IPProto::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
