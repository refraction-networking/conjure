// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `signalling.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.PubKey)
pub struct PubKey {
    // message fields
    ///  A public key, as used by the station.
    // @@protoc_insertion_point(field:tapdance.PubKey.key)
    pub key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:tapdance.PubKey.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<KeyType>>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.PubKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubKey {
    fn default() -> &'a PubKey {
        <PubKey as ::protobuf::Message>::default_instance()
    }
}

impl PubKey {
    pub fn new() -> PubKey {
        ::std::default::Default::default()
    }

    // optional bytes key = 1;

    pub fn key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.KeyType type = 2;

    pub fn type_(&self) -> KeyType {
        match self.type_ {
            Some(e) => e.enum_value_or(KeyType::AES_GCM_128),
            None => KeyType::AES_GCM_128,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: KeyType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &PubKey| { &m.key },
            |m: &mut PubKey| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PubKey| { &m.type_ },
            |m: &mut PubKey| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubKey>(
            "PubKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubKey {
    const NAME: &'static str = "PubKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubKey {
        PubKey::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubKey {
        static instance: PubKey = PubKey {
            key: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PubKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.TLSDecoySpec)
pub struct TLSDecoySpec {
    // message fields
    ///  The hostname/SNI to use for this host
    ///
    ///  The hostname is the only required field, although other
    ///  fields are expected to be present in most cases.
    // @@protoc_insertion_point(field:tapdance.TLSDecoySpec.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    ///  The 32-bit ipv4 address, in network byte order
    ///
    ///  If the IPv4 address is absent, then it may be resolved via
    ///  DNS by the client, or the client may discard this decoy spec
    ///  if local DNS is untrusted, or the service may be multihomed.
    // @@protoc_insertion_point(field:tapdance.TLSDecoySpec.ipv4addr)
    pub ipv4addr: ::std::option::Option<u32>,
    ///  The 128-bit ipv6 address, in network byte order
    // @@protoc_insertion_point(field:tapdance.TLSDecoySpec.ipv6addr)
    pub ipv6addr: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  The Tapdance station public key to use when contacting this
    ///  decoy
    ///
    ///  If omitted, the default station public key (if any) is used.
    // @@protoc_insertion_point(field:tapdance.TLSDecoySpec.pubkey)
    pub pubkey: ::protobuf::MessageField<PubKey>,
    ///  The maximum duration, in milliseconds, to maintain an open
    ///  connection to this decoy (because the decoy may close the
    ///  connection itself after this length of time)
    ///
    ///  If omitted, a default of 30,000 milliseconds is assumed.
    // @@protoc_insertion_point(field:tapdance.TLSDecoySpec.timeout)
    pub timeout: ::std::option::Option<u32>,
    ///  The maximum TCP window size to attempt to use for this decoy.
    ///
    ///  If omitted, a default of 15360 is assumed.
    ///
    ///  TODO: the default is based on the current heuristic of only
    ///  using decoys that permit windows of 15KB or larger.  If this
    ///  heuristic changes, then this default doesn't make sense.
    // @@protoc_insertion_point(field:tapdance.TLSDecoySpec.tcpwin)
    pub tcpwin: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.TLSDecoySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TLSDecoySpec {
    fn default() -> &'a TLSDecoySpec {
        <TLSDecoySpec as ::protobuf::Message>::default_instance()
    }
}

impl TLSDecoySpec {
    pub fn new() -> TLSDecoySpec {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 ipv4addr = 2;

    pub fn ipv4addr(&self) -> u32 {
        self.ipv4addr.unwrap_or(0)
    }

    pub fn clear_ipv4addr(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
    }

    pub fn has_ipv4addr(&self) -> bool {
        self.ipv4addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4addr(&mut self, v: u32) {
        self.ipv4addr = ::std::option::Option::Some(v);
    }

    // optional bytes ipv6addr = 6;

    pub fn ipv6addr(&self) -> &[u8] {
        match self.ipv6addr.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ipv6addr(&mut self) {
        self.ipv6addr = ::std::option::Option::None;
    }

    pub fn has_ipv6addr(&self) -> bool {
        self.ipv6addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ipv6addr.is_none() {
            self.ipv6addr = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ipv6addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6addr(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6addr.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 4;

    pub fn timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }

    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }

    // optional uint32 tcpwin = 5;

    pub fn tcpwin(&self) -> u32 {
        self.tcpwin.unwrap_or(0)
    }

    pub fn clear_tcpwin(&mut self) {
        self.tcpwin = ::std::option::Option::None;
    }

    pub fn has_tcpwin(&self) -> bool {
        self.tcpwin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpwin(&mut self, v: u32) {
        self.tcpwin = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &TLSDecoySpec| { &m.hostname },
            |m: &mut TLSDecoySpec| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv4addr",
            |m: &TLSDecoySpec| { &m.ipv4addr },
            |m: &mut TLSDecoySpec| { &mut m.ipv4addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv6addr",
            |m: &TLSDecoySpec| { &m.ipv6addr },
            |m: &mut TLSDecoySpec| { &mut m.ipv6addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubKey>(
            "pubkey",
            |m: &TLSDecoySpec| { &m.pubkey },
            |m: &mut TLSDecoySpec| { &mut m.pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout",
            |m: &TLSDecoySpec| { &m.timeout },
            |m: &mut TLSDecoySpec| { &mut m.timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcpwin",
            |m: &TLSDecoySpec| { &m.tcpwin },
            |m: &mut TLSDecoySpec| { &mut m.tcpwin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TLSDecoySpec>(
            "TLSDecoySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TLSDecoySpec {
    const NAME: &'static str = "TLSDecoySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.ipv4addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                50 => {
                    self.ipv6addr = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pubkey)?;
                },
                32 => {
                    self.timeout = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tcpwin = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ipv4addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tcpwin {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ipv4addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.pubkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tcpwin {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TLSDecoySpec {
        TLSDecoySpec::new()
    }

    fn clear(&mut self) {
        self.hostname = ::std::option::Option::None;
        self.ipv4addr = ::std::option::Option::None;
        self.ipv6addr = ::std::option::Option::None;
        self.pubkey.clear();
        self.timeout = ::std::option::Option::None;
        self.tcpwin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TLSDecoySpec {
        static instance: TLSDecoySpec = TLSDecoySpec {
            hostname: ::std::option::Option::None,
            ipv4addr: ::std::option::Option::None,
            ipv6addr: ::std::option::Option::None,
            pubkey: ::protobuf::MessageField::none(),
            timeout: ::std::option::Option::None,
            tcpwin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TLSDecoySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TLSDecoySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TLSDecoySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TLSDecoySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.ClientConf)
pub struct ClientConf {
    // message fields
    // @@protoc_insertion_point(field:tapdance.ClientConf.decoy_list)
    pub decoy_list: ::protobuf::MessageField<DecoyList>,
    // @@protoc_insertion_point(field:tapdance.ClientConf.generation)
    pub generation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.ClientConf.default_pubkey)
    pub default_pubkey: ::protobuf::MessageField<PubKey>,
    // @@protoc_insertion_point(field:tapdance.ClientConf.phantom_subnets_list)
    pub phantom_subnets_list: ::protobuf::MessageField<PhantomSubnetsList>,
    // @@protoc_insertion_point(field:tapdance.ClientConf.conjure_pubkey)
    pub conjure_pubkey: ::protobuf::MessageField<PubKey>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.ClientConf.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientConf {
    fn default() -> &'a ClientConf {
        <ClientConf as ::protobuf::Message>::default_instance()
    }
}

impl ClientConf {
    pub fn new() -> ClientConf {
        ::std::default::Default::default()
    }

    // optional uint32 generation = 2;

    pub fn generation(&self) -> u32 {
        self.generation.unwrap_or(0)
    }

    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: u32) {
        self.generation = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DecoyList>(
            "decoy_list",
            |m: &ClientConf| { &m.decoy_list },
            |m: &mut ClientConf| { &mut m.decoy_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generation",
            |m: &ClientConf| { &m.generation },
            |m: &mut ClientConf| { &mut m.generation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubKey>(
            "default_pubkey",
            |m: &ClientConf| { &m.default_pubkey },
            |m: &mut ClientConf| { &mut m.default_pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PhantomSubnetsList>(
            "phantom_subnets_list",
            |m: &ClientConf| { &m.phantom_subnets_list },
            |m: &mut ClientConf| { &mut m.phantom_subnets_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubKey>(
            "conjure_pubkey",
            |m: &ClientConf| { &m.conjure_pubkey },
            |m: &mut ClientConf| { &mut m.conjure_pubkey },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientConf>(
            "ClientConf",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientConf {
    const NAME: &'static str = "ClientConf";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.decoy_list)?;
                },
                16 => {
                    self.generation = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_pubkey)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.phantom_subnets_list)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.conjure_pubkey)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.decoy_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.default_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.phantom_subnets_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.conjure_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.decoy_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.generation {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.default_pubkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.phantom_subnets_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.conjure_pubkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientConf {
        ClientConf::new()
    }

    fn clear(&mut self) {
        self.decoy_list.clear();
        self.generation = ::std::option::Option::None;
        self.default_pubkey.clear();
        self.phantom_subnets_list.clear();
        self.conjure_pubkey.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientConf {
        static instance: ClientConf = ClientConf {
            decoy_list: ::protobuf::MessageField::none(),
            generation: ::std::option::Option::None,
            default_pubkey: ::protobuf::MessageField::none(),
            phantom_subnets_list: ::protobuf::MessageField::none(),
            conjure_pubkey: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientConf {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientConf").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientConf {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Configuration for DNS registrar
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.DnsRegConf)
pub struct DnsRegConf {
    // message fields
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.dns_reg_method)
    pub dns_reg_method: ::std::option::Option<::protobuf::EnumOrUnknown<DnsRegMethod>>,
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.udp_addr)
    pub udp_addr: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.dot_addr)
    pub dot_addr: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.doh_url)
    pub doh_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.pubkey)
    pub pubkey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.utls_distribution)
    pub utls_distribution: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.DnsRegConf.stun_server)
    pub stun_server: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.DnsRegConf.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DnsRegConf {
    fn default() -> &'a DnsRegConf {
        <DnsRegConf as ::protobuf::Message>::default_instance()
    }
}

impl DnsRegConf {
    pub fn new() -> DnsRegConf {
        ::std::default::Default::default()
    }

    // required .tapdance.DnsRegMethod dns_reg_method = 1;

    pub fn dns_reg_method(&self) -> DnsRegMethod {
        match self.dns_reg_method {
            Some(e) => e.enum_value_or(DnsRegMethod::UDP),
            None => DnsRegMethod::UDP,
        }
    }

    pub fn clear_dns_reg_method(&mut self) {
        self.dns_reg_method = ::std::option::Option::None;
    }

    pub fn has_dns_reg_method(&self) -> bool {
        self.dns_reg_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dns_reg_method(&mut self, v: DnsRegMethod) {
        self.dns_reg_method = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string udp_addr = 2;

    pub fn udp_addr(&self) -> &str {
        match self.udp_addr.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_udp_addr(&mut self) {
        self.udp_addr = ::std::option::Option::None;
    }

    pub fn has_udp_addr(&self) -> bool {
        self.udp_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_addr(&mut self, v: ::std::string::String) {
        self.udp_addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_udp_addr(&mut self) -> &mut ::std::string::String {
        if self.udp_addr.is_none() {
            self.udp_addr = ::std::option::Option::Some(::std::string::String::new());
        }
        self.udp_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_udp_addr(&mut self) -> ::std::string::String {
        self.udp_addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dot_addr = 3;

    pub fn dot_addr(&self) -> &str {
        match self.dot_addr.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dot_addr(&mut self) {
        self.dot_addr = ::std::option::Option::None;
    }

    pub fn has_dot_addr(&self) -> bool {
        self.dot_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dot_addr(&mut self, v: ::std::string::String) {
        self.dot_addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dot_addr(&mut self) -> &mut ::std::string::String {
        if self.dot_addr.is_none() {
            self.dot_addr = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dot_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_dot_addr(&mut self) -> ::std::string::String {
        self.dot_addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doh_url = 4;

    pub fn doh_url(&self) -> &str {
        match self.doh_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doh_url(&mut self) {
        self.doh_url = ::std::option::Option::None;
    }

    pub fn has_doh_url(&self) -> bool {
        self.doh_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doh_url(&mut self, v: ::std::string::String) {
        self.doh_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doh_url(&mut self) -> &mut ::std::string::String {
        if self.doh_url.is_none() {
            self.doh_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doh_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_doh_url(&mut self) -> ::std::string::String {
        self.doh_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string domain = 5;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes pubkey = 6;

    pub fn pubkey(&self) -> &[u8] {
        match self.pubkey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pubkey(&mut self) {
        self.pubkey = ::std::option::Option::None;
    }

    pub fn has_pubkey(&self) -> bool {
        self.pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pubkey.is_none() {
            self.pubkey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        self.pubkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string utls_distribution = 7;

    pub fn utls_distribution(&self) -> &str {
        match self.utls_distribution.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_utls_distribution(&mut self) {
        self.utls_distribution = ::std::option::Option::None;
    }

    pub fn has_utls_distribution(&self) -> bool {
        self.utls_distribution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utls_distribution(&mut self, v: ::std::string::String) {
        self.utls_distribution = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utls_distribution(&mut self) -> &mut ::std::string::String {
        if self.utls_distribution.is_none() {
            self.utls_distribution = ::std::option::Option::Some(::std::string::String::new());
        }
        self.utls_distribution.as_mut().unwrap()
    }

    // Take field
    pub fn take_utls_distribution(&mut self) -> ::std::string::String {
        self.utls_distribution.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stun_server = 8;

    pub fn stun_server(&self) -> &str {
        match self.stun_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stun_server(&mut self) {
        self.stun_server = ::std::option::Option::None;
    }

    pub fn has_stun_server(&self) -> bool {
        self.stun_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_server(&mut self, v: ::std::string::String) {
        self.stun_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stun_server(&mut self) -> &mut ::std::string::String {
        if self.stun_server.is_none() {
            self.stun_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stun_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_stun_server(&mut self) -> ::std::string::String {
        self.stun_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dns_reg_method",
            |m: &DnsRegConf| { &m.dns_reg_method },
            |m: &mut DnsRegConf| { &mut m.dns_reg_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "udp_addr",
            |m: &DnsRegConf| { &m.udp_addr },
            |m: &mut DnsRegConf| { &mut m.udp_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dot_addr",
            |m: &DnsRegConf| { &m.dot_addr },
            |m: &mut DnsRegConf| { &mut m.dot_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "doh_url",
            |m: &DnsRegConf| { &m.doh_url },
            |m: &mut DnsRegConf| { &mut m.doh_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "domain",
            |m: &DnsRegConf| { &m.domain },
            |m: &mut DnsRegConf| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pubkey",
            |m: &DnsRegConf| { &m.pubkey },
            |m: &mut DnsRegConf| { &mut m.pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utls_distribution",
            |m: &DnsRegConf| { &m.utls_distribution },
            |m: &mut DnsRegConf| { &mut m.utls_distribution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stun_server",
            |m: &DnsRegConf| { &m.stun_server },
            |m: &mut DnsRegConf| { &mut m.stun_server },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DnsRegConf>(
            "DnsRegConf",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DnsRegConf {
    const NAME: &'static str = "DnsRegConf";

    fn is_initialized(&self) -> bool {
        if self.dns_reg_method.is_none() {
            return false;
        }
        if self.domain.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dns_reg_method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.udp_addr = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.dot_addr = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.doh_url = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.pubkey = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.utls_distribution = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.stun_server = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dns_reg_method {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.udp_addr.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.dot_addr.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.doh_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.pubkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.utls_distribution.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.stun_server.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dns_reg_method {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.udp_addr.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.dot_addr.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.doh_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.domain.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.pubkey.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.utls_distribution.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.stun_server.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DnsRegConf {
        DnsRegConf::new()
    }

    fn clear(&mut self) {
        self.dns_reg_method = ::std::option::Option::None;
        self.udp_addr = ::std::option::Option::None;
        self.dot_addr = ::std::option::Option::None;
        self.doh_url = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.pubkey = ::std::option::Option::None;
        self.utls_distribution = ::std::option::Option::None;
        self.stun_server = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DnsRegConf {
        static instance: DnsRegConf = DnsRegConf {
            dns_reg_method: ::std::option::Option::None,
            udp_addr: ::std::option::Option::None,
            dot_addr: ::std::option::Option::None,
            doh_url: ::std::option::Option::None,
            domain: ::std::option::Option::None,
            pubkey: ::std::option::Option::None,
            utls_distribution: ::std::option::Option::None,
            stun_server: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DnsRegConf {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DnsRegConf").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DnsRegConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsRegConf {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.DecoyList)
pub struct DecoyList {
    // message fields
    // @@protoc_insertion_point(field:tapdance.DecoyList.tls_decoys)
    pub tls_decoys: ::std::vec::Vec<TLSDecoySpec>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.DecoyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DecoyList {
    fn default() -> &'a DecoyList {
        <DecoyList as ::protobuf::Message>::default_instance()
    }
}

impl DecoyList {
    pub fn new() -> DecoyList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tls_decoys",
            |m: &DecoyList| { &m.tls_decoys },
            |m: &mut DecoyList| { &mut m.tls_decoys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DecoyList>(
            "DecoyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DecoyList {
    const NAME: &'static str = "DecoyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tls_decoys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tls_decoys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tls_decoys {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DecoyList {
        DecoyList::new()
    }

    fn clear(&mut self) {
        self.tls_decoys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DecoyList {
        static instance: DecoyList = DecoyList {
            tls_decoys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DecoyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DecoyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DecoyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecoyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.PhantomSubnetsList)
pub struct PhantomSubnetsList {
    // message fields
    // @@protoc_insertion_point(field:tapdance.PhantomSubnetsList.weighted_subnets)
    pub weighted_subnets: ::std::vec::Vec<PhantomSubnets>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.PhantomSubnetsList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhantomSubnetsList {
    fn default() -> &'a PhantomSubnetsList {
        <PhantomSubnetsList as ::protobuf::Message>::default_instance()
    }
}

impl PhantomSubnetsList {
    pub fn new() -> PhantomSubnetsList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weighted_subnets",
            |m: &PhantomSubnetsList| { &m.weighted_subnets },
            |m: &mut PhantomSubnetsList| { &mut m.weighted_subnets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhantomSubnetsList>(
            "PhantomSubnetsList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhantomSubnetsList {
    const NAME: &'static str = "PhantomSubnetsList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.weighted_subnets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.weighted_subnets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.weighted_subnets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhantomSubnetsList {
        PhantomSubnetsList::new()
    }

    fn clear(&mut self) {
        self.weighted_subnets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhantomSubnetsList {
        static instance: PhantomSubnetsList = PhantomSubnetsList {
            weighted_subnets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhantomSubnetsList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhantomSubnetsList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhantomSubnetsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhantomSubnetsList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.PhantomSubnets)
pub struct PhantomSubnets {
    // message fields
    // @@protoc_insertion_point(field:tapdance.PhantomSubnets.weight)
    pub weight: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.PhantomSubnets.subnets)
    pub subnets: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.PhantomSubnets.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhantomSubnets {
    fn default() -> &'a PhantomSubnets {
        <PhantomSubnets as ::protobuf::Message>::default_instance()
    }
}

impl PhantomSubnets {
    pub fn new() -> PhantomSubnets {
        ::std::default::Default::default()
    }

    // optional uint32 weight = 1;

    pub fn weight(&self) -> u32 {
        self.weight.unwrap_or(0)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &PhantomSubnets| { &m.weight },
            |m: &mut PhantomSubnets| { &mut m.weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subnets",
            |m: &PhantomSubnets| { &m.subnets },
            |m: &mut PhantomSubnets| { &mut m.subnets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhantomSubnets>(
            "PhantomSubnets",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhantomSubnets {
    const NAME: &'static str = "PhantomSubnets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.weight = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.subnets.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.subnets {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.weight {
            os.write_uint32(1, v)?;
        }
        for v in &self.subnets {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhantomSubnets {
        PhantomSubnets::new()
    }

    fn clear(&mut self) {
        self.weight = ::std::option::Option::None;
        self.subnets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhantomSubnets {
        static instance: PhantomSubnets = PhantomSubnets {
            weight: ::std::option::Option::None,
            subnets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhantomSubnets {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhantomSubnets").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhantomSubnets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhantomSubnets {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Deflated ICE Candidate by seed2sdp package
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.WebRTCICECandidate)
pub struct WebRTCICECandidate {
    // message fields
    ///  IP is represented in its 16-byte form
    // @@protoc_insertion_point(field:tapdance.WebRTCICECandidate.ip_upper)
    pub ip_upper: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:tapdance.WebRTCICECandidate.ip_lower)
    pub ip_lower: ::std::option::Option<u64>,
    ///  Composed info includes port, tcptype (unset if not tcp), candidate type (host, srflx, prflx), protocol (TCP/UDP), and component (RTP/RTCP)
    // @@protoc_insertion_point(field:tapdance.WebRTCICECandidate.composed_info)
    pub composed_info: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.WebRTCICECandidate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebRTCICECandidate {
    fn default() -> &'a WebRTCICECandidate {
        <WebRTCICECandidate as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCICECandidate {
    pub fn new() -> WebRTCICECandidate {
        ::std::default::Default::default()
    }

    // required uint64 ip_upper = 1;

    pub fn ip_upper(&self) -> u64 {
        self.ip_upper.unwrap_or(0)
    }

    pub fn clear_ip_upper(&mut self) {
        self.ip_upper = ::std::option::Option::None;
    }

    pub fn has_ip_upper(&self) -> bool {
        self.ip_upper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_upper(&mut self, v: u64) {
        self.ip_upper = ::std::option::Option::Some(v);
    }

    // required uint64 ip_lower = 2;

    pub fn ip_lower(&self) -> u64 {
        self.ip_lower.unwrap_or(0)
    }

    pub fn clear_ip_lower(&mut self) {
        self.ip_lower = ::std::option::Option::None;
    }

    pub fn has_ip_lower(&self) -> bool {
        self.ip_lower.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_lower(&mut self, v: u64) {
        self.ip_lower = ::std::option::Option::Some(v);
    }

    // required uint32 composed_info = 3;

    pub fn composed_info(&self) -> u32 {
        self.composed_info.unwrap_or(0)
    }

    pub fn clear_composed_info(&mut self) {
        self.composed_info = ::std::option::Option::None;
    }

    pub fn has_composed_info(&self) -> bool {
        self.composed_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composed_info(&mut self, v: u32) {
        self.composed_info = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_upper",
            |m: &WebRTCICECandidate| { &m.ip_upper },
            |m: &mut WebRTCICECandidate| { &mut m.ip_upper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_lower",
            |m: &WebRTCICECandidate| { &m.ip_lower },
            |m: &mut WebRTCICECandidate| { &mut m.ip_lower },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "composed_info",
            |m: &WebRTCICECandidate| { &m.composed_info },
            |m: &mut WebRTCICECandidate| { &mut m.composed_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebRTCICECandidate>(
            "WebRTCICECandidate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebRTCICECandidate {
    const NAME: &'static str = "WebRTCICECandidate";

    fn is_initialized(&self) -> bool {
        if self.ip_upper.is_none() {
            return false;
        }
        if self.ip_lower.is_none() {
            return false;
        }
        if self.composed_info.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ip_upper = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.ip_lower = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.composed_info = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip_upper {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.ip_lower {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.composed_info {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip_upper {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ip_lower {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.composed_info {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebRTCICECandidate {
        WebRTCICECandidate::new()
    }

    fn clear(&mut self) {
        self.ip_upper = ::std::option::Option::None;
        self.ip_lower = ::std::option::Option::None;
        self.composed_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebRTCICECandidate {
        static instance: WebRTCICECandidate = WebRTCICECandidate {
            ip_upper: ::std::option::Option::None,
            ip_lower: ::std::option::Option::None,
            composed_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebRTCICECandidate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebRTCICECandidate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebRTCICECandidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCICECandidate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Deflated SDP for WebRTC by seed2sdp package
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.WebRTCSDP)
pub struct WebRTCSDP {
    // message fields
    // @@protoc_insertion_point(field:tapdance.WebRTCSDP.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.WebRTCSDP.candidates)
    pub candidates: ::std::vec::Vec<WebRTCICECandidate>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.WebRTCSDP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebRTCSDP {
    fn default() -> &'a WebRTCSDP {
        <WebRTCSDP as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCSDP {
    pub fn new() -> WebRTCSDP {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &WebRTCSDP| { &m.type_ },
            |m: &mut WebRTCSDP| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "candidates",
            |m: &WebRTCSDP| { &m.candidates },
            |m: &mut WebRTCSDP| { &mut m.candidates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebRTCSDP>(
            "WebRTCSDP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebRTCSDP {
    const NAME: &'static str = "WebRTCSDP";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        for v in &self.candidates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.candidates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.candidates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        for v in &self.candidates {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebRTCSDP {
        WebRTCSDP::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.candidates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebRTCSDP {
        static instance: WebRTCSDP = WebRTCSDP {
            type_: ::std::option::Option::None,
            candidates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebRTCSDP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebRTCSDP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebRTCSDP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCSDP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WebRTCSignal includes a deflated SDP and a seed
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.WebRTCSignal)
pub struct WebRTCSignal {
    // message fields
    // @@protoc_insertion_point(field:tapdance.WebRTCSignal.seed)
    pub seed: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.WebRTCSignal.sdp)
    pub sdp: ::protobuf::MessageField<WebRTCSDP>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.WebRTCSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebRTCSignal {
    fn default() -> &'a WebRTCSignal {
        <WebRTCSignal as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCSignal {
    pub fn new() -> WebRTCSignal {
        ::std::default::Default::default()
    }

    // required string seed = 1;

    pub fn seed(&self) -> &str {
        match self.seed.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_seed(&mut self) {
        self.seed = ::std::option::Option::None;
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: ::std::string::String) {
        self.seed = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed(&mut self) -> &mut ::std::string::String {
        if self.seed.is_none() {
            self.seed = ::std::option::Option::Some(::std::string::String::new());
        }
        self.seed.as_mut().unwrap()
    }

    // Take field
    pub fn take_seed(&mut self) -> ::std::string::String {
        self.seed.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seed",
            |m: &WebRTCSignal| { &m.seed },
            |m: &mut WebRTCSignal| { &mut m.seed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebRTCSDP>(
            "sdp",
            |m: &WebRTCSignal| { &m.sdp },
            |m: &mut WebRTCSignal| { &mut m.sdp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebRTCSignal>(
            "WebRTCSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebRTCSignal {
    const NAME: &'static str = "WebRTCSignal";

    fn is_initialized(&self) -> bool {
        if self.seed.is_none() {
            return false;
        }
        if self.sdp.is_none() {
            return false;
        }
        for v in &self.sdp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.seed = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sdp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seed.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sdp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seed.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sdp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebRTCSignal {
        WebRTCSignal::new()
    }

    fn clear(&mut self) {
        self.seed = ::std::option::Option::None;
        self.sdp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebRTCSignal {
        static instance: WebRTCSignal = WebRTCSignal {
            seed: ::std::option::Option::None,
            sdp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebRTCSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebRTCSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebRTCSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.StationToClient)
pub struct StationToClient {
    // message fields
    ///  Should accompany (at least) SESSION_INIT and CONFIRM_RECONNECT.
    // @@protoc_insertion_point(field:tapdance.StationToClient.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    ///  There might be a state transition. May be absent; absence should be
    ///  treated identically to NO_CHANGE.
    // @@protoc_insertion_point(field:tapdance.StationToClient.state_transition)
    pub state_transition: ::std::option::Option<::protobuf::EnumOrUnknown<S2C_Transition>>,
    ///  The station can send client config info piggybacked
    ///  on any message, as it sees fit
    // @@protoc_insertion_point(field:tapdance.StationToClient.config_info)
    pub config_info: ::protobuf::MessageField<ClientConf>,
    ///  If state_transition == S2C_ERROR, this field is the explanation.
    // @@protoc_insertion_point(field:tapdance.StationToClient.err_reason)
    pub err_reason: ::std::option::Option<::protobuf::EnumOrUnknown<ErrorReasonS2C>>,
    ///  Signals client to stop connecting for following amount of seconds
    // @@protoc_insertion_point(field:tapdance.StationToClient.tmp_backoff)
    pub tmp_backoff: ::std::option::Option<u32>,
    ///  Sent in SESSION_INIT, identifies the station that picked up
    // @@protoc_insertion_point(field:tapdance.StationToClient.station_id)
    pub station_id: ::std::option::Option<::std::string::String>,
    ///  Random-sized junk to defeat packet size fingerprinting.
    // @@protoc_insertion_point(field:tapdance.StationToClient.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.StationToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StationToClient {
    fn default() -> &'a StationToClient {
        <StationToClient as ::protobuf::Message>::default_instance()
    }
}

impl StationToClient {
    pub fn new() -> StationToClient {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional .tapdance.S2C_Transition state_transition = 2;

    pub fn state_transition(&self) -> S2C_Transition {
        match self.state_transition {
            Some(e) => e.enum_value_or(S2C_Transition::S2C_NO_CHANGE),
            None => S2C_Transition::S2C_NO_CHANGE,
        }
    }

    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: S2C_Transition) {
        self.state_transition = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .tapdance.ErrorReasonS2C err_reason = 4;

    pub fn err_reason(&self) -> ErrorReasonS2C {
        match self.err_reason {
            Some(e) => e.enum_value_or(ErrorReasonS2C::NO_ERROR),
            None => ErrorReasonS2C::NO_ERROR,
        }
    }

    pub fn clear_err_reason(&mut self) {
        self.err_reason = ::std::option::Option::None;
    }

    pub fn has_err_reason(&self) -> bool {
        self.err_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_err_reason(&mut self, v: ErrorReasonS2C) {
        self.err_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 tmp_backoff = 5;

    pub fn tmp_backoff(&self) -> u32 {
        self.tmp_backoff.unwrap_or(0)
    }

    pub fn clear_tmp_backoff(&mut self) {
        self.tmp_backoff = ::std::option::Option::None;
    }

    pub fn has_tmp_backoff(&self) -> bool {
        self.tmp_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tmp_backoff(&mut self, v: u32) {
        self.tmp_backoff = ::std::option::Option::Some(v);
    }

    // optional string station_id = 6;

    pub fn station_id(&self) -> &str {
        match self.station_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_station_id(&mut self) {
        self.station_id = ::std::option::Option::None;
    }

    pub fn has_station_id(&self) -> bool {
        self.station_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_id(&mut self, v: ::std::string::String) {
        self.station_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_station_id(&mut self) -> &mut ::std::string::String {
        if self.station_id.is_none() {
            self.station_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.station_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_station_id(&mut self) -> ::std::string::String {
        self.station_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes padding = 100;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &StationToClient| { &m.protocol_version },
            |m: &mut StationToClient| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_transition",
            |m: &StationToClient| { &m.state_transition },
            |m: &mut StationToClient| { &mut m.state_transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientConf>(
            "config_info",
            |m: &StationToClient| { &m.config_info },
            |m: &mut StationToClient| { &mut m.config_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "err_reason",
            |m: &StationToClient| { &m.err_reason },
            |m: &mut StationToClient| { &mut m.err_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tmp_backoff",
            |m: &StationToClient| { &m.tmp_backoff },
            |m: &mut StationToClient| { &mut m.tmp_backoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "station_id",
            |m: &StationToClient| { &m.station_id },
            |m: &mut StationToClient| { &mut m.station_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &StationToClient| { &m.padding },
            |m: &mut StationToClient| { &mut m.padding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StationToClient>(
            "StationToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StationToClient {
    const NAME: &'static str = "StationToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.state_transition = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config_info)?;
                },
                32 => {
                    self.err_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.tmp_backoff = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.station_id = ::std::option::Option::Some(is.read_string()?);
                },
                802 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.config_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.err_reason {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.tmp_backoff {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.station_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.config_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.err_reason {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tmp_backoff {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.station_id.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(100, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StationToClient {
        StationToClient::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.config_info.clear();
        self.err_reason = ::std::option::Option::None;
        self.tmp_backoff = ::std::option::Option::None;
        self.station_id = ::std::option::Option::None;
        self.padding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StationToClient {
        static instance: StationToClient = StationToClient {
            protocol_version: ::std::option::Option::None,
            state_transition: ::std::option::Option::None,
            config_info: ::protobuf::MessageField::none(),
            err_reason: ::std::option::Option::None,
            tmp_backoff: ::std::option::Option::None,
            station_id: ::std::option::Option::None,
            padding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StationToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StationToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StationToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.RegistrationFlags)
pub struct RegistrationFlags {
    // message fields
    // @@protoc_insertion_point(field:tapdance.RegistrationFlags.upload_only)
    pub upload_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:tapdance.RegistrationFlags.dark_decoy)
    pub dark_decoy: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:tapdance.RegistrationFlags.proxy_header)
    pub proxy_header: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:tapdance.RegistrationFlags.use_TIL)
    pub use_TIL: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:tapdance.RegistrationFlags.prescanned)
    pub prescanned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.RegistrationFlags.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegistrationFlags {
    fn default() -> &'a RegistrationFlags {
        <RegistrationFlags as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationFlags {
    pub fn new() -> RegistrationFlags {
        ::std::default::Default::default()
    }

    // optional bool upload_only = 1;

    pub fn upload_only(&self) -> bool {
        self.upload_only.unwrap_or(false)
    }

    pub fn clear_upload_only(&mut self) {
        self.upload_only = ::std::option::Option::None;
    }

    pub fn has_upload_only(&self) -> bool {
        self.upload_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_only(&mut self, v: bool) {
        self.upload_only = ::std::option::Option::Some(v);
    }

    // optional bool dark_decoy = 2;

    pub fn dark_decoy(&self) -> bool {
        self.dark_decoy.unwrap_or(false)
    }

    pub fn clear_dark_decoy(&mut self) {
        self.dark_decoy = ::std::option::Option::None;
    }

    pub fn has_dark_decoy(&self) -> bool {
        self.dark_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dark_decoy(&mut self, v: bool) {
        self.dark_decoy = ::std::option::Option::Some(v);
    }

    // optional bool proxy_header = 3;

    pub fn proxy_header(&self) -> bool {
        self.proxy_header.unwrap_or(false)
    }

    pub fn clear_proxy_header(&mut self) {
        self.proxy_header = ::std::option::Option::None;
    }

    pub fn has_proxy_header(&self) -> bool {
        self.proxy_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_header(&mut self, v: bool) {
        self.proxy_header = ::std::option::Option::Some(v);
    }

    // optional bool use_TIL = 4;

    pub fn use_TIL(&self) -> bool {
        self.use_TIL.unwrap_or(false)
    }

    pub fn clear_use_TIL(&mut self) {
        self.use_TIL = ::std::option::Option::None;
    }

    pub fn has_use_TIL(&self) -> bool {
        self.use_TIL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_TIL(&mut self, v: bool) {
        self.use_TIL = ::std::option::Option::Some(v);
    }

    // optional bool prescanned = 5;

    pub fn prescanned(&self) -> bool {
        self.prescanned.unwrap_or(false)
    }

    pub fn clear_prescanned(&mut self) {
        self.prescanned = ::std::option::Option::None;
    }

    pub fn has_prescanned(&self) -> bool {
        self.prescanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prescanned(&mut self, v: bool) {
        self.prescanned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_only",
            |m: &RegistrationFlags| { &m.upload_only },
            |m: &mut RegistrationFlags| { &mut m.upload_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dark_decoy",
            |m: &RegistrationFlags| { &m.dark_decoy },
            |m: &mut RegistrationFlags| { &mut m.dark_decoy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proxy_header",
            |m: &RegistrationFlags| { &m.proxy_header },
            |m: &mut RegistrationFlags| { &mut m.proxy_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_TIL",
            |m: &RegistrationFlags| { &m.use_TIL },
            |m: &mut RegistrationFlags| { &mut m.use_TIL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prescanned",
            |m: &RegistrationFlags| { &m.prescanned },
            |m: &mut RegistrationFlags| { &mut m.prescanned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegistrationFlags>(
            "RegistrationFlags",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegistrationFlags {
    const NAME: &'static str = "RegistrationFlags";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upload_only = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.dark_decoy = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.proxy_header = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.use_TIL = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.prescanned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upload_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dark_decoy {
            my_size += 1 + 1;
        }
        if let Some(v) = self.proxy_header {
            my_size += 1 + 1;
        }
        if let Some(v) = self.use_TIL {
            my_size += 1 + 1;
        }
        if let Some(v) = self.prescanned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upload_only {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dark_decoy {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.proxy_header {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.use_TIL {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.prescanned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegistrationFlags {
        RegistrationFlags::new()
    }

    fn clear(&mut self) {
        self.upload_only = ::std::option::Option::None;
        self.dark_decoy = ::std::option::Option::None;
        self.proxy_header = ::std::option::Option::None;
        self.use_TIL = ::std::option::Option::None;
        self.prescanned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegistrationFlags {
        static instance: RegistrationFlags = RegistrationFlags {
            upload_only: ::std::option::Option::None,
            dark_decoy: ::std::option::Option::None,
            proxy_header: ::std::option::Option::None,
            use_TIL: ::std::option::Option::None,
            prescanned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegistrationFlags {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegistrationFlags").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegistrationFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationFlags {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.ClientToStation)
pub struct ClientToStation {
    // message fields
    // @@protoc_insertion_point(field:tapdance.ClientToStation.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    ///  The client reports its decoy list's version number here, which the
    ///  station can use to decide whether to send an updated one. The station
    ///  should always send a list if this field is set to 0.
    // @@protoc_insertion_point(field:tapdance.ClientToStation.decoy_list_generation)
    pub decoy_list_generation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.ClientToStation.state_transition)
    pub state_transition: ::std::option::Option<::protobuf::EnumOrUnknown<C2S_Transition>>,
    ///  The position in the overall session's upload sequence where the current
    ///  YIELD=>ACQUIRE switchover is happening.
    // @@protoc_insertion_point(field:tapdance.ClientToStation.upload_sync)
    pub upload_sync: ::std::option::Option<u64>,
    ///  High level client library version used for indicating feature support, or
    ///  lack therof.
    // @@protoc_insertion_point(field:tapdance.ClientToStation.client_lib_version)
    pub client_lib_version: ::std::option::Option<u32>,
    ///  List of decoys that client have unsuccessfully tried in current session.
    ///  Could be sent in chunks
    // @@protoc_insertion_point(field:tapdance.ClientToStation.failed_decoys)
    pub failed_decoys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.ClientToStation.stats)
    pub stats: ::protobuf::MessageField<SessionStats>,
    ///  NullTransport, MinTransport, Obfs4Transport, etc. Transport type we want from phantom proxy
    // @@protoc_insertion_point(field:tapdance.ClientToStation.transport)
    pub transport: ::std::option::Option<::protobuf::EnumOrUnknown<TransportType>>,
    // @@protoc_insertion_point(field:tapdance.ClientToStation.transport_params)
    pub transport_params: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  Station is only required to check this variable during session initialization.
    ///  If set, station must facilitate connection to said target by itself, i.e. write into squid
    ///  socket an HTTP/SOCKS/any other connection request.
    ///  covert_address must have exactly one ':' colon, that separates host (literal IP address or
    ///  resolvable hostname) and port
    ///  TODO: make it required for initialization, and stop connecting any client straight to squid?
    // @@protoc_insertion_point(field:tapdance.ClientToStation.covert_address)
    pub covert_address: ::std::option::Option<::std::string::String>,
    ///  Used in dark decoys to signal which dark decoy it will connect to.
    // @@protoc_insertion_point(field:tapdance.ClientToStation.masked_decoy_server_name)
    pub masked_decoy_server_name: ::std::option::Option<::std::string::String>,
    ///  Used to indicate to server if client is registering v4, v6 or both
    // @@protoc_insertion_point(field:tapdance.ClientToStation.v6_support)
    pub v6_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:tapdance.ClientToStation.v4_support)
    pub v4_support: ::std::option::Option<bool>,
    ///  A collection of optional flags for the registration.
    // @@protoc_insertion_point(field:tapdance.ClientToStation.flags)
    pub flags: ::protobuf::MessageField<RegistrationFlags>,
    ///  Transport Extensions
    ///  TODO(jmwample) - move to WebRTC specific transport params protobuf message.
    // @@protoc_insertion_point(field:tapdance.ClientToStation.webrtc_signal)
    pub webrtc_signal: ::protobuf::MessageField<WebRTCSignal>,
    ///  Random-sized junk to defeat packet size fingerprinting.
    // @@protoc_insertion_point(field:tapdance.ClientToStation.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.ClientToStation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientToStation {
    fn default() -> &'a ClientToStation {
        <ClientToStation as ::protobuf::Message>::default_instance()
    }
}

impl ClientToStation {
    pub fn new() -> ClientToStation {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 decoy_list_generation = 2;

    pub fn decoy_list_generation(&self) -> u32 {
        self.decoy_list_generation.unwrap_or(0)
    }

    pub fn clear_decoy_list_generation(&mut self) {
        self.decoy_list_generation = ::std::option::Option::None;
    }

    pub fn has_decoy_list_generation(&self) -> bool {
        self.decoy_list_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_list_generation(&mut self, v: u32) {
        self.decoy_list_generation = ::std::option::Option::Some(v);
    }

    // optional .tapdance.C2S_Transition state_transition = 3;

    pub fn state_transition(&self) -> C2S_Transition {
        match self.state_transition {
            Some(e) => e.enum_value_or(C2S_Transition::C2S_NO_CHANGE),
            None => C2S_Transition::C2S_NO_CHANGE,
        }
    }

    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: C2S_Transition) {
        self.state_transition = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 upload_sync = 4;

    pub fn upload_sync(&self) -> u64 {
        self.upload_sync.unwrap_or(0)
    }

    pub fn clear_upload_sync(&mut self) {
        self.upload_sync = ::std::option::Option::None;
    }

    pub fn has_upload_sync(&self) -> bool {
        self.upload_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_sync(&mut self, v: u64) {
        self.upload_sync = ::std::option::Option::Some(v);
    }

    // optional uint32 client_lib_version = 5;

    pub fn client_lib_version(&self) -> u32 {
        self.client_lib_version.unwrap_or(0)
    }

    pub fn clear_client_lib_version(&mut self) {
        self.client_lib_version = ::std::option::Option::None;
    }

    pub fn has_client_lib_version(&self) -> bool {
        self.client_lib_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_lib_version(&mut self, v: u32) {
        self.client_lib_version = ::std::option::Option::Some(v);
    }

    // optional .tapdance.TransportType transport = 12;

    pub fn transport(&self) -> TransportType {
        match self.transport {
            Some(e) => e.enum_value_or(TransportType::Null),
            None => TransportType::Null,
        }
    }

    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: TransportType) {
        self.transport = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string covert_address = 20;

    pub fn covert_address(&self) -> &str {
        match self.covert_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_covert_address(&mut self) {
        self.covert_address = ::std::option::Option::None;
    }

    pub fn has_covert_address(&self) -> bool {
        self.covert_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_covert_address(&mut self, v: ::std::string::String) {
        self.covert_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_covert_address(&mut self) -> &mut ::std::string::String {
        if self.covert_address.is_none() {
            self.covert_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.covert_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_covert_address(&mut self) -> ::std::string::String {
        self.covert_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string masked_decoy_server_name = 21;

    pub fn masked_decoy_server_name(&self) -> &str {
        match self.masked_decoy_server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_masked_decoy_server_name(&mut self) {
        self.masked_decoy_server_name = ::std::option::Option::None;
    }

    pub fn has_masked_decoy_server_name(&self) -> bool {
        self.masked_decoy_server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked_decoy_server_name(&mut self, v: ::std::string::String) {
        self.masked_decoy_server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked_decoy_server_name(&mut self) -> &mut ::std::string::String {
        if self.masked_decoy_server_name.is_none() {
            self.masked_decoy_server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.masked_decoy_server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked_decoy_server_name(&mut self) -> ::std::string::String {
        self.masked_decoy_server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool v6_support = 22;

    pub fn v6_support(&self) -> bool {
        self.v6_support.unwrap_or(false)
    }

    pub fn clear_v6_support(&mut self) {
        self.v6_support = ::std::option::Option::None;
    }

    pub fn has_v6_support(&self) -> bool {
        self.v6_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v6_support(&mut self, v: bool) {
        self.v6_support = ::std::option::Option::Some(v);
    }

    // optional bool v4_support = 23;

    pub fn v4_support(&self) -> bool {
        self.v4_support.unwrap_or(false)
    }

    pub fn clear_v4_support(&mut self) {
        self.v4_support = ::std::option::Option::None;
    }

    pub fn has_v4_support(&self) -> bool {
        self.v4_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v4_support(&mut self, v: bool) {
        self.v4_support = ::std::option::Option::Some(v);
    }

    // optional bytes padding = 100;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &ClientToStation| { &m.protocol_version },
            |m: &mut ClientToStation| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decoy_list_generation",
            |m: &ClientToStation| { &m.decoy_list_generation },
            |m: &mut ClientToStation| { &mut m.decoy_list_generation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_transition",
            |m: &ClientToStation| { &m.state_transition },
            |m: &mut ClientToStation| { &mut m.state_transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_sync",
            |m: &ClientToStation| { &m.upload_sync },
            |m: &mut ClientToStation| { &mut m.upload_sync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_lib_version",
            |m: &ClientToStation| { &m.client_lib_version },
            |m: &mut ClientToStation| { &mut m.client_lib_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failed_decoys",
            |m: &ClientToStation| { &m.failed_decoys },
            |m: &mut ClientToStation| { &mut m.failed_decoys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SessionStats>(
            "stats",
            |m: &ClientToStation| { &m.stats },
            |m: &mut ClientToStation| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport",
            |m: &ClientToStation| { &m.transport },
            |m: &mut ClientToStation| { &mut m.transport },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "transport_params",
            |m: &ClientToStation| { &m.transport_params },
            |m: &mut ClientToStation| { &mut m.transport_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "covert_address",
            |m: &ClientToStation| { &m.covert_address },
            |m: &mut ClientToStation| { &mut m.covert_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "masked_decoy_server_name",
            |m: &ClientToStation| { &m.masked_decoy_server_name },
            |m: &mut ClientToStation| { &mut m.masked_decoy_server_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "v6_support",
            |m: &ClientToStation| { &m.v6_support },
            |m: &mut ClientToStation| { &mut m.v6_support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "v4_support",
            |m: &ClientToStation| { &m.v4_support },
            |m: &mut ClientToStation| { &mut m.v4_support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RegistrationFlags>(
            "flags",
            |m: &ClientToStation| { &m.flags },
            |m: &mut ClientToStation| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebRTCSignal>(
            "webrtc_signal",
            |m: &ClientToStation| { &m.webrtc_signal },
            |m: &mut ClientToStation| { &mut m.webrtc_signal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &ClientToStation| { &m.padding },
            |m: &mut ClientToStation| { &mut m.padding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientToStation>(
            "ClientToStation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientToStation {
    const NAME: &'static str = "ClientToStation";

    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.webrtc_signal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.decoy_list_generation = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state_transition = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.upload_sync = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.client_lib_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.failed_decoys.push(is.read_string()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                96 => {
                    self.transport = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transport_params)?;
                },
                162 => {
                    self.covert_address = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.masked_decoy_server_name = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.v6_support = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.v4_support = ::std::option::Option::Some(is.read_bool()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flags)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webrtc_signal)?;
                },
                802 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.decoy_list_generation {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.upload_sync {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.client_lib_version {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.failed_decoys {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.transport_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.covert_address.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.masked_decoy_server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.v6_support {
            my_size += 2 + 1;
        }
        if let Some(v) = self.v4_support {
            my_size += 2 + 1;
        }
        if let Some(v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.webrtc_signal.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.decoy_list_generation {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.upload_sync {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.client_lib_version {
            os.write_uint32(5, v)?;
        }
        for v in &self.failed_decoys {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.transport_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.covert_address.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.masked_decoy_server_name.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.v6_support {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.v4_support {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.flags.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.webrtc_signal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(100, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientToStation {
        ClientToStation::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.decoy_list_generation = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.upload_sync = ::std::option::Option::None;
        self.client_lib_version = ::std::option::Option::None;
        self.failed_decoys.clear();
        self.stats.clear();
        self.transport = ::std::option::Option::None;
        self.transport_params.clear();
        self.covert_address = ::std::option::Option::None;
        self.masked_decoy_server_name = ::std::option::Option::None;
        self.v6_support = ::std::option::Option::None;
        self.v4_support = ::std::option::Option::None;
        self.flags.clear();
        self.webrtc_signal.clear();
        self.padding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientToStation {
        static instance: ClientToStation = ClientToStation {
            protocol_version: ::std::option::Option::None,
            decoy_list_generation: ::std::option::Option::None,
            state_transition: ::std::option::Option::None,
            upload_sync: ::std::option::Option::None,
            client_lib_version: ::std::option::Option::None,
            failed_decoys: ::std::vec::Vec::new(),
            stats: ::protobuf::MessageField::none(),
            transport: ::std::option::Option::None,
            transport_params: ::protobuf::MessageField::none(),
            covert_address: ::std::option::Option::None,
            masked_decoy_server_name: ::std::option::Option::None,
            v6_support: ::std::option::Option::None,
            v4_support: ::std::option::Option::None,
            flags: ::protobuf::MessageField::none(),
            webrtc_signal: ::protobuf::MessageField::none(),
            padding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientToStation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientToStation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientToStation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientToStation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.GenericTransportParams)
pub struct GenericTransportParams {
    // message fields
    ///  Indicates whether the client has elected to use destination port
    ///  randomization. Should be checked against selected transport to ensure
    ///  that destination port randomization is supported.
    // @@protoc_insertion_point(field:tapdance.GenericTransportParams.randomize_dst_port)
    pub randomize_dst_port: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.GenericTransportParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericTransportParams {
    fn default() -> &'a GenericTransportParams {
        <GenericTransportParams as ::protobuf::Message>::default_instance()
    }
}

impl GenericTransportParams {
    pub fn new() -> GenericTransportParams {
        ::std::default::Default::default()
    }

    // optional bool randomize_dst_port = 13;

    pub fn randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.unwrap_or(false)
    }

    pub fn clear_randomize_dst_port(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
    }

    pub fn has_randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomize_dst_port(&mut self, v: bool) {
        self.randomize_dst_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "randomize_dst_port",
            |m: &GenericTransportParams| { &m.randomize_dst_port },
            |m: &mut GenericTransportParams| { &mut m.randomize_dst_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericTransportParams>(
            "GenericTransportParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericTransportParams {
    const NAME: &'static str = "GenericTransportParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                104 => {
                    self.randomize_dst_port = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.randomize_dst_port {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.randomize_dst_port {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericTransportParams {
        GenericTransportParams::new()
    }

    fn clear(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericTransportParams {
        static instance: GenericTransportParams = GenericTransportParams {
            randomize_dst_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericTransportParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericTransportParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericTransportParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericTransportParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.C2SWrapper)
pub struct C2SWrapper {
    // message fields
    // @@protoc_insertion_point(field:tapdance.C2SWrapper.shared_secret)
    pub shared_secret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:tapdance.C2SWrapper.registration_payload)
    pub registration_payload: ::protobuf::MessageField<ClientToStation>,
    // @@protoc_insertion_point(field:tapdance.C2SWrapper.registration_source)
    pub registration_source: ::std::option::Option<::protobuf::EnumOrUnknown<RegistrationSource>>,
    ///  client source address when receiving a registration
    // @@protoc_insertion_point(field:tapdance.C2SWrapper.registration_address)
    pub registration_address: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  Decoy address used when registering over Decoy registrar
    // @@protoc_insertion_point(field:tapdance.C2SWrapper.decoy_address)
    pub decoy_address: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:tapdance.C2SWrapper.registration_response)
    pub registration_response: ::protobuf::MessageField<RegistrationResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.C2SWrapper.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a C2SWrapper {
    fn default() -> &'a C2SWrapper {
        <C2SWrapper as ::protobuf::Message>::default_instance()
    }
}

impl C2SWrapper {
    pub fn new() -> C2SWrapper {
        ::std::default::Default::default()
    }

    // optional bytes shared_secret = 1;

    pub fn shared_secret(&self) -> &[u8] {
        match self.shared_secret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_shared_secret(&mut self) {
        self.shared_secret = ::std::option::Option::None;
    }

    pub fn has_shared_secret(&self) -> bool {
        self.shared_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.shared_secret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shared_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.shared_secret.is_none() {
            self.shared_secret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.shared_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_shared_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.shared_secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.RegistrationSource registration_source = 4;

    pub fn registration_source(&self) -> RegistrationSource {
        match self.registration_source {
            Some(e) => e.enum_value_or(RegistrationSource::Unspecified),
            None => RegistrationSource::Unspecified,
        }
    }

    pub fn clear_registration_source(&mut self) {
        self.registration_source = ::std::option::Option::None;
    }

    pub fn has_registration_source(&self) -> bool {
        self.registration_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_source(&mut self, v: RegistrationSource) {
        self.registration_source = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes registration_address = 6;

    pub fn registration_address(&self) -> &[u8] {
        match self.registration_address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_registration_address(&mut self) {
        self.registration_address = ::std::option::Option::None;
    }

    pub fn has_registration_address(&self) -> bool {
        self.registration_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.registration_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.registration_address.is_none() {
            self.registration_address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.registration_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_address(&mut self) -> ::std::vec::Vec<u8> {
        self.registration_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes decoy_address = 7;

    pub fn decoy_address(&self) -> &[u8] {
        match self.decoy_address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_decoy_address(&mut self) {
        self.decoy_address = ::std::option::Option::None;
    }

    pub fn has_decoy_address(&self) -> bool {
        self.decoy_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.decoy_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoy_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.decoy_address.is_none() {
            self.decoy_address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.decoy_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_decoy_address(&mut self) -> ::std::vec::Vec<u8> {
        self.decoy_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shared_secret",
            |m: &C2SWrapper| { &m.shared_secret },
            |m: &mut C2SWrapper| { &mut m.shared_secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientToStation>(
            "registration_payload",
            |m: &C2SWrapper| { &m.registration_payload },
            |m: &mut C2SWrapper| { &mut m.registration_payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registration_source",
            |m: &C2SWrapper| { &m.registration_source },
            |m: &mut C2SWrapper| { &mut m.registration_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registration_address",
            |m: &C2SWrapper| { &m.registration_address },
            |m: &mut C2SWrapper| { &mut m.registration_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decoy_address",
            |m: &C2SWrapper| { &m.decoy_address },
            |m: &mut C2SWrapper| { &mut m.decoy_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RegistrationResponse>(
            "registration_response",
            |m: &C2SWrapper| { &m.registration_response },
            |m: &mut C2SWrapper| { &mut m.registration_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<C2SWrapper>(
            "C2SWrapper",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for C2SWrapper {
    const NAME: &'static str = "C2SWrapper";

    fn is_initialized(&self) -> bool {
        for v in &self.registration_payload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.registration_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shared_secret = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.registration_payload)?;
                },
                32 => {
                    self.registration_source = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.registration_address = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.decoy_address = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.registration_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shared_secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.registration_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.registration_source {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.registration_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.decoy_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.registration_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shared_secret.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.registration_payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.registration_source {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.registration_address.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.decoy_address.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.registration_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> C2SWrapper {
        C2SWrapper::new()
    }

    fn clear(&mut self) {
        self.shared_secret = ::std::option::Option::None;
        self.registration_payload.clear();
        self.registration_source = ::std::option::Option::None;
        self.registration_address = ::std::option::Option::None;
        self.decoy_address = ::std::option::Option::None;
        self.registration_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static C2SWrapper {
        static instance: C2SWrapper = C2SWrapper {
            shared_secret: ::std::option::Option::None,
            registration_payload: ::protobuf::MessageField::none(),
            registration_source: ::std::option::Option::None,
            registration_address: ::std::option::Option::None,
            decoy_address: ::std::option::Option::None,
            registration_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for C2SWrapper {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("C2SWrapper").unwrap()).clone()
    }
}

impl ::std::fmt::Display for C2SWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for C2SWrapper {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.SessionStats)
pub struct SessionStats {
    // message fields
    // @@protoc_insertion_point(field:tapdance.SessionStats.failed_decoys_amount)
    pub failed_decoys_amount: ::std::option::Option<u32>,
    ///  Applicable to whole session:
    // @@protoc_insertion_point(field:tapdance.SessionStats.total_time_to_connect)
    pub total_time_to_connect: ::std::option::Option<u32>,
    ///  Last (i.e. successful) decoy:
    // @@protoc_insertion_point(field:tapdance.SessionStats.rtt_to_station)
    pub rtt_to_station: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.SessionStats.tls_to_decoy)
    pub tls_to_decoy: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.SessionStats.tcp_to_decoy)
    pub tcp_to_decoy: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.SessionStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SessionStats {
    fn default() -> &'a SessionStats {
        <SessionStats as ::protobuf::Message>::default_instance()
    }
}

impl SessionStats {
    pub fn new() -> SessionStats {
        ::std::default::Default::default()
    }

    // optional uint32 failed_decoys_amount = 20;

    pub fn failed_decoys_amount(&self) -> u32 {
        self.failed_decoys_amount.unwrap_or(0)
    }

    pub fn clear_failed_decoys_amount(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
    }

    pub fn has_failed_decoys_amount(&self) -> bool {
        self.failed_decoys_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_decoys_amount(&mut self, v: u32) {
        self.failed_decoys_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 total_time_to_connect = 31;

    pub fn total_time_to_connect(&self) -> u32 {
        self.total_time_to_connect.unwrap_or(0)
    }

    pub fn clear_total_time_to_connect(&mut self) {
        self.total_time_to_connect = ::std::option::Option::None;
    }

    pub fn has_total_time_to_connect(&self) -> bool {
        self.total_time_to_connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_time_to_connect(&mut self, v: u32) {
        self.total_time_to_connect = ::std::option::Option::Some(v);
    }

    // optional uint32 rtt_to_station = 33;

    pub fn rtt_to_station(&self) -> u32 {
        self.rtt_to_station.unwrap_or(0)
    }

    pub fn clear_rtt_to_station(&mut self) {
        self.rtt_to_station = ::std::option::Option::None;
    }

    pub fn has_rtt_to_station(&self) -> bool {
        self.rtt_to_station.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtt_to_station(&mut self, v: u32) {
        self.rtt_to_station = ::std::option::Option::Some(v);
    }

    // optional uint32 tls_to_decoy = 38;

    pub fn tls_to_decoy(&self) -> u32 {
        self.tls_to_decoy.unwrap_or(0)
    }

    pub fn clear_tls_to_decoy(&mut self) {
        self.tls_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tls_to_decoy(&self) -> bool {
        self.tls_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls_to_decoy(&mut self, v: u32) {
        self.tls_to_decoy = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_to_decoy = 39;

    pub fn tcp_to_decoy(&self) -> u32 {
        self.tcp_to_decoy.unwrap_or(0)
    }

    pub fn clear_tcp_to_decoy(&mut self) {
        self.tcp_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tcp_to_decoy(&self) -> bool {
        self.tcp_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_to_decoy(&mut self, v: u32) {
        self.tcp_to_decoy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failed_decoys_amount",
            |m: &SessionStats| { &m.failed_decoys_amount },
            |m: &mut SessionStats| { &mut m.failed_decoys_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_time_to_connect",
            |m: &SessionStats| { &m.total_time_to_connect },
            |m: &mut SessionStats| { &mut m.total_time_to_connect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtt_to_station",
            |m: &SessionStats| { &m.rtt_to_station },
            |m: &mut SessionStats| { &mut m.rtt_to_station },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tls_to_decoy",
            |m: &SessionStats| { &m.tls_to_decoy },
            |m: &mut SessionStats| { &mut m.tls_to_decoy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_to_decoy",
            |m: &SessionStats| { &m.tcp_to_decoy },
            |m: &mut SessionStats| { &mut m.tcp_to_decoy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionStats>(
            "SessionStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SessionStats {
    const NAME: &'static str = "SessionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                160 => {
                    self.failed_decoys_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.total_time_to_connect = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.rtt_to_station = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.tls_to_decoy = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.tcp_to_decoy = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.failed_decoys_amount {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.total_time_to_connect {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.rtt_to_station {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.tls_to_decoy {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.tcp_to_decoy {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.failed_decoys_amount {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.total_time_to_connect {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.rtt_to_station {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.tls_to_decoy {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.tcp_to_decoy {
            os.write_uint32(39, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SessionStats {
        SessionStats::new()
    }

    fn clear(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
        self.total_time_to_connect = ::std::option::Option::None;
        self.rtt_to_station = ::std::option::Option::None;
        self.tls_to_decoy = ::std::option::Option::None;
        self.tcp_to_decoy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SessionStats {
        static instance: SessionStats = SessionStats {
            failed_decoys_amount: ::std::option::Option::None,
            total_time_to_connect: ::std::option::Option::None,
            rtt_to_station: ::std::option::Option::None,
            tls_to_decoy: ::std::option::Option::None,
            tcp_to_decoy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SessionStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SessionStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.StationToDetector)
pub struct StationToDetector {
    // message fields
    // @@protoc_insertion_point(field:tapdance.StationToDetector.phantom_ip)
    pub phantom_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.StationToDetector.client_ip)
    pub client_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:tapdance.StationToDetector.timeout_ns)
    pub timeout_ns: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:tapdance.StationToDetector.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<StationOperations>>,
    // @@protoc_insertion_point(field:tapdance.StationToDetector.dst_port)
    pub dst_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.StationToDetector.src_port)
    pub src_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:tapdance.StationToDetector.proto)
    pub proto: ::std::option::Option<::protobuf::EnumOrUnknown<IPProto>>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.StationToDetector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StationToDetector {
    fn default() -> &'a StationToDetector {
        <StationToDetector as ::protobuf::Message>::default_instance()
    }
}

impl StationToDetector {
    pub fn new() -> StationToDetector {
        ::std::default::Default::default()
    }

    // optional string phantom_ip = 1;

    pub fn phantom_ip(&self) -> &str {
        match self.phantom_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phantom_ip(&mut self) {
        self.phantom_ip = ::std::option::Option::None;
    }

    pub fn has_phantom_ip(&self) -> bool {
        self.phantom_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phantom_ip(&mut self, v: ::std::string::String) {
        self.phantom_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phantom_ip(&mut self) -> &mut ::std::string::String {
        if self.phantom_ip.is_none() {
            self.phantom_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phantom_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_phantom_ip(&mut self) -> ::std::string::String {
        self.phantom_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string client_ip = 2;

    pub fn client_ip(&self) -> &str {
        match self.client_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_client_ip(&mut self) {
        self.client_ip = ::std::option::Option::None;
    }

    pub fn has_client_ip(&self) -> bool {
        self.client_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_ip(&mut self, v: ::std::string::String) {
        self.client_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_ip(&mut self) -> &mut ::std::string::String {
        if self.client_ip.is_none() {
            self.client_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.client_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_ip(&mut self) -> ::std::string::String {
        self.client_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timeout_ns = 3;

    pub fn timeout_ns(&self) -> u64 {
        self.timeout_ns.unwrap_or(0)
    }

    pub fn clear_timeout_ns(&mut self) {
        self.timeout_ns = ::std::option::Option::None;
    }

    pub fn has_timeout_ns(&self) -> bool {
        self.timeout_ns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ns(&mut self, v: u64) {
        self.timeout_ns = ::std::option::Option::Some(v);
    }

    // optional .tapdance.StationOperations operation = 4;

    pub fn operation(&self) -> StationOperations {
        match self.operation {
            Some(e) => e.enum_value_or(StationOperations::Unknown),
            None => StationOperations::Unknown,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: StationOperations) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 dst_port = 10;

    pub fn dst_port(&self) -> u32 {
        self.dst_port.unwrap_or(0)
    }

    pub fn clear_dst_port(&mut self) {
        self.dst_port = ::std::option::Option::None;
    }

    pub fn has_dst_port(&self) -> bool {
        self.dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_port(&mut self, v: u32) {
        self.dst_port = ::std::option::Option::Some(v);
    }

    // optional uint32 src_port = 11;

    pub fn src_port(&self) -> u32 {
        self.src_port.unwrap_or(0)
    }

    pub fn clear_src_port(&mut self) {
        self.src_port = ::std::option::Option::None;
    }

    pub fn has_src_port(&self) -> bool {
        self.src_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_port(&mut self, v: u32) {
        self.src_port = ::std::option::Option::Some(v);
    }

    // optional .tapdance.IPProto proto = 12;

    pub fn proto(&self) -> IPProto {
        match self.proto {
            Some(e) => e.enum_value_or(IPProto::Unk),
            None => IPProto::Unk,
        }
    }

    pub fn clear_proto(&mut self) {
        self.proto = ::std::option::Option::None;
    }

    pub fn has_proto(&self) -> bool {
        self.proto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proto(&mut self, v: IPProto) {
        self.proto = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phantom_ip",
            |m: &StationToDetector| { &m.phantom_ip },
            |m: &mut StationToDetector| { &mut m.phantom_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_ip",
            |m: &StationToDetector| { &m.client_ip },
            |m: &mut StationToDetector| { &mut m.client_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout_ns",
            |m: &StationToDetector| { &m.timeout_ns },
            |m: &mut StationToDetector| { &mut m.timeout_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &StationToDetector| { &m.operation },
            |m: &mut StationToDetector| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_port",
            |m: &StationToDetector| { &m.dst_port },
            |m: &mut StationToDetector| { &mut m.dst_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "src_port",
            |m: &StationToDetector| { &m.src_port },
            |m: &mut StationToDetector| { &mut m.src_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proto",
            |m: &StationToDetector| { &m.proto },
            |m: &mut StationToDetector| { &mut m.proto },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StationToDetector>(
            "StationToDetector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StationToDetector {
    const NAME: &'static str = "StationToDetector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phantom_ip = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.client_ip = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.timeout_ns = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.dst_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.src_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.proto = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phantom_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.client_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timeout_ns {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.dst_port {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.src_port {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.proto {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phantom_ip.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.client_ip.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.timeout_ns {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.operation {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.dst_port {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.src_port {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.proto {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StationToDetector {
        StationToDetector::new()
    }

    fn clear(&mut self) {
        self.phantom_ip = ::std::option::Option::None;
        self.client_ip = ::std::option::Option::None;
        self.timeout_ns = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.dst_port = ::std::option::Option::None;
        self.src_port = ::std::option::Option::None;
        self.proto = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StationToDetector {
        static instance: StationToDetector = StationToDetector {
            phantom_ip: ::std::option::Option::None,
            client_ip: ::std::option::Option::None,
            timeout_ns: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            dst_port: ::std::option::Option::None,
            src_port: ::std::option::Option::None,
            proto: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StationToDetector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StationToDetector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StationToDetector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToDetector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Adding message response from Station to Client for bidirectional API
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.RegistrationResponse)
pub struct RegistrationResponse {
    // message fields
    // @@protoc_insertion_point(field:tapdance.RegistrationResponse.ipv4addr)
    pub ipv4addr: ::std::option::Option<u32>,
    ///  The 128-bit ipv6 address, in network byte order
    // @@protoc_insertion_point(field:tapdance.RegistrationResponse.ipv6addr)
    pub ipv6addr: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  Respond with randomized port
    // @@protoc_insertion_point(field:tapdance.RegistrationResponse.dst_port)
    pub dst_port: ::std::option::Option<u32>,
    ///  Future: station provides client with secret, want chanel present
    ///  Leave null for now
    // @@protoc_insertion_point(field:tapdance.RegistrationResponse.serverRandom)
    pub serverRandom: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  If registration wrong, populate this error string
    // @@protoc_insertion_point(field:tapdance.RegistrationResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    ///  ClientConf field (optional)
    // @@protoc_insertion_point(field:tapdance.RegistrationResponse.clientConf)
    pub clientConf: ::protobuf::MessageField<ClientConf>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.RegistrationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegistrationResponse {
    fn default() -> &'a RegistrationResponse {
        <RegistrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationResponse {
    pub fn new() -> RegistrationResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ipv4addr = 1;

    pub fn ipv4addr(&self) -> u32 {
        self.ipv4addr.unwrap_or(0)
    }

    pub fn clear_ipv4addr(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
    }

    pub fn has_ipv4addr(&self) -> bool {
        self.ipv4addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4addr(&mut self, v: u32) {
        self.ipv4addr = ::std::option::Option::Some(v);
    }

    // optional bytes ipv6addr = 2;

    pub fn ipv6addr(&self) -> &[u8] {
        match self.ipv6addr.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ipv6addr(&mut self) {
        self.ipv6addr = ::std::option::Option::None;
    }

    pub fn has_ipv6addr(&self) -> bool {
        self.ipv6addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ipv6addr.is_none() {
            self.ipv6addr = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ipv6addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6addr(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6addr.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 dst_port = 3;

    pub fn dst_port(&self) -> u32 {
        self.dst_port.unwrap_or(0)
    }

    pub fn clear_dst_port(&mut self) {
        self.dst_port = ::std::option::Option::None;
    }

    pub fn has_dst_port(&self) -> bool {
        self.dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_port(&mut self, v: u32) {
        self.dst_port = ::std::option::Option::Some(v);
    }

    // optional bytes serverRandom = 4;

    pub fn serverRandom(&self) -> &[u8] {
        match self.serverRandom.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serverRandom(&mut self) {
        self.serverRandom = ::std::option::Option::None;
    }

    pub fn has_serverRandom(&self) -> bool {
        self.serverRandom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverRandom(&mut self, v: ::std::vec::Vec<u8>) {
        self.serverRandom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverRandom(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serverRandom.is_none() {
            self.serverRandom = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serverRandom.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverRandom(&mut self) -> ::std::vec::Vec<u8> {
        self.serverRandom.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string error = 5;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv4addr",
            |m: &RegistrationResponse| { &m.ipv4addr },
            |m: &mut RegistrationResponse| { &mut m.ipv4addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv6addr",
            |m: &RegistrationResponse| { &m.ipv6addr },
            |m: &mut RegistrationResponse| { &mut m.ipv6addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_port",
            |m: &RegistrationResponse| { &m.dst_port },
            |m: &mut RegistrationResponse| { &mut m.dst_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverRandom",
            |m: &RegistrationResponse| { &m.serverRandom },
            |m: &mut RegistrationResponse| { &mut m.serverRandom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &RegistrationResponse| { &m.error },
            |m: &mut RegistrationResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientConf>(
            "clientConf",
            |m: &RegistrationResponse| { &m.clientConf },
            |m: &mut RegistrationResponse| { &mut m.clientConf },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegistrationResponse>(
            "RegistrationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegistrationResponse {
    const NAME: &'static str = "RegistrationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ipv4addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.ipv6addr = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.dst_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.serverRandom = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientConf)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ipv4addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.dst_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.serverRandom.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.clientConf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ipv4addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.ipv6addr.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.dst_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.serverRandom.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.clientConf.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegistrationResponse {
        RegistrationResponse::new()
    }

    fn clear(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
        self.ipv6addr = ::std::option::Option::None;
        self.dst_port = ::std::option::Option::None;
        self.serverRandom = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.clientConf.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegistrationResponse {
        static instance: RegistrationResponse = RegistrationResponse {
            ipv4addr: ::std::option::Option::None,
            ipv6addr: ::std::option::Option::None,
            dst_port: ::std::option::Option::None,
            serverRandom: ::std::option::Option::None,
            error: ::std::option::Option::None,
            clientConf: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegistrationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegistrationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegistrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  response from dns
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tapdance.DnsResponse)
pub struct DnsResponse {
    // message fields
    // @@protoc_insertion_point(field:tapdance.DnsResponse.success)
    pub success: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:tapdance.DnsResponse.clientconf_outdated)
    pub clientconf_outdated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:tapdance.DnsResponse.bidirectional_response)
    pub bidirectional_response: ::protobuf::MessageField<RegistrationResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:tapdance.DnsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DnsResponse {
    fn default() -> &'a DnsResponse {
        <DnsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DnsResponse {
    pub fn new() -> DnsResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional bool clientconf_outdated = 2;

    pub fn clientconf_outdated(&self) -> bool {
        self.clientconf_outdated.unwrap_or(false)
    }

    pub fn clear_clientconf_outdated(&mut self) {
        self.clientconf_outdated = ::std::option::Option::None;
    }

    pub fn has_clientconf_outdated(&self) -> bool {
        self.clientconf_outdated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientconf_outdated(&mut self, v: bool) {
        self.clientconf_outdated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &DnsResponse| { &m.success },
            |m: &mut DnsResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientconf_outdated",
            |m: &DnsResponse| { &m.clientconf_outdated },
            |m: &mut DnsResponse| { &mut m.clientconf_outdated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RegistrationResponse>(
            "bidirectional_response",
            |m: &DnsResponse| { &m.bidirectional_response },
            |m: &mut DnsResponse| { &mut m.bidirectional_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DnsResponse>(
            "DnsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DnsResponse {
    const NAME: &'static str = "DnsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.clientconf_outdated = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bidirectional_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        if let Some(v) = self.clientconf_outdated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bidirectional_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.clientconf_outdated {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bidirectional_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DnsResponse {
        DnsResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.clientconf_outdated = ::std::option::Option::None;
        self.bidirectional_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DnsResponse {
        static instance: DnsResponse = DnsResponse {
            success: ::std::option::Option::None,
            clientconf_outdated: ::std::option::Option::None,
            bidirectional_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DnsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DnsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DnsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.KeyType)
pub enum KeyType {
    // @@protoc_insertion_point(enum_value:tapdance.KeyType.AES_GCM_128)
    AES_GCM_128 = 90,
    // @@protoc_insertion_point(enum_value:tapdance.KeyType.AES_GCM_256)
    AES_GCM_256 = 91,
}

impl ::protobuf::Enum for KeyType {
    const NAME: &'static str = "KeyType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyType> {
        match value {
            90 => ::std::option::Option::Some(KeyType::AES_GCM_128),
            91 => ::std::option::Option::Some(KeyType::AES_GCM_256),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeyType] = &[
        KeyType::AES_GCM_128,
        KeyType::AES_GCM_256,
    ];
}

impl ::protobuf::EnumFull for KeyType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeyType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            KeyType::AES_GCM_128 => 0,
            KeyType::AES_GCM_256 => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for KeyType {
    fn default() -> Self {
        KeyType::AES_GCM_128
    }
}

impl KeyType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeyType>("KeyType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.DnsRegMethod)
pub enum DnsRegMethod {
    // @@protoc_insertion_point(enum_value:tapdance.DnsRegMethod.UDP)
    UDP = 0,
    // @@protoc_insertion_point(enum_value:tapdance.DnsRegMethod.DOT)
    DOT = 1,
    // @@protoc_insertion_point(enum_value:tapdance.DnsRegMethod.DOH)
    DOH = 2,
}

impl ::protobuf::Enum for DnsRegMethod {
    const NAME: &'static str = "DnsRegMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DnsRegMethod> {
        match value {
            0 => ::std::option::Option::Some(DnsRegMethod::UDP),
            1 => ::std::option::Option::Some(DnsRegMethod::DOT),
            2 => ::std::option::Option::Some(DnsRegMethod::DOH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DnsRegMethod] = &[
        DnsRegMethod::UDP,
        DnsRegMethod::DOT,
        DnsRegMethod::DOH,
    ];
}

impl ::protobuf::EnumFull for DnsRegMethod {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DnsRegMethod").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DnsRegMethod {
    fn default() -> Self {
        DnsRegMethod::UDP
    }
}

impl DnsRegMethod {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DnsRegMethod>("DnsRegMethod")
    }
}

///  State transitions of the client
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.C2S_Transition)
pub enum C2S_Transition {
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_NO_CHANGE)
    C2S_NO_CHANGE = 0,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_SESSION_INIT)
    C2S_SESSION_INIT = 1,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_SESSION_COVERT_INIT)
    C2S_SESSION_COVERT_INIT = 11,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_EXPECT_RECONNECT)
    C2S_EXPECT_RECONNECT = 2,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_SESSION_CLOSE)
    C2S_SESSION_CLOSE = 3,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_YIELD_UPLOAD)
    C2S_YIELD_UPLOAD = 4,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_ACQUIRE_UPLOAD)
    C2S_ACQUIRE_UPLOAD = 5,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_EXPECT_UPLOADONLY_RECONN)
    C2S_EXPECT_UPLOADONLY_RECONN = 6,
    // @@protoc_insertion_point(enum_value:tapdance.C2S_Transition.C2S_ERROR)
    C2S_ERROR = 255,
}

impl ::protobuf::Enum for C2S_Transition {
    const NAME: &'static str = "C2S_Transition";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<C2S_Transition> {
        match value {
            0 => ::std::option::Option::Some(C2S_Transition::C2S_NO_CHANGE),
            1 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_INIT),
            11 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_RECONNECT),
            3 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_CLOSE),
            4 => ::std::option::Option::Some(C2S_Transition::C2S_YIELD_UPLOAD),
            5 => ::std::option::Option::Some(C2S_Transition::C2S_ACQUIRE_UPLOAD),
            6 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN),
            255 => ::std::option::Option::Some(C2S_Transition::C2S_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [C2S_Transition] = &[
        C2S_Transition::C2S_NO_CHANGE,
        C2S_Transition::C2S_SESSION_INIT,
        C2S_Transition::C2S_SESSION_COVERT_INIT,
        C2S_Transition::C2S_EXPECT_RECONNECT,
        C2S_Transition::C2S_SESSION_CLOSE,
        C2S_Transition::C2S_YIELD_UPLOAD,
        C2S_Transition::C2S_ACQUIRE_UPLOAD,
        C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN,
        C2S_Transition::C2S_ERROR,
    ];
}

impl ::protobuf::EnumFull for C2S_Transition {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("C2S_Transition").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            C2S_Transition::C2S_NO_CHANGE => 0,
            C2S_Transition::C2S_SESSION_INIT => 1,
            C2S_Transition::C2S_SESSION_COVERT_INIT => 2,
            C2S_Transition::C2S_EXPECT_RECONNECT => 3,
            C2S_Transition::C2S_SESSION_CLOSE => 4,
            C2S_Transition::C2S_YIELD_UPLOAD => 5,
            C2S_Transition::C2S_ACQUIRE_UPLOAD => 6,
            C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN => 7,
            C2S_Transition::C2S_ERROR => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for C2S_Transition {
    fn default() -> Self {
        C2S_Transition::C2S_NO_CHANGE
    }
}

impl C2S_Transition {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<C2S_Transition>("C2S_Transition")
    }
}

///  State transitions of the server
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.S2C_Transition)
pub enum S2C_Transition {
    // @@protoc_insertion_point(enum_value:tapdance.S2C_Transition.S2C_NO_CHANGE)
    S2C_NO_CHANGE = 0,
    // @@protoc_insertion_point(enum_value:tapdance.S2C_Transition.S2C_SESSION_INIT)
    S2C_SESSION_INIT = 1,
    // @@protoc_insertion_point(enum_value:tapdance.S2C_Transition.S2C_SESSION_COVERT_INIT)
    S2C_SESSION_COVERT_INIT = 11,
    // @@protoc_insertion_point(enum_value:tapdance.S2C_Transition.S2C_CONFIRM_RECONNECT)
    S2C_CONFIRM_RECONNECT = 2,
    // @@protoc_insertion_point(enum_value:tapdance.S2C_Transition.S2C_SESSION_CLOSE)
    S2C_SESSION_CLOSE = 3,
    // @@protoc_insertion_point(enum_value:tapdance.S2C_Transition.S2C_ERROR)
    S2C_ERROR = 255,
}

impl ::protobuf::Enum for S2C_Transition {
    const NAME: &'static str = "S2C_Transition";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<S2C_Transition> {
        match value {
            0 => ::std::option::Option::Some(S2C_Transition::S2C_NO_CHANGE),
            1 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_INIT),
            11 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(S2C_Transition::S2C_CONFIRM_RECONNECT),
            3 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_CLOSE),
            255 => ::std::option::Option::Some(S2C_Transition::S2C_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [S2C_Transition] = &[
        S2C_Transition::S2C_NO_CHANGE,
        S2C_Transition::S2C_SESSION_INIT,
        S2C_Transition::S2C_SESSION_COVERT_INIT,
        S2C_Transition::S2C_CONFIRM_RECONNECT,
        S2C_Transition::S2C_SESSION_CLOSE,
        S2C_Transition::S2C_ERROR,
    ];
}

impl ::protobuf::EnumFull for S2C_Transition {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("S2C_Transition").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            S2C_Transition::S2C_NO_CHANGE => 0,
            S2C_Transition::S2C_SESSION_INIT => 1,
            S2C_Transition::S2C_SESSION_COVERT_INIT => 2,
            S2C_Transition::S2C_CONFIRM_RECONNECT => 3,
            S2C_Transition::S2C_SESSION_CLOSE => 4,
            S2C_Transition::S2C_ERROR => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for S2C_Transition {
    fn default() -> Self {
        S2C_Transition::S2C_NO_CHANGE
    }
}

impl S2C_Transition {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<S2C_Transition>("S2C_Transition")
    }
}

///  Should accompany all S2C_ERROR messages.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.ErrorReasonS2C)
pub enum ErrorReasonS2C {
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.NO_ERROR)
    NO_ERROR = 0,
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.COVERT_STREAM)
    COVERT_STREAM = 1,
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.CLIENT_REPORTED)
    CLIENT_REPORTED = 2,
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.CLIENT_PROTOCOL)
    CLIENT_PROTOCOL = 3,
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.STATION_INTERNAL)
    STATION_INTERNAL = 4,
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.DECOY_OVERLOAD)
    DECOY_OVERLOAD = 5,
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.CLIENT_STREAM)
    CLIENT_STREAM = 100,
    // @@protoc_insertion_point(enum_value:tapdance.ErrorReasonS2C.CLIENT_TIMEOUT)
    CLIENT_TIMEOUT = 101,
}

impl ::protobuf::Enum for ErrorReasonS2C {
    const NAME: &'static str = "ErrorReasonS2C";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorReasonS2C> {
        match value {
            0 => ::std::option::Option::Some(ErrorReasonS2C::NO_ERROR),
            1 => ::std::option::Option::Some(ErrorReasonS2C::COVERT_STREAM),
            2 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_REPORTED),
            3 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_PROTOCOL),
            4 => ::std::option::Option::Some(ErrorReasonS2C::STATION_INTERNAL),
            5 => ::std::option::Option::Some(ErrorReasonS2C::DECOY_OVERLOAD),
            100 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_STREAM),
            101 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ErrorReasonS2C] = &[
        ErrorReasonS2C::NO_ERROR,
        ErrorReasonS2C::COVERT_STREAM,
        ErrorReasonS2C::CLIENT_REPORTED,
        ErrorReasonS2C::CLIENT_PROTOCOL,
        ErrorReasonS2C::STATION_INTERNAL,
        ErrorReasonS2C::DECOY_OVERLOAD,
        ErrorReasonS2C::CLIENT_STREAM,
        ErrorReasonS2C::CLIENT_TIMEOUT,
    ];
}

impl ::protobuf::EnumFull for ErrorReasonS2C {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ErrorReasonS2C").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ErrorReasonS2C::NO_ERROR => 0,
            ErrorReasonS2C::COVERT_STREAM => 1,
            ErrorReasonS2C::CLIENT_REPORTED => 2,
            ErrorReasonS2C::CLIENT_PROTOCOL => 3,
            ErrorReasonS2C::STATION_INTERNAL => 4,
            ErrorReasonS2C::DECOY_OVERLOAD => 5,
            ErrorReasonS2C::CLIENT_STREAM => 6,
            ErrorReasonS2C::CLIENT_TIMEOUT => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ErrorReasonS2C {
    fn default() -> Self {
        ErrorReasonS2C::NO_ERROR
    }
}

impl ErrorReasonS2C {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ErrorReasonS2C>("ErrorReasonS2C")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.TransportType)
pub enum TransportType {
    // @@protoc_insertion_point(enum_value:tapdance.TransportType.Null)
    Null = 0,
    // @@protoc_insertion_point(enum_value:tapdance.TransportType.Min)
    Min = 1,
    // @@protoc_insertion_point(enum_value:tapdance.TransportType.Obfs4)
    Obfs4 = 2,
    // @@protoc_insertion_point(enum_value:tapdance.TransportType.Webrtc)
    Webrtc = 99,
}

impl ::protobuf::Enum for TransportType {
    const NAME: &'static str = "TransportType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransportType> {
        match value {
            0 => ::std::option::Option::Some(TransportType::Null),
            1 => ::std::option::Option::Some(TransportType::Min),
            2 => ::std::option::Option::Some(TransportType::Obfs4),
            99 => ::std::option::Option::Some(TransportType::Webrtc),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TransportType] = &[
        TransportType::Null,
        TransportType::Min,
        TransportType::Obfs4,
        TransportType::Webrtc,
    ];
}

impl ::protobuf::EnumFull for TransportType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TransportType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TransportType::Null => 0,
            TransportType::Min => 1,
            TransportType::Obfs4 => 2,
            TransportType::Webrtc => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TransportType {
    fn default() -> Self {
        TransportType::Null
    }
}

impl TransportType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransportType>("TransportType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.RegistrationSource)
pub enum RegistrationSource {
    // @@protoc_insertion_point(enum_value:tapdance.RegistrationSource.Unspecified)
    Unspecified = 0,
    // @@protoc_insertion_point(enum_value:tapdance.RegistrationSource.Detector)
    Detector = 1,
    // @@protoc_insertion_point(enum_value:tapdance.RegistrationSource.API)
    API = 2,
    // @@protoc_insertion_point(enum_value:tapdance.RegistrationSource.DetectorPrescan)
    DetectorPrescan = 3,
    // @@protoc_insertion_point(enum_value:tapdance.RegistrationSource.BidirectionalAPI)
    BidirectionalAPI = 4,
    // @@protoc_insertion_point(enum_value:tapdance.RegistrationSource.DNS)
    DNS = 5,
    // @@protoc_insertion_point(enum_value:tapdance.RegistrationSource.BidirectionalDNS)
    BidirectionalDNS = 6,
}

impl ::protobuf::Enum for RegistrationSource {
    const NAME: &'static str = "RegistrationSource";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RegistrationSource> {
        match value {
            0 => ::std::option::Option::Some(RegistrationSource::Unspecified),
            1 => ::std::option::Option::Some(RegistrationSource::Detector),
            2 => ::std::option::Option::Some(RegistrationSource::API),
            3 => ::std::option::Option::Some(RegistrationSource::DetectorPrescan),
            4 => ::std::option::Option::Some(RegistrationSource::BidirectionalAPI),
            5 => ::std::option::Option::Some(RegistrationSource::DNS),
            6 => ::std::option::Option::Some(RegistrationSource::BidirectionalDNS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RegistrationSource] = &[
        RegistrationSource::Unspecified,
        RegistrationSource::Detector,
        RegistrationSource::API,
        RegistrationSource::DetectorPrescan,
        RegistrationSource::BidirectionalAPI,
        RegistrationSource::DNS,
        RegistrationSource::BidirectionalDNS,
    ];
}

impl ::protobuf::EnumFull for RegistrationSource {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RegistrationSource").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RegistrationSource {
    fn default() -> Self {
        RegistrationSource::Unspecified
    }
}

impl RegistrationSource {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RegistrationSource>("RegistrationSource")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.StationOperations)
pub enum StationOperations {
    // @@protoc_insertion_point(enum_value:tapdance.StationOperations.Unknown)
    Unknown = 0,
    // @@protoc_insertion_point(enum_value:tapdance.StationOperations.New)
    New = 1,
    // @@protoc_insertion_point(enum_value:tapdance.StationOperations.Update)
    Update = 2,
    // @@protoc_insertion_point(enum_value:tapdance.StationOperations.Clear)
    Clear = 3,
}

impl ::protobuf::Enum for StationOperations {
    const NAME: &'static str = "StationOperations";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StationOperations> {
        match value {
            0 => ::std::option::Option::Some(StationOperations::Unknown),
            1 => ::std::option::Option::Some(StationOperations::New),
            2 => ::std::option::Option::Some(StationOperations::Update),
            3 => ::std::option::Option::Some(StationOperations::Clear),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [StationOperations] = &[
        StationOperations::Unknown,
        StationOperations::New,
        StationOperations::Update,
        StationOperations::Clear,
    ];
}

impl ::protobuf::EnumFull for StationOperations {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("StationOperations").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for StationOperations {
    fn default() -> Self {
        StationOperations::Unknown
    }
}

impl StationOperations {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StationOperations>("StationOperations")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tapdance.IPProto)
pub enum IPProto {
    // @@protoc_insertion_point(enum_value:tapdance.IPProto.Unk)
    Unk = 0,
    // @@protoc_insertion_point(enum_value:tapdance.IPProto.Tcp)
    Tcp = 1,
    // @@protoc_insertion_point(enum_value:tapdance.IPProto.Udp)
    Udp = 2,
}

impl ::protobuf::Enum for IPProto {
    const NAME: &'static str = "IPProto";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IPProto> {
        match value {
            0 => ::std::option::Option::Some(IPProto::Unk),
            1 => ::std::option::Option::Some(IPProto::Tcp),
            2 => ::std::option::Option::Some(IPProto::Udp),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [IPProto] = &[
        IPProto::Unk,
        IPProto::Tcp,
        IPProto::Udp,
    ];
}

impl ::protobuf::EnumFull for IPProto {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("IPProto").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for IPProto {
    fn default() -> Self {
        IPProto::Unk
    }
}

impl IPProto {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<IPProto>("IPProto")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10signalling.proto\x12\x08tapdance\x1a\x19google/protobuf/any.proto\
    \"A\n\x06PubKey\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12%\n\x04\
    type\x18\x02\x20\x01(\x0e2\x11.tapdance.KeyTypeR\x04type\"\xbe\x01\n\x0c\
    TLSDecoySpec\x12\x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostname\x12\
    \x1a\n\x08ipv4addr\x18\x02\x20\x01(\x07R\x08ipv4addr\x12\x1a\n\x08ipv6ad\
    dr\x18\x06\x20\x01(\x0cR\x08ipv6addr\x12(\n\x06pubkey\x18\x03\x20\x01(\
    \x0b2\x10.tapdance.PubKeyR\x06pubkey\x12\x18\n\x07timeout\x18\x04\x20\
    \x01(\rR\x07timeout\x12\x16\n\x06tcpwin\x18\x05\x20\x01(\rR\x06tcpwin\"\
    \xa2\x02\n\nClientConf\x122\n\ndecoy_list\x18\x01\x20\x01(\x0b2\x13.tapd\
    ance.DecoyListR\tdecoyList\x12\x1e\n\ngeneration\x18\x02\x20\x01(\rR\nge\
    neration\x127\n\x0edefault_pubkey\x18\x03\x20\x01(\x0b2\x10.tapdance.Pub\
    KeyR\rdefaultPubkey\x12N\n\x14phantom_subnets_list\x18\x04\x20\x01(\x0b2\
    \x1c.tapdance.PhantomSubnetsListR\x12phantomSubnetsList\x127\n\x0econjur\
    e_pubkey\x18\x05\x20\x01(\x0b2\x10.tapdance.PubKeyR\rconjurePubkey\"\x97\
    \x02\n\nDnsRegConf\x12<\n\x0edns_reg_method\x18\x01\x20\x02(\x0e2\x16.ta\
    pdance.DnsRegMethodR\x0cdnsRegMethod\x12\x19\n\x08udp_addr\x18\x02\x20\
    \x01(\tR\x07udpAddr\x12\x19\n\x08dot_addr\x18\x03\x20\x01(\tR\x07dotAddr\
    \x12\x17\n\x07doh_url\x18\x04\x20\x01(\tR\x06dohUrl\x12\x16\n\x06domain\
    \x18\x05\x20\x02(\tR\x06domain\x12\x16\n\x06pubkey\x18\x06\x20\x01(\x0cR\
    \x06pubkey\x12+\n\x11utls_distribution\x18\x07\x20\x01(\tR\x10utlsDistri\
    bution\x12\x1f\n\x0bstun_server\x18\x08\x20\x01(\tR\nstunServer\"B\n\tDe\
    coyList\x125\n\ntls_decoys\x18\x01\x20\x03(\x0b2\x16.tapdance.TLSDecoySp\
    ecR\ttlsDecoys\"Y\n\x12PhantomSubnetsList\x12C\n\x10weighted_subnets\x18\
    \x01\x20\x03(\x0b2\x18.tapdance.PhantomSubnetsR\x0fweightedSubnets\"B\n\
    \x0ePhantomSubnets\x12\x16\n\x06weight\x18\x01\x20\x01(\rR\x06weight\x12\
    \x18\n\x07subnets\x18\x02\x20\x03(\tR\x07subnets\"o\n\x12WebRTCICECandid\
    ate\x12\x19\n\x08ip_upper\x18\x01\x20\x02(\x04R\x07ipUpper\x12\x19\n\x08\
    ip_lower\x18\x02\x20\x02(\x04R\x07ipLower\x12#\n\rcomposed_info\x18\x03\
    \x20\x02(\rR\x0ccomposedInfo\"]\n\tWebRTCSDP\x12\x12\n\x04type\x18\x01\
    \x20\x02(\rR\x04type\x12<\n\ncandidates\x18\x02\x20\x03(\x0b2\x1c.tapdan\
    ce.WebRTCICECandidateR\ncandidates\"I\n\x0cWebRTCSignal\x12\x12\n\x04see\
    d\x18\x01\x20\x02(\tR\x04seed\x12%\n\x03sdp\x18\x02\x20\x02(\x0b2\x13.ta\
    pdance.WebRTCSDPR\x03sdp\"\xcb\x02\n\x0fStationToClient\x12)\n\x10protoc\
    ol_version\x18\x01\x20\x01(\rR\x0fprotocolVersion\x12C\n\x10state_transi\
    tion\x18\x02\x20\x01(\x0e2\x18.tapdance.S2C_TransitionR\x0fstateTransiti\
    on\x125\n\x0bconfig_info\x18\x03\x20\x01(\x0b2\x14.tapdance.ClientConfR\
    \nconfigInfo\x127\n\nerr_reason\x18\x04\x20\x01(\x0e2\x18.tapdance.Error\
    ReasonS2CR\terrReason\x12\x1f\n\x0btmp_backoff\x18\x05\x20\x01(\rR\ntmpB\
    ackoff\x12\x1d\n\nstation_id\x18\x06\x20\x01(\tR\tstationId\x12\x18\n\
    \x07padding\x18d\x20\x01(\x0cR\x07padding\"\xaf\x01\n\x11RegistrationFla\
    gs\x12\x1f\n\x0bupload_only\x18\x01\x20\x01(\x08R\nuploadOnly\x12\x1d\n\
    \ndark_decoy\x18\x02\x20\x01(\x08R\tdarkDecoy\x12!\n\x0cproxy_header\x18\
    \x03\x20\x01(\x08R\x0bproxyHeader\x12\x17\n\x07use_TIL\x18\x04\x20\x01(\
    \x08R\x06useTIL\x12\x1e\n\nprescanned\x18\x05\x20\x01(\x08R\nprescanned\
    \"\xf7\x05\n\x0fClientToStation\x12)\n\x10protocol_version\x18\x01\x20\
    \x01(\rR\x0fprotocolVersion\x122\n\x15decoy_list_generation\x18\x02\x20\
    \x01(\rR\x13decoyListGeneration\x12C\n\x10state_transition\x18\x03\x20\
    \x01(\x0e2\x18.tapdance.C2S_TransitionR\x0fstateTransition\x12\x1f\n\x0b\
    upload_sync\x18\x04\x20\x01(\x04R\nuploadSync\x12,\n\x12client_lib_versi\
    on\x18\x05\x20\x01(\rR\x10clientLibVersion\x12#\n\rfailed_decoys\x18\n\
    \x20\x03(\tR\x0cfailedDecoys\x12,\n\x05stats\x18\x0b\x20\x01(\x0b2\x16.t\
    apdance.SessionStatsR\x05stats\x125\n\ttransport\x18\x0c\x20\x01(\x0e2\
    \x17.tapdance.TransportTypeR\ttransport\x12?\n\x10transport_params\x18\r\
    \x20\x01(\x0b2\x14.google.protobuf.AnyR\x0ftransportParams\x12%\n\x0ecov\
    ert_address\x18\x14\x20\x01(\tR\rcovertAddress\x127\n\x18masked_decoy_se\
    rver_name\x18\x15\x20\x01(\tR\x15maskedDecoyServerName\x12\x1d\n\nv6_sup\
    port\x18\x16\x20\x01(\x08R\tv6Support\x12\x1d\n\nv4_support\x18\x17\x20\
    \x01(\x08R\tv4Support\x121\n\x05flags\x18\x18\x20\x01(\x0b2\x1b.tapdance\
    .RegistrationFlagsR\x05flags\x12;\n\rwebrtc_signal\x18\x1f\x20\x01(\x0b2\
    \x16.tapdance.WebRTCSignalR\x0cwebrtcSignal\x12\x18\n\x07padding\x18d\
    \x20\x01(\x0cR\x07padding\"F\n\x16GenericTransportParams\x12,\n\x12rando\
    mize_dst_port\x18\r\x20\x01(\x08R\x10randomizeDstPort\"\xfb\x02\n\nC2SWr\
    apper\x12#\n\rshared_secret\x18\x01\x20\x01(\x0cR\x0csharedSecret\x12L\n\
    \x14registration_payload\x18\x03\x20\x01(\x0b2\x19.tapdance.ClientToStat\
    ionR\x13registrationPayload\x12M\n\x13registration_source\x18\x04\x20\
    \x01(\x0e2\x1c.tapdance.RegistrationSourceR\x12registrationSource\x121\n\
    \x14registration_address\x18\x06\x20\x01(\x0cR\x13registrationAddress\
    \x12#\n\rdecoy_address\x18\x07\x20\x01(\x0cR\x0cdecoyAddress\x12S\n\x15r\
    egistration_response\x18\x08\x20\x01(\x0b2\x1e.tapdance.RegistrationResp\
    onseR\x14registrationResponse\"\xdd\x01\n\x0cSessionStats\x120\n\x14fail\
    ed_decoys_amount\x18\x14\x20\x01(\rR\x12failedDecoysAmount\x121\n\x15tot\
    al_time_to_connect\x18\x1f\x20\x01(\rR\x12totalTimeToConnect\x12$\n\x0er\
    tt_to_station\x18!\x20\x01(\rR\x0crttToStation\x12\x20\n\x0ctls_to_decoy\
    \x18&\x20\x01(\rR\ntlsToDecoy\x12\x20\n\x0ctcp_to_decoy\x18'\x20\x01(\rR\
    \ntcpToDecoy\"\x88\x02\n\x11StationToDetector\x12\x1d\n\nphantom_ip\x18\
    \x01\x20\x01(\tR\tphantomIp\x12\x1b\n\tclient_ip\x18\x02\x20\x01(\tR\x08\
    clientIp\x12\x1d\n\ntimeout_ns\x18\x03\x20\x01(\x04R\ttimeoutNs\x129\n\t\
    operation\x18\x04\x20\x01(\x0e2\x1b.tapdance.StationOperationsR\toperati\
    on\x12\x19\n\x08dst_port\x18\n\x20\x01(\rR\x07dstPort\x12\x19\n\x08src_p\
    ort\x18\x0b\x20\x01(\rR\x07srcPort\x12'\n\x05proto\x18\x0c\x20\x01(\x0e2\
    \x11.tapdance.IPProtoR\x05proto\"\xd9\x01\n\x14RegistrationResponse\x12\
    \x1a\n\x08ipv4addr\x18\x01\x20\x01(\x07R\x08ipv4addr\x12\x1a\n\x08ipv6ad\
    dr\x18\x02\x20\x01(\x0cR\x08ipv6addr\x12\x19\n\x08dst_port\x18\x03\x20\
    \x01(\rR\x07dstPort\x12\"\n\x0cserverRandom\x18\x04\x20\x01(\x0cR\x0cser\
    verRandom\x12\x14\n\x05error\x18\x05\x20\x01(\tR\x05error\x124\n\nclient\
    Conf\x18\x06\x20\x01(\x0b2\x14.tapdance.ClientConfR\nclientConf\"\xaf\
    \x01\n\x0bDnsResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07succ\
    ess\x12/\n\x13clientconf_outdated\x18\x02\x20\x01(\x08R\x12clientconfOut\
    dated\x12U\n\x16bidirectional_response\x18\x03\x20\x01(\x0b2\x1e.tapdanc\
    e.RegistrationResponseR\x15bidirectionalResponse*+\n\x07KeyType\x12\x0f\
    \n\x0bAES_GCM_128\x10Z\x12\x0f\n\x0bAES_GCM_256\x10[*)\n\x0cDnsRegMethod\
    \x12\x07\n\x03UDP\x10\0\x12\x07\n\x03DOT\x10\x01\x12\x07\n\x03DOH\x10\
    \x02*\xe7\x01\n\x0eC2S_Transition\x12\x11\n\rC2S_NO_CHANGE\x10\0\x12\x14\
    \n\x10C2S_SESSION_INIT\x10\x01\x12\x1b\n\x17C2S_SESSION_COVERT_INIT\x10\
    \x0b\x12\x18\n\x14C2S_EXPECT_RECONNECT\x10\x02\x12\x15\n\x11C2S_SESSION_\
    CLOSE\x10\x03\x12\x14\n\x10C2S_YIELD_UPLOAD\x10\x04\x12\x16\n\x12C2S_ACQ\
    UIRE_UPLOAD\x10\x05\x12\x20\n\x1cC2S_EXPECT_UPLOADONLY_RECONN\x10\x06\
    \x12\x0e\n\tC2S_ERROR\x10\xff\x01*\x98\x01\n\x0eS2C_Transition\x12\x11\n\
    \rS2C_NO_CHANGE\x10\0\x12\x14\n\x10S2C_SESSION_INIT\x10\x01\x12\x1b\n\
    \x17S2C_SESSION_COVERT_INIT\x10\x0b\x12\x19\n\x15S2C_CONFIRM_RECONNECT\
    \x10\x02\x12\x15\n\x11S2C_SESSION_CLOSE\x10\x03\x12\x0e\n\tS2C_ERROR\x10\
    \xff\x01*\xac\x01\n\x0eErrorReasonS2C\x12\x0c\n\x08NO_ERROR\x10\0\x12\
    \x11\n\rCOVERT_STREAM\x10\x01\x12\x13\n\x0fCLIENT_REPORTED\x10\x02\x12\
    \x13\n\x0fCLIENT_PROTOCOL\x10\x03\x12\x14\n\x10STATION_INTERNAL\x10\x04\
    \x12\x12\n\x0eDECOY_OVERLOAD\x10\x05\x12\x11\n\rCLIENT_STREAM\x10d\x12\
    \x12\n\x0eCLIENT_TIMEOUT\x10e*9\n\rTransportType\x12\x08\n\x04Null\x10\0\
    \x12\x07\n\x03Min\x10\x01\x12\t\n\x05Obfs4\x10\x02\x12\n\n\x06Webrtc\x10\
    c*\x86\x01\n\x12RegistrationSource\x12\x0f\n\x0bUnspecified\x10\0\x12\
    \x0c\n\x08Detector\x10\x01\x12\x07\n\x03API\x10\x02\x12\x13\n\x0fDetecto\
    rPrescan\x10\x03\x12\x14\n\x10BidirectionalAPI\x10\x04\x12\x07\n\x03DNS\
    \x10\x05\x12\x14\n\x10BidirectionalDNS\x10\x06*@\n\x11StationOperations\
    \x12\x0b\n\x07Unknown\x10\0\x12\x07\n\x03New\x10\x01\x12\n\n\x06Update\
    \x10\x02\x12\t\n\x05Clear\x10\x03*$\n\x07IPProto\x12\x07\n\x03Unk\x10\0\
    \x12\x07\n\x03Tcp\x10\x01\x12\x07\n\x03Udp\x10\x02J\x8fy\n\x07\x12\x05\0\
    \0\xf3\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\xb0\x01\n\x01\x02\x12\
    \x03\x06\0\x112\xa5\x01\x20TODO:\x20We're\x20using\x20proto2\x20because\
    \x20it's\x20the\x20default\x20on\x20Ubuntu\x2016.04.\n\x20At\x20some\x20\
    point\x20we\x20will\x20want\x20to\x20migrate\x20to\x20proto3,\x20but\x20\
    we\x20are\x20not\n\x20using\x20any\x20proto3\x20features\x20yet.\n\n\t\n\
    \x02\x03\0\x12\x03\x08\0#\n\n\n\x02\x05\0\x12\x04\n\0\r\x01\n\n\n\x03\
    \x05\0\x01\x12\x03\n\x05\x0c\n\x0b\n\x04\x05\0\x02\0\x12\x03\x0b\x04\x15\
    \n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x0b\x04\x0f\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03\x0b\x12\x14\n\x20\n\x04\x05\0\x02\x01\x12\x03\x0c\x04\x15\"\
    \x13\x20not\x20supported\x20atm\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\
    \x0c\x04\x0f\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x0c\x12\x14\n\n\n\x02\
    \x04\0\x12\x04\x0f\0\x14\x01\n\n\n\x03\x04\0\x01\x12\x03\x0f\x08\x0e\n4\
    \n\x04\x04\0\x02\0\x12\x03\x11\x04\x1b\x1a'\x20A\x20public\x20key,\x20as\
    \x20used\x20by\x20the\x20station.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\
    \x11\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x11\r\x12\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\x11\x13\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \x11\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x13\x04\x1e\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x06\x12\
    \x03\x13\r\x14\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x13\x15\x19\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\x13\x1c\x1d\n\n\n\x02\x04\x01\x12\x04\x16\
    \0<\x01\n\n\n\x03\x04\x01\x01\x12\x03\x16\x08\x14\n\xa1\x01\n\x04\x04\
    \x01\x02\0\x12\x03\x1b\x04!\x1a\x93\x01\x20The\x20hostname/SNI\x20to\x20\
    use\x20for\x20this\x20host\n\n\x20The\x20hostname\x20is\x20the\x20only\
    \x20required\x20field,\x20although\x20other\n\x20fields\x20are\x20expect\
    ed\x20to\x20be\x20present\x20in\x20most\x20cases.\n\n\x0c\n\x05\x04\x01\
    \x02\0\x04\x12\x03\x1b\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1b\
    \r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1b\x14\x1c\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03\x1b\x1f\x20\n\xf7\x01\n\x04\x04\x01\x02\x01\x12\
    \x03\"\x04\"\x1a\xe9\x01\x20The\x2032-bit\x20ipv4\x20address,\x20in\x20n\
    etwork\x20byte\x20order\n\n\x20If\x20the\x20IPv4\x20address\x20is\x20abs\
    ent,\x20then\x20it\x20may\x20be\x20resolved\x20via\n\x20DNS\x20by\x20the\
    \x20client,\x20or\x20the\x20client\x20may\x20discard\x20this\x20decoy\
    \x20spec\n\x20if\x20local\x20DNS\x20is\x20untrusted,\x20or\x20the\x20ser\
    vice\x20may\x20be\x20multihomed.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03\"\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\"\r\x14\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03\"\x15\x1d\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\"\x20!\n>\n\x04\x04\x01\x02\x02\x12\x03%\x04\x20\x1a1\x20Th\
    e\x20128-bit\x20ipv6\x20address,\x20in\x20network\x20byte\x20order\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x04\x12\x03%\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \x02\x05\x12\x03%\r\x12\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03%\x13\x1b\
    \n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03%\x1e\x1f\n\x91\x01\n\x04\x04\
    \x01\x02\x03\x12\x03+\x04\x1f\x1a\x83\x01\x20The\x20Tapdance\x20station\
    \x20public\x20key\x20to\x20use\x20when\x20contacting\x20this\n\x20decoy\
    \n\n\x20If\x20omitted,\x20the\x20default\x20station\x20public\x20key\x20\
    (if\x20any)\x20is\x20used.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03+\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03+\r\x13\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03+\x14\x1a\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03+\x1d\x1e\n\xee\x01\n\x04\x04\x01\x02\x04\x12\x032\x04\x20\x1a\xe0\
    \x01\x20The\x20maximum\x20duration,\x20in\x20milliseconds,\x20to\x20main\
    tain\x20an\x20open\n\x20connection\x20to\x20this\x20decoy\x20(because\
    \x20the\x20decoy\x20may\x20close\x20the\n\x20connection\x20itself\x20aft\
    er\x20this\x20length\x20of\x20time)\n\n\x20If\x20omitted,\x20a\x20defaul\
    t\x20of\x2030,000\x20milliseconds\x20is\x20assumed.\n\n\x0c\n\x05\x04\
    \x01\x02\x04\x04\x12\x032\x04\x0c\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\
    \x032\r\x13\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x032\x14\x1b\n\x0c\n\x05\
    \x04\x01\x02\x04\x03\x12\x032\x1e\x1f\n\xb0\x02\n\x04\x04\x01\x02\x05\
    \x12\x03;\x04\x1f\x1a\xa2\x02\x20The\x20maximum\x20TCP\x20window\x20size\
    \x20to\x20attempt\x20to\x20use\x20for\x20this\x20decoy.\n\n\x20If\x20omi\
    tted,\x20a\x20default\x20of\x2015360\x20is\x20assumed.\n\n\x20TODO:\x20t\
    he\x20default\x20is\x20based\x20on\x20the\x20current\x20heuristic\x20of\
    \x20only\n\x20using\x20decoys\x20that\x20permit\x20windows\x20of\x2015KB\
    \x20or\x20larger.\x20\x20If\x20this\n\x20heuristic\x20changes,\x20then\
    \x20this\x20default\x20doesn't\x20make\x20sense.\n\n\x0c\n\x05\x04\x01\
    \x02\x05\x04\x12\x03;\x04\x0c\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03;\r\
    \x13\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03;\x14\x1a\n\x0c\n\x05\x04\
    \x01\x02\x05\x03\x12\x03;\x1d\x1e\n\x83\x08\n\x02\x04\x02\x12\x04S\0Y\
    \x012\xf6\x07\x20In\x20version\x201,\x20the\x20request\x20is\x20very\x20\
    simple:\x20when\n\x20the\x20client\x20sends\x20a\x20MSG_PROTO\x20to\x20t\
    he\x20station,\x20if\x20the\n\x20generation\x20number\x20is\x20present,\
    \x20then\x20this\x20request\x20includes\n\x20(in\x20addition\x20to\x20wh\
    atever\x20other\x20operations\x20are\x20part\x20of\x20the\n\x20request)\
    \x20a\x20request\x20for\x20the\x20station\x20to\x20send\x20a\x20copy\x20\
    of\n\x20the\x20current\x20decoy\x20set\x20that\x20has\x20a\x20generation\
    \x20number\x20greater\n\x20than\x20the\x20generation\x20number\x20in\x20\
    its\x20request.\n\n\x20If\x20the\x20response\x20contains\x20a\x20DecoyLi\
    stUpdate\x20with\x20a\x20generation\x20number\x20equal\n\x20to\x20that\
    \x20which\x20the\x20client\x20sent,\x20then\x20the\x20client\x20is\x20\"\
    caught\x20up\"\x20with\n\x20the\x20station\x20and\x20the\x20response\x20\
    contains\x20no\x20new\x20information\n\x20(and\x20all\x20other\x20fields\
    \x20may\x20be\x20omitted\x20or\x20empty).\x20\x20Otherwise,\n\x20the\x20\
    station\x20will\x20send\x20the\x20latest\x20configuration\x20information\
    ,\n\x20along\x20with\x20its\x20generation\x20number.\n\n\x20The\x20stati\
    on\x20can\x20also\x20send\x20ClientConf\x20messages\n\x20(as\x20part\x20\
    of\x20Station2Client\x20messages)\x20whenever\x20it\x20wants.\n\x20The\
    \x20client\x20is\x20expected\x20to\x20react\x20as\x20if\x20it\x20had\x20\
    requested\n\x20such\x20messages\x20--\x20possibly\x20by\x20ignoring\x20t\
    hem,\x20if\x20the\x20client\n\x20is\x20already\x20up-to-date\x20accordin\
    g\x20to\x20the\x20generation\x20number.\n\n\n\n\x03\x04\x02\x01\x12\x03S\
    \x08\x12\n\x0b\n\x04\x04\x02\x02\0\x12\x03T\x04&\n\x0c\n\x05\x04\x02\x02\
    \0\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03T\r\x16\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03T\x17!\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03T$%\n\x0b\n\x04\x04\x02\x02\x01\x12\x03U\x04#\n\x0c\n\x05\x04\
    \x02\x02\x01\x04\x12\x03U\x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\
    \x03U\r\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03U\x14\x1e\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03U!\"\n\x0b\n\x04\x04\x02\x02\x02\x12\x03V\
    \x04'\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03V\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x02\x06\x12\x03V\r\x13\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03V\
    \x14\"\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03V%&\n\x0b\n\x04\x04\x02\
    \x02\x03\x12\x03W\x049\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03W\x04\x0c\
    \n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03W\r\x1f\n\x0c\n\x05\x04\x02\x02\
    \x03\x01\x12\x03W\x204\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03W78\n\x0b\
    \n\x04\x04\x02\x02\x04\x12\x03X\x04'\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\
    \x03X\x04\x0c\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03X\r\x13\n\x0c\n\x05\
    \x04\x02\x02\x04\x01\x12\x03X\x14\"\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\
    \x03X%&\n-\n\x02\x04\x03\x12\x04\\\0e\x01\x1a!\x20Configuration\x20for\
    \x20DNS\x20registrar\n\n\n\n\x03\x04\x03\x01\x12\x03\\\x08\x12\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x03]\x04-\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03]\
    \x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03]\r\x19\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03]\x1a(\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03]+,\n\
    \x0b\n\x04\x04\x03\x02\x01\x12\x03^\x04!\n\x0c\n\x05\x04\x03\x02\x01\x04\
    \x12\x03^\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03^\r\x13\n\x0c\n\
    \x05\x04\x03\x02\x01\x01\x12\x03^\x14\x1c\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03^\x1f\x20\n\x0b\n\x04\x04\x03\x02\x02\x12\x03_\x04!\n\x0c\n\
    \x05\x04\x03\x02\x02\x04\x12\x03_\x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\
    \x05\x12\x03_\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03_\x14\x1c\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03_\x1f\x20\n\x0b\n\x04\x04\x03\x02\
    \x03\x12\x03`\x04\x20\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03`\x04\x0c\n\
    \x0c\n\x05\x04\x03\x02\x03\x05\x12\x03`\r\x13\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03`\x14\x1b\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03`\x1e\
    \x1f\n\x0b\n\x04\x04\x03\x02\x04\x12\x03a\x04\x1f\n\x0c\n\x05\x04\x03\
    \x02\x04\x04\x12\x03a\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03a\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03a\x14\x1a\n\x0c\n\x05\x04\
    \x03\x02\x04\x03\x12\x03a\x1d\x1e\n\x0b\n\x04\x04\x03\x02\x05\x12\x03b\
    \x04\x1e\n\x0c\n\x05\x04\x03\x02\x05\x04\x12\x03b\x04\x0c\n\x0c\n\x05\
    \x04\x03\x02\x05\x05\x12\x03b\r\x12\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\
    \x03b\x13\x19\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03b\x1c\x1d\n\x0b\n\
    \x04\x04\x03\x02\x06\x12\x03c\x04*\n\x0c\n\x05\x04\x03\x02\x06\x04\x12\
    \x03c\x04\x0c\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x03c\r\x13\n\x0c\n\x05\
    \x04\x03\x02\x06\x01\x12\x03c\x14%\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\
    \x03c()\n\x0b\n\x04\x04\x03\x02\x07\x12\x03d\x04$\n\x0c\n\x05\x04\x03\
    \x02\x07\x04\x12\x03d\x04\x0c\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03d\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03d\x14\x1f\n\x0c\n\x05\x04\
    \x03\x02\x07\x03\x12\x03d\"#\n\n\n\x02\x05\x01\x12\x04g\0k\x01\n\n\n\x03\
    \x05\x01\x01\x12\x03g\x05\x11\n\x0b\n\x04\x05\x01\x02\0\x12\x03h\x04\x0c\
    \n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03h\x04\x07\n\x0c\n\x05\x05\x01\x02\
    \0\x02\x12\x03h\n\x0b\n\x0b\n\x04\x05\x01\x02\x01\x12\x03i\x04\x0c\n\x0c\
    \n\x05\x05\x01\x02\x01\x01\x12\x03i\x04\x07\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03i\n\x0b\n\x0b\n\x04\x05\x01\x02\x02\x12\x03j\x04\x0c\n\x0c\n\
    \x05\x05\x01\x02\x02\x01\x12\x03j\x04\x07\n\x0c\n\x05\x05\x01\x02\x02\
    \x02\x12\x03j\n\x0b\n\n\n\x02\x04\x04\x12\x04m\0o\x01\n\n\n\x03\x04\x04\
    \x01\x12\x03m\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03n\x04)\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x03n\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\
    \x12\x03n\r\x19\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03n\x1a$\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03n'(\n\n\n\x02\x04\x05\x12\x04q\0s\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03q\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03r\x04\
    1\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03r\x04\x0c\n\x0c\n\x05\x04\x05\x02\
    \0\x06\x12\x03r\r\x1b\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03r\x1c,\n\x0c\
    \n\x05\x04\x05\x02\0\x03\x12\x03r/0\n\n\n\x02\x04\x06\x12\x04u\0x\x01\n\
    \n\n\x03\x04\x06\x01\x12\x03u\x08\x16\n\x0b\n\x04\x04\x06\x02\0\x12\x03v\
    \x04\x1f\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03v\x04\x0c\n\x0c\n\x05\x04\
    \x06\x02\0\x05\x12\x03v\r\x13\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03v\x14\
    \x1a\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03v\x1d\x1e\n\x0b\n\x04\x04\x06\
    \x02\x01\x12\x03w\x04\x20\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03w\x04\
    \x0c\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03w\r\x13\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03w\x14\x1b\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03w\
    \x1e\x1f\n.\n\x02\x05\x02\x12\x05{\0\x85\x01\x01\x1a!\x20State\x20transi\
    tions\x20of\x20the\x20client\n\n\n\n\x03\x05\x02\x01\x12\x03{\x05\x13\n\
    \x0b\n\x04\x05\x02\x02\0\x12\x03|\x04\x16\n\x0c\n\x05\x05\x02\x02\0\x01\
    \x12\x03|\x04\x11\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03|\x14\x15\n\"\n\
    \x04\x05\x02\x02\x01\x12\x03}\x04\x19\"\x15\x20connect\x20me\x20to\x20sq\
    uid\n\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03}\x04\x14\n\x0c\n\x05\x05\
    \x02\x02\x01\x02\x12\x03}\x17\x18\n,\n\x04\x05\x02\x02\x02\x12\x03~\x04!\
    \"\x1f\x20connect\x20me\x20to\x20provided\x20covert\n\n\x0c\n\x05\x05\
    \x02\x02\x02\x01\x12\x03~\x04\x1b\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\
    \x03~\x1e\x20\n\x0b\n\x04\x05\x02\x02\x03\x12\x03\x7f\x04\x1d\n\x0c\n\
    \x05\x05\x02\x02\x03\x01\x12\x03\x7f\x04\x18\n\x0c\n\x05\x05\x02\x02\x03\
    \x02\x12\x03\x7f\x1b\x1c\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\x80\x01\x04\
    \x1a\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\x80\x01\x04\x15\n\r\n\x05\x05\
    \x02\x02\x04\x02\x12\x04\x80\x01\x18\x19\n\x0c\n\x04\x05\x02\x02\x05\x12\
    \x04\x81\x01\x04\x19\n\r\n\x05\x05\x02\x02\x05\x01\x12\x04\x81\x01\x04\
    \x14\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\x81\x01\x17\x18\n\x0c\n\x04\
    \x05\x02\x02\x06\x12\x04\x82\x01\x04\x1b\n\r\n\x05\x05\x02\x02\x06\x01\
    \x12\x04\x82\x01\x04\x16\n\r\n\x05\x05\x02\x02\x06\x02\x12\x04\x82\x01\
    \x19\x1a\n\x0c\n\x04\x05\x02\x02\x07\x12\x04\x83\x01\x04%\n\r\n\x05\x05\
    \x02\x02\x07\x01\x12\x04\x83\x01\x04\x20\n\r\n\x05\x05\x02\x02\x07\x02\
    \x12\x04\x83\x01#$\n\x0c\n\x04\x05\x02\x02\x08\x12\x04\x84\x01\x04\x14\n\
    \r\n\x05\x05\x02\x02\x08\x01\x12\x04\x84\x01\x04\r\n\r\n\x05\x05\x02\x02\
    \x08\x02\x12\x04\x84\x01\x10\x13\n/\n\x02\x05\x03\x12\x06\x88\x01\0\x90\
    \x01\x01\x1a!\x20State\x20transitions\x20of\x20the\x20server\n\n\x0b\n\
    \x03\x05\x03\x01\x12\x04\x88\x01\x05\x13\n\x0c\n\x04\x05\x03\x02\0\x12\
    \x04\x89\x01\x04\x16\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\x89\x01\x04\x11\
    \n\r\n\x05\x05\x03\x02\0\x02\x12\x04\x89\x01\x14\x15\n\"\n\x04\x05\x03\
    \x02\x01\x12\x04\x8a\x01\x04\x19\"\x14\x20connected\x20to\x20squid\n\n\r\
    \n\x05\x05\x03\x02\x01\x01\x12\x04\x8a\x01\x04\x14\n\r\n\x05\x05\x03\x02\
    \x01\x02\x12\x04\x8a\x01\x17\x18\n(\n\x04\x05\x03\x02\x02\x12\x04\x8b\
    \x01\x04!\"\x1a\x20connected\x20to\x20covert\x20host\n\n\r\n\x05\x05\x03\
    \x02\x02\x01\x12\x04\x8b\x01\x04\x1b\n\r\n\x05\x05\x03\x02\x02\x02\x12\
    \x04\x8b\x01\x1e\x20\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\x8c\x01\x04\x1e\
    \n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\x8c\x01\x04\x19\n\r\n\x05\x05\x03\
    \x02\x03\x02\x12\x04\x8c\x01\x1c\x1d\n\x0c\n\x04\x05\x03\x02\x04\x12\x04\
    \x8d\x01\x04\x1a\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\x8d\x01\x04\x15\n\
    \r\n\x05\x05\x03\x02\x04\x02\x12\x04\x8d\x01\x18\x19\nS\n\x04\x05\x03\
    \x02\x05\x12\x04\x8f\x01\x04\x14\x1aE\x20TODO\x20should\x20probably\x20a\
    lso\x20allow\x20EXPECT_RECONNECT\x20here,\x20for\x20DittoTap\n\n\r\n\x05\
    \x05\x03\x02\x05\x01\x12\x04\x8f\x01\x04\r\n\r\n\x05\x05\x03\x02\x05\x02\
    \x12\x04\x8f\x01\x10\x13\n8\n\x02\x05\x04\x12\x06\x93\x01\0\x9d\x01\x01\
    \x1a*\x20Should\x20accompany\x20all\x20S2C_ERROR\x20messages.\n\n\x0b\n\
    \x03\x05\x04\x01\x12\x04\x93\x01\x05\x13\n\x0c\n\x04\x05\x04\x02\0\x12\
    \x04\x94\x01\x04\x11\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\x94\x01\x04\x0c\
    \n\r\n\x05\x05\x04\x02\0\x02\x12\x04\x94\x01\x0f\x10\n*\n\x04\x05\x04\
    \x02\x01\x12\x04\x95\x01\x04\x16\"\x1c\x20Squid\x20TCP\x20connection\x20\
    broke\n\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\x95\x01\x04\x11\n\r\n\x05\
    \x05\x04\x02\x01\x02\x12\x04\x95\x01\x14\x15\n7\n\x04\x05\x04\x02\x02\
    \x12\x04\x96\x01\x04\x18\")\x20You\x20told\x20me\x20something\x20was\x20\
    wrong,\x20client\n\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\x96\x01\x04\x13\
    \n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\x96\x01\x16\x17\n@\n\x04\x05\x04\
    \x02\x03\x12\x04\x97\x01\x04\x18\"2\x20You\x20messed\x20up,\x20client\
    \x20(e.g.\x20sent\x20a\x20bad\x20protobuf)\n\n\r\n\x05\x05\x04\x02\x03\
    \x01\x12\x04\x97\x01\x04\x13\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\x97\
    \x01\x16\x17\n\x17\n\x04\x05\x04\x02\x04\x12\x04\x98\x01\x04\x19\"\t\x20\
    I\x20broke\n\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\x98\x01\x04\x14\n\r\n\
    \x05\x05\x04\x02\x04\x02\x12\x04\x98\x01\x17\x18\nE\n\x04\x05\x04\x02\
    \x05\x12\x04\x99\x01\x04\x17\"7\x20Everything's\x20fine,\x20but\x20don't\
    \x20use\x20this\x20decoy\x20right\x20now\n\n\r\n\x05\x05\x04\x02\x05\x01\
    \x12\x04\x99\x01\x04\x12\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\x99\x01\
    \x15\x16\nD\n\x04\x05\x04\x02\x06\x12\x04\x9b\x01\x04\x18\"6\x20My\x20st\
    ream\x20to\x20you\x20broke.\x20(This\x20is\x20impossible\x20to\x20send)\
    \n\n\r\n\x05\x05\x04\x02\x06\x01\x12\x04\x9b\x01\x04\x11\n\r\n\x05\x05\
    \x04\x02\x06\x02\x12\x04\x9b\x01\x14\x17\nA\n\x04\x05\x04\x02\x07\x12\
    \x04\x9c\x01\x04\x19\"3\x20You\x20never\x20came\x20back.\x20(This\x20is\
    \x20impossible\x20to\x20send)\n\n\r\n\x05\x05\x04\x02\x07\x01\x12\x04\
    \x9c\x01\x04\x12\n\r\n\x05\x05\x04\x02\x07\x02\x12\x04\x9c\x01\x15\x18\n\
    \x0c\n\x02\x05\x05\x12\x06\x9f\x01\0\xa4\x01\x01\n\x0b\n\x03\x05\x05\x01\
    \x12\x04\x9f\x01\x05\x12\n\x0c\n\x04\x05\x05\x02\0\x12\x04\xa0\x01\x04\r\
    \n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xa0\x01\x04\x08\n\r\n\x05\x05\x05\
    \x02\0\x02\x12\x04\xa0\x01\x0b\x0c\n`\n\x04\x05\x05\x02\x01\x12\x04\xa1\
    \x01\x04\x0c\"R\x20Send\x20a\x2032-byte\x20HMAC\x20id\x20to\x20let\x20th\
    e\x20station\x20distinguish\x20registrations\x20to\x20same\x20host\n\n\r\
    \n\x05\x05\x05\x02\x01\x01\x12\x04\xa1\x01\x04\x07\n\r\n\x05\x05\x05\x02\
    \x01\x02\x12\x04\xa1\x01\n\x0b\n$\n\x04\x05\x05\x02\x02\x12\x04\xa2\x01\
    \x04\x0e\"\x16\x20Not\x20implemented\x20yet?\n\n\r\n\x05\x05\x05\x02\x02\
    \x01\x12\x04\xa2\x01\x04\t\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xa2\x01\
    \x0c\r\n1\n\x04\x05\x05\x02\x03\x12\x04\xa3\x01\x04\x10\"#\x20UDP\x20tra\
    nsport:\x20WebRTC\x20DataChannel\n\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\
    \xa3\x01\x04\n\n\r\n\x05\x05\x05\x02\x03\x02\x12\x04\xa3\x01\r\x0f\n:\n\
    \x02\x04\x07\x12\x06\xa7\x01\0\xad\x01\x01\x1a,\x20Deflated\x20ICE\x20Ca\
    ndidate\x20by\x20seed2sdp\x20package\n\n\x0b\n\x03\x04\x07\x01\x12\x04\
    \xa7\x01\x08\x1a\n5\n\x04\x04\x07\x02\0\x12\x04\xa9\x01\x04!\x1a'\x20IP\
    \x20is\x20represented\x20in\x20its\x2016-byte\x20form\n\n\r\n\x05\x04\
    \x07\x02\0\x04\x12\x04\xa9\x01\x04\x0c\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\xa9\x01\r\x13\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xa9\x01\x14\x1c\n\
    \r\n\x05\x04\x07\x02\0\x03\x12\x04\xa9\x01\x1f\x20\n\x0c\n\x04\x04\x07\
    \x02\x01\x12\x04\xaa\x01\x04!\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\xaa\
    \x01\x04\x0c\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xaa\x01\r\x13\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\xaa\x01\x14\x1c\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xaa\x01\x1f\x20\n\x9b\x01\n\x04\x04\x07\x02\x02\x12\x04\
    \xac\x01\x04&\x1a\x8c\x01\x20Composed\x20info\x20includes\x20port,\x20tc\
    ptype\x20(unset\x20if\x20not\x20tcp),\x20candidate\x20type\x20(host,\x20\
    srflx,\x20prflx),\x20protocol\x20(TCP/UDP),\x20and\x20component\x20(RTP/\
    RTCP)\n\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xac\x01\x04\x0c\n\r\n\x05\
    \x04\x07\x02\x02\x05\x12\x04\xac\x01\r\x13\n\r\n\x05\x04\x07\x02\x02\x01\
    \x12\x04\xac\x01\x14!\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xac\x01$%\n;\
    \n\x02\x04\x08\x12\x06\xb0\x01\0\xb3\x01\x01\x1a-\x20Deflated\x20SDP\x20\
    for\x20WebRTC\x20by\x20seed2sdp\x20package\n\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xb0\x01\x08\x11\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xb1\x01\x04\x1d\n\
    \r\n\x05\x04\x08\x02\0\x04\x12\x04\xb1\x01\x04\x0c\n\r\n\x05\x04\x08\x02\
    \0\x05\x12\x04\xb1\x01\r\x13\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xb1\x01\
    \x14\x18\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xb1\x01\x1b\x1c\n2\n\x04\
    \x04\x08\x02\x01\x12\x04\xb2\x01\x04/\"$\x20there\x20could\x20be\x20mult\
    iple\x20candidates\n\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xb2\x01\x04\
    \x0c\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xb2\x01\r\x1f\n\r\n\x05\x04\
    \x08\x02\x01\x01\x12\x04\xb2\x01\x20*\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\xb2\x01-.\n?\n\x02\x04\t\x12\x06\xb6\x01\0\xb9\x01\x01\x1a1\x20WebR\
    TCSignal\x20includes\x20a\x20deflated\x20SDP\x20and\x20a\x20seed\n\n\x0b\
    \n\x03\x04\t\x01\x12\x04\xb6\x01\x08\x14\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \xb7\x01\x04\x1d\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xb7\x01\x04\x0c\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\xb7\x01\r\x13\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xb7\x01\x14\x18\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xb7\x01\x1b\x1c\n\
    \x0c\n\x04\x04\t\x02\x01\x12\x04\xb8\x01\x04\x1f\n\r\n\x05\x04\t\x02\x01\
    \x04\x12\x04\xb8\x01\x04\x0c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xb8\x01\
    \r\x16\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xb8\x01\x17\x1a\n\r\n\x05\x04\
    \t\x02\x01\x03\x12\x04\xb8\x01\x1d\x1e\n\x0c\n\x02\x04\n\x12\x06\xbb\x01\
    \0\xd2\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xbb\x01\x08\x17\nO\n\x04\
    \x04\n\x02\0\x12\x04\xbd\x01\x04)\x1aA\x20Should\x20accompany\x20(at\x20\
    least)\x20SESSION_INIT\x20and\x20CONFIRM_RECONNECT.\n\n\r\n\x05\x04\n\
    \x02\0\x04\x12\x04\xbd\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xbd\
    \x01\r\x13\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xbd\x01\x14$\n\r\n\x05\x04\
    \n\x02\0\x03\x12\x04\xbd\x01'(\nv\n\x04\x04\n\x02\x01\x12\x04\xc1\x01\
    \x041\x1ah\x20There\x20might\x20be\x20a\x20state\x20transition.\x20May\
    \x20be\x20absent;\x20absence\x20should\x20be\n\x20treated\x20identically\
    \x20to\x20NO_CHANGE.\n\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xc1\x01\x04\
    \x0c\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xc1\x01\r\x1b\n\r\n\x05\x04\n\
    \x02\x01\x01\x12\x04\xc1\x01\x1c,\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\
    \xc1\x01/0\nc\n\x04\x04\n\x02\x02\x12\x04\xc5\x01\x04(\x1aU\x20The\x20st\
    ation\x20can\x20send\x20client\x20config\x20info\x20piggybacked\n\x20on\
    \x20any\x20message,\x20as\x20it\x20sees\x20fit\n\n\r\n\x05\x04\n\x02\x02\
    \x04\x12\x04\xc5\x01\x04\x0c\n\r\n\x05\x04\n\x02\x02\x06\x12\x04\xc5\x01\
    \r\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xc5\x01\x18#\n\r\n\x05\x04\n\
    \x02\x02\x03\x12\x04\xc5\x01&'\nP\n\x04\x04\n\x02\x03\x12\x04\xc8\x01\
    \x04+\x1aB\x20If\x20state_transition\x20==\x20S2C_ERROR,\x20this\x20fiel\
    d\x20is\x20the\x20explanation.\n\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\xc8\
    \x01\x04\x0c\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\xc8\x01\r\x1b\n\r\n\x05\
    \x04\n\x02\x03\x01\x12\x04\xc8\x01\x1c&\n\r\n\x05\x04\n\x02\x03\x03\x12\
    \x04\xc8\x01)*\nQ\n\x04\x04\n\x02\x04\x12\x04\xcb\x01\x04$\x1aC\x20Signa\
    ls\x20client\x20to\x20stop\x20connecting\x20for\x20following\x20amount\
    \x20of\x20seconds\n\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\xcb\x01\x04\x0c\
    \n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xcb\x01\r\x13\n\r\n\x05\x04\n\x02\
    \x04\x01\x12\x04\xcb\x01\x14\x1f\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xcb\
    \x01\"#\nK\n\x04\x04\n\x02\x05\x12\x04\xce\x01\x04#\x1a=\x20Sent\x20in\
    \x20SESSION_INIT,\x20identifies\x20the\x20station\x20that\x20picked\x20u\
    p\n\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xce\x01\x04\x0c\n\r\n\x05\x04\n\
    \x02\x05\x05\x12\x04\xce\x01\r\x13\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\
    \xce\x01\x14\x1e\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xce\x01!\"\nG\n\x04\
    \x04\n\x02\x06\x12\x04\xd1\x01\x04!\x1a9\x20Random-sized\x20junk\x20to\
    \x20defeat\x20packet\x20size\x20fingerprinting.\n\n\r\n\x05\x04\n\x02\
    \x06\x04\x12\x04\xd1\x01\x04\x0c\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\xd1\
    \x01\r\x12\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\xd1\x01\x13\x1a\n\r\n\x05\
    \x04\n\x02\x06\x03\x12\x04\xd1\x01\x1d\x20\n\x0c\n\x02\x04\x0b\x12\x06\
    \xd4\x01\0\xda\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xd4\x01\x08\x19\n\
    \x0c\n\x04\x04\x0b\x02\0\x12\x04\xd5\x01\x08&\n\r\n\x05\x04\x0b\x02\0\
    \x04\x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xd5\x01\
    \x11\x15\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xd5\x01\x16!\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\xd5\x01$%\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xd6\
    \x01\x08%\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xd6\x01\x08\x10\n\r\n\
    \x05\x04\x0b\x02\x01\x05\x12\x04\xd6\x01\x11\x15\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\xd6\x01\x16\x20\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xd6\x01#$\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xd7\x01\x08'\n\r\n\x05\
    \x04\x0b\x02\x02\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x02\
    \x05\x12\x04\xd7\x01\x11\x15\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xd7\
    \x01\x16\"\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xd7\x01%&\n\x0c\n\x04\
    \x04\x0b\x02\x03\x12\x04\xd8\x01\x04\x1e\n\r\n\x05\x04\x0b\x02\x03\x04\
    \x12\x04\xd8\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xd8\x01\r\
    \x11\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xd8\x01\x12\x19\n\r\n\x05\x04\
    \x0b\x02\x03\x03\x12\x04\xd8\x01\x1c\x1d\n\x0c\n\x04\x04\x0b\x02\x04\x12\
    \x04\xd9\x01\x04!\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\xd9\x01\x04\x0c\
    \n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\xd9\x01\r\x11\n\r\n\x05\x04\x0b\
    \x02\x04\x01\x12\x04\xd9\x01\x12\x1c\n\r\n\x05\x04\x0b\x02\x04\x03\x12\
    \x04\xd9\x01\x1f\x20\n\x0c\n\x02\x04\x0c\x12\x06\xdc\x01\0\x91\x02\x01\n\
    \x0b\n\x03\x04\x0c\x01\x12\x04\xdc\x01\x08\x17\n\x0c\n\x04\x04\x0c\x02\0\
    \x12\x04\xdd\x01\x04)\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xdd\x01\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xdd\x01\r\x13\n\r\n\x05\x04\x0c\
    \x02\0\x01\x12\x04\xdd\x01\x14$\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xdd\
    \x01'(\n\xd0\x01\n\x04\x04\x0c\x02\x01\x12\x04\xe2\x01\x04.\x1a\xc1\x01\
    \x20The\x20client\x20reports\x20its\x20decoy\x20list's\x20version\x20num\
    ber\x20here,\x20which\x20the\n\x20station\x20can\x20use\x20to\x20decide\
    \x20whether\x20to\x20send\x20an\x20updated\x20one.\x20The\x20station\n\
    \x20should\x20always\x20send\x20a\x20list\x20if\x20this\x20field\x20is\
    \x20set\x20to\x200.\n\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xe2\x01\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xe2\x01\r\x13\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\xe2\x01\x14)\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\xe2\x01,-\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xe4\x01\x041\n\r\n\
    \x05\x04\x0c\x02\x02\x04\x12\x04\xe4\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x02\x06\x12\x04\xe4\x01\r\x1b\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xe4\
    \x01\x1c,\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xe4\x01/0\n\x80\x01\n\
    \x04\x04\x0c\x02\x03\x12\x04\xe8\x01\x04$\x1ar\x20The\x20position\x20in\
    \x20the\x20overall\x20session's\x20upload\x20sequence\x20where\x20the\
    \x20current\n\x20YIELD=>ACQUIRE\x20switchover\x20is\x20happening.\n\n\r\
    \n\x05\x04\x0c\x02\x03\x04\x12\x04\xe8\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x03\x05\x12\x04\xe8\x01\r\x13\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xe8\
    \x01\x14\x1f\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xe8\x01\"#\ng\n\x04\
    \x04\x0c\x02\x04\x12\x04\xec\x01\x04+\x1aY\x20High\x20level\x20client\
    \x20library\x20version\x20used\x20for\x20indicating\x20feature\x20suppor\
    t,\x20or\n\x20lack\x20therof.\n\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\
    \xec\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\xec\x01\r\x13\n\r\
    \n\x05\x04\x0c\x02\x04\x01\x12\x04\xec\x01\x14&\n\r\n\x05\x04\x0c\x02\
    \x04\x03\x12\x04\xec\x01)*\nq\n\x04\x04\x0c\x02\x05\x12\x04\xf0\x01\x04'\
    \x1ac\x20List\x20of\x20decoys\x20that\x20client\x20have\x20unsuccessfull\
    y\x20tried\x20in\x20current\x20session.\n\x20Could\x20be\x20sent\x20in\
    \x20chunks\n\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xf0\x01\x04\x0c\n\r\n\
    \x05\x04\x0c\x02\x05\x05\x12\x04\xf0\x01\r\x13\n\r\n\x05\x04\x0c\x02\x05\
    \x01\x12\x04\xf0\x01\x14!\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xf0\x01$\
    &\n\x0c\n\x04\x04\x0c\x02\x06\x12\x04\xf2\x01\x04%\n\r\n\x05\x04\x0c\x02\
    \x06\x04\x12\x04\xf2\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x06\x06\x12\x04\
    \xf2\x01\r\x19\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xf2\x01\x1a\x1f\n\r\
    \n\x05\x04\x0c\x02\x06\x03\x12\x04\xf2\x01\"$\nk\n\x04\x04\x0c\x02\x07\
    \x12\x04\xf5\x01\x04*\x1a]\x20NullTransport,\x20MinTransport,\x20Obfs4Tr\
    ansport,\x20etc.\x20Transport\x20type\x20we\x20want\x20from\x20phantom\
    \x20proxy\n\n\r\n\x05\x04\x0c\x02\x07\x04\x12\x04\xf5\x01\x04\x0c\n\r\n\
    \x05\x04\x0c\x02\x07\x06\x12\x04\xf5\x01\r\x1a\n\r\n\x05\x04\x0c\x02\x07\
    \x01\x12\x04\xf5\x01\x1b$\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\xf5\x01'\
    )\n\x0c\n\x04\x04\x0c\x02\x08\x12\x04\xf7\x01\x047\n\r\n\x05\x04\x0c\x02\
    \x08\x04\x12\x04\xf7\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x08\x06\x12\x04\
    \xf7\x01\r\x20\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\xf7\x01!1\n\r\n\x05\
    \x04\x0c\x02\x08\x03\x12\x04\xf7\x0146\n\xc8\x03\n\x04\x04\x0c\x02\t\x12\
    \x04\xff\x01\x04(\x1a\xb9\x03\x20Station\x20is\x20only\x20required\x20to\
    \x20check\x20this\x20variable\x20during\x20session\x20initialization.\n\
    \x20If\x20set,\x20station\x20must\x20facilitate\x20connection\x20to\x20s\
    aid\x20target\x20by\x20itself,\x20i.e.\x20write\x20into\x20squid\n\x20so\
    cket\x20an\x20HTTP/SOCKS/any\x20other\x20connection\x20request.\n\x20cov\
    ert_address\x20must\x20have\x20exactly\x20one\x20':'\x20colon,\x20that\
    \x20separates\x20host\x20(literal\x20IP\x20address\x20or\n\x20resolvable\
    \x20hostname)\x20and\x20port\n\x20TODO:\x20make\x20it\x20required\x20for\
    \x20initialization,\x20and\x20stop\x20connecting\x20any\x20client\x20str\
    aight\x20to\x20squid?\n\n\r\n\x05\x04\x0c\x02\t\x04\x12\x04\xff\x01\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\xff\x01\r\x13\n\r\n\x05\x04\x0c\
    \x02\t\x01\x12\x04\xff\x01\x14\"\n\r\n\x05\x04\x0c\x02\t\x03\x12\x04\xff\
    \x01%'\nR\n\x04\x04\x0c\x02\n\x12\x04\x82\x02\x042\x1aD\x20Used\x20in\
    \x20dark\x20decoys\x20to\x20signal\x20which\x20dark\x20decoy\x20it\x20wi\
    ll\x20connect\x20to.\n\n\r\n\x05\x04\x0c\x02\n\x04\x12\x04\x82\x02\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\n\x05\x12\x04\x82\x02\r\x13\n\r\n\x05\x04\x0c\
    \x02\n\x01\x12\x04\x82\x02\x14,\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\x82\
    \x02/1\nR\n\x04\x04\x0c\x02\x0b\x12\x04\x85\x02\x04\"\x1aD\x20Used\x20to\
    \x20indicate\x20to\x20server\x20if\x20client\x20is\x20registering\x20v4,\
    \x20v6\x20or\x20both\n\n\r\n\x05\x04\x0c\x02\x0b\x04\x12\x04\x85\x02\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\x0b\x05\x12\x04\x85\x02\r\x11\n\r\n\x05\x04\
    \x0c\x02\x0b\x01\x12\x04\x85\x02\x12\x1c\n\r\n\x05\x04\x0c\x02\x0b\x03\
    \x12\x04\x85\x02\x1f!\n\x0c\n\x04\x04\x0c\x02\x0c\x12\x04\x86\x02\x04\"\
    \n\r\n\x05\x04\x0c\x02\x0c\x04\x12\x04\x86\x02\x04\x0c\n\r\n\x05\x04\x0c\
    \x02\x0c\x05\x12\x04\x86\x02\r\x11\n\r\n\x05\x04\x0c\x02\x0c\x01\x12\x04\
    \x86\x02\x12\x1c\n\r\n\x05\x04\x0c\x02\x0c\x03\x12\x04\x86\x02\x1f!\nD\n\
    \x04\x04\x0c\x02\r\x12\x04\x89\x02\x04*\x1a6\x20A\x20collection\x20of\
    \x20optional\x20flags\x20for\x20the\x20registration.\n\n\r\n\x05\x04\x0c\
    \x02\r\x04\x12\x04\x89\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\r\x06\x12\x04\
    \x89\x02\r\x1e\n\r\n\x05\x04\x0c\x02\r\x01\x12\x04\x89\x02\x1f$\n\r\n\
    \x05\x04\x0c\x02\r\x03\x12\x04\x89\x02')\nq\n\x04\x04\x0c\x02\x0e\x12\
    \x04\x8d\x02\x04-\x1ac\x20Transport\x20Extensions\n\x20TODO(jmwample)\
    \x20-\x20move\x20to\x20WebRTC\x20specific\x20transport\x20params\x20prot\
    obuf\x20message.\n\n\r\n\x05\x04\x0c\x02\x0e\x04\x12\x04\x8d\x02\x04\x0c\
    \n\r\n\x05\x04\x0c\x02\x0e\x06\x12\x04\x8d\x02\r\x19\n\r\n\x05\x04\x0c\
    \x02\x0e\x01\x12\x04\x8d\x02\x1a'\n\r\n\x05\x04\x0c\x02\x0e\x03\x12\x04\
    \x8d\x02*,\nG\n\x04\x04\x0c\x02\x0f\x12\x04\x90\x02\x04!\x1a9\x20Random-\
    sized\x20junk\x20to\x20defeat\x20packet\x20size\x20fingerprinting.\n\n\r\
    \n\x05\x04\x0c\x02\x0f\x04\x12\x04\x90\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x0f\x05\x12\x04\x90\x02\r\x12\n\r\n\x05\x04\x0c\x02\x0f\x01\x12\x04\x90\
    \x02\x13\x1a\n\r\n\x05\x04\x0c\x02\x0f\x03\x12\x04\x90\x02\x1d\x20\n\x0c\
    \n\x02\x04\r\x12\x06\x93\x02\0\x98\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\
    \x93\x02\x08\x1e\n\xcb\x01\n\x04\x04\r\x02\0\x12\x04\x97\x02\x04*\x1a\
    \xbc\x01\x20Indicates\x20whether\x20the\x20client\x20has\x20elected\x20t\
    o\x20use\x20destination\x20port\n\x20randomization.\x20Should\x20be\x20c\
    hecked\x20against\x20selected\x20transport\x20to\x20ensure\n\x20that\x20\
    destination\x20port\x20randomization\x20is\x20supported.\n\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\x97\x02\x04\x0c\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \x97\x02\r\x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x97\x02\x12$\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\x97\x02')\n\x0c\n\x02\x05\x06\x12\x06\x9a\x02\0\
    \xa2\x02\x01\n\x0b\n\x03\x05\x06\x01\x12\x04\x9a\x02\x05\x17\n\x0c\n\x04\
    \x05\x06\x02\0\x12\x04\x9b\x02\x02\x12\n\r\n\x05\x05\x06\x02\0\x01\x12\
    \x04\x9b\x02\x02\r\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\x9b\x02\x10\x11\n\
    \x0c\n\x04\x05\x06\x02\x01\x12\x04\x9c\x02\x08\x15\n\r\n\x05\x05\x06\x02\
    \x01\x01\x12\x04\x9c\x02\x08\x10\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\
    \x9c\x02\x13\x14\n\x0c\n\x04\x05\x06\x02\x02\x12\x04\x9d\x02\x08\x10\n\r\
    \n\x05\x05\x06\x02\x02\x01\x12\x04\x9d\x02\x08\x0b\n\r\n\x05\x05\x06\x02\
    \x02\x02\x12\x04\x9d\x02\x0e\x0f\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\x9e\
    \x02\x02\x16\n\r\n\x05\x05\x06\x02\x03\x01\x12\x04\x9e\x02\x02\x11\n\r\n\
    \x05\x05\x06\x02\x03\x02\x12\x04\x9e\x02\x14\x15\n\x0c\n\x04\x05\x06\x02\
    \x04\x12\x04\x9f\x02\x02\x17\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\x9f\
    \x02\x02\x12\n\r\n\x05\x05\x06\x02\x04\x02\x12\x04\x9f\x02\x15\x16\n\x0c\
    \n\x04\x05\x06\x02\x05\x12\x04\xa0\x02\x02\n\n\r\n\x05\x05\x06\x02\x05\
    \x01\x12\x04\xa0\x02\x02\x05\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xa0\
    \x02\x08\t\n\x0c\n\x04\x05\x06\x02\x06\x12\x04\xa1\x02\x02\x17\n\r\n\x05\
    \x05\x06\x02\x06\x01\x12\x04\xa1\x02\x02\x12\n\r\n\x05\x05\x06\x02\x06\
    \x02\x12\x04\xa1\x02\x15\x16\n\x0c\n\x02\x04\x0e\x12\x06\xa4\x02\0\xb0\
    \x02\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa4\x02\x08\x12\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\xa5\x02\x02#\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xa5\
    \x02\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xa5\x02\x0b\x10\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xa5\x02\x11\x1e\n\r\n\x05\x04\x0e\x02\0\x03\
    \x12\x04\xa5\x02!\"\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xa6\x02\x024\n\r\
    \n\x05\x04\x0e\x02\x01\x04\x12\x04\xa6\x02\x02\n\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\xa6\x02\x0b\x1a\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \xa6\x02\x1b/\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa6\x0223\n\x0c\n\
    \x04\x04\x0e\x02\x02\x12\x04\xa7\x02\x026\n\r\n\x05\x04\x0e\x02\x02\x04\
    \x12\x04\xa7\x02\x02\n\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\xa7\x02\x0b\
    \x1d\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa7\x02\x1e1\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\xa7\x0245\nC\n\x04\x04\x0e\x02\x03\x12\x04\xaa\
    \x02\x02*\x1a5\x20client\x20source\x20address\x20when\x20receiving\x20a\
    \x20registration\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xaa\x02\x02\n\n\
    \r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xaa\x02\x0b\x10\n\r\n\x05\x04\x0e\
    \x02\x03\x01\x12\x04\xaa\x02\x11%\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\
    \xaa\x02()\nH\n\x04\x04\x0e\x02\x04\x12\x04\xad\x02\x02#\x1a:\x20Decoy\
    \x20address\x20used\x20when\x20registering\x20over\x20Decoy\x20registrar\
    \n\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\xad\x02\x02\n\n\r\n\x05\x04\x0e\
    \x02\x04\x05\x12\x04\xad\x02\x0b\x10\n\r\n\x05\x04\x0e\x02\x04\x01\x12\
    \x04\xad\x02\x11\x1e\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xad\x02!\"\n\
    \x0c\n\x04\x04\x0e\x02\x05\x12\x04\xaf\x02\x02:\n\r\n\x05\x04\x0e\x02\
    \x05\x04\x12\x04\xaf\x02\x02\n\n\r\n\x05\x04\x0e\x02\x05\x06\x12\x04\xaf\
    \x02\x0b\x1f\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xaf\x02\x205\n\r\n\
    \x05\x04\x0e\x02\x05\x03\x12\x04\xaf\x0289\n\x0c\n\x02\x04\x0f\x12\x06\
    \xb2\x02\0\xbe\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xb2\x02\x08\x14\n\
    9\n\x04\x04\x0f\x02\0\x12\x04\xb3\x02\x04.\"+\x20how\x20many\x20decoys\
    \x20were\x20tried\x20before\x20success\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\xb3\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xb3\x02\r\x13\n\
    \r\n\x05\x04\x0f\x02\0\x01\x12\x04\xb3\x02\x14(\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xb3\x02+-\nm\n\x04\x04\x0f\x02\x01\x12\x04\xb8\x02\x04/\x1a\
    \x1e\x20Applicable\x20to\x20whole\x20session:\n\"\x1a\x20includes\x20fai\
    led\x20attempts\n2#\x20Timings\x20below\x20are\x20in\x20milliseconds\n\n\
    \r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xb8\x02\x04\x0c\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\xb8\x02\r\x13\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\
    \xb8\x02\x14)\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xb8\x02,.\nR\n\x04\
    \x04\x0f\x02\x02\x12\x04\xbb\x02\x04(\x1a\x1f\x20Last\x20(i.e.\x20succes\
    sful)\x20decoy:\n\"#\x20measured\x20during\x20initial\x20handshake\n\n\r\
    \n\x05\x04\x0f\x02\x02\x04\x12\x04\xbb\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\
    \x02\x05\x12\x04\xbb\x02\r\x13\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xbb\
    \x02\x14\"\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xbb\x02%'\n%\n\x04\x04\
    \x0f\x02\x03\x12\x04\xbc\x02\x04&\"\x17\x20includes\x20tcp\x20to\x20deco\
    y\n\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\xbc\x02\x04\x0c\n\r\n\x05\x04\
    \x0f\x02\x03\x05\x12\x04\xbc\x02\r\x13\n\r\n\x05\x04\x0f\x02\x03\x01\x12\
    \x04\xbc\x02\x14\x20\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xbc\x02#%\nB\
    \n\x04\x04\x0f\x02\x04\x12\x04\xbd\x02\x04&\"4\x20measured\x20when\x20es\
    tablishing\x20tcp\x20connection\x20to\x20decot\n\n\r\n\x05\x04\x0f\x02\
    \x04\x04\x12\x04\xbd\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\
    \xbd\x02\r\x13\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xbd\x02\x14\x20\n\r\
    \n\x05\x04\x0f\x02\x04\x03\x12\x04\xbd\x02#%\n\x0c\n\x02\x05\x07\x12\x06\
    \xc0\x02\0\xc5\x02\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\xc0\x02\x05\x16\n\
    \x0c\n\x04\x05\x07\x02\0\x12\x04\xc1\x02\x04\x10\n\r\n\x05\x05\x07\x02\0\
    \x01\x12\x04\xc1\x02\x04\x0b\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\xc1\x02\
    \x0e\x0f\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xc2\x02\x04\x0c\n\r\n\x05\
    \x05\x07\x02\x01\x01\x12\x04\xc2\x02\x04\x07\n\r\n\x05\x05\x07\x02\x01\
    \x02\x12\x04\xc2\x02\n\x0b\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\xc3\x02\
    \x04\x0f\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xc3\x02\x04\n\n\r\n\x05\
    \x05\x07\x02\x02\x02\x12\x04\xc3\x02\r\x0e\n\x0c\n\x04\x05\x07\x02\x03\
    \x12\x04\xc4\x02\x04\x0e\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\xc4\x02\
    \x04\t\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\xc4\x02\x0c\r\n\x0c\n\x02\
    \x05\x08\x12\x06\xc7\x02\0\xcb\x02\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\
    \xc7\x02\x05\x0c\n\x0c\n\x04\x05\x08\x02\0\x12\x04\xc8\x02\x04\x0c\n\r\n\
    \x05\x05\x08\x02\0\x01\x12\x04\xc8\x02\x04\x07\n\r\n\x05\x05\x08\x02\0\
    \x02\x12\x04\xc8\x02\n\x0b\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xc9\x02\
    \x04\x0c\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\xc9\x02\x04\x07\n\r\n\x05\
    \x05\x08\x02\x01\x02\x12\x04\xc9\x02\n\x0b\n\x0c\n\x04\x05\x08\x02\x02\
    \x12\x04\xca\x02\x04\x0c\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\xca\x02\
    \x04\x07\n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\xca\x02\n\x0b\n\x0c\n\x02\
    \x04\x10\x12\x06\xcd\x02\0\xd8\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \xcd\x02\x08\x19\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xce\x02\x04#\n\r\n\
    \x05\x04\x10\x02\0\x04\x12\x04\xce\x02\x04\x0c\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\xce\x02\r\x13\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xce\x02\
    \x14\x1e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xce\x02!\"\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\xcf\x02\x04\"\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\
    \xcf\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xcf\x02\r\x13\n\r\
    \n\x05\x04\x10\x02\x01\x01\x12\x04\xcf\x02\x14\x1d\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\xcf\x02\x20!\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xd1\
    \x02\x04#\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xd1\x02\x04\x0c\n\r\n\
    \x05\x04\x10\x02\x02\x05\x12\x04\xd1\x02\r\x13\n\r\n\x05\x04\x10\x02\x02\
    \x01\x12\x04\xd1\x02\x14\x1e\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd1\
    \x02!\"\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\xd3\x02\x04-\n\r\n\x05\x04\
    \x10\x02\x03\x04\x12\x04\xd3\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x03\x06\
    \x12\x04\xd3\x02\r\x1e\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xd3\x02\x1f\
    (\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xd3\x02+,\n\x0c\n\x04\x04\x10\
    \x02\x04\x12\x04\xd5\x02\x04\"\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\xd5\
    \x02\x04\x0c\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xd5\x02\r\x13\n\r\n\
    \x05\x04\x10\x02\x04\x01\x12\x04\xd5\x02\x14\x1c\n\r\n\x05\x04\x10\x02\
    \x04\x03\x12\x04\xd5\x02\x1f!\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xd6\
    \x02\x04\"\n\r\n\x05\x04\x10\x02\x05\x04\x12\x04\xd6\x02\x04\x0c\n\r\n\
    \x05\x04\x10\x02\x05\x05\x12\x04\xd6\x02\r\x13\n\r\n\x05\x04\x10\x02\x05\
    \x01\x12\x04\xd6\x02\x14\x1c\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xd6\
    \x02\x1f!\n\x0c\n\x04\x04\x10\x02\x06\x12\x04\xd7\x02\x04\x20\n\r\n\x05\
    \x04\x10\x02\x06\x04\x12\x04\xd7\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x06\
    \x06\x12\x04\xd7\x02\r\x14\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xd7\x02\
    \x15\x1a\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\xd7\x02\x1d\x1f\nT\n\x02\
    \x04\x11\x12\x06\xdb\x02\0\xec\x02\x01\x1aF\x20Adding\x20message\x20resp\
    onse\x20from\x20Station\x20to\x20Client\x20for\x20bidirectional\x20API\n\
    \n\x0b\n\x03\x04\x11\x01\x12\x04\xdb\x02\x08\x1c\n\x0c\n\x04\x04\x11\x02\
    \0\x12\x04\xdc\x02\x02\x20\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xdc\x02\
    \x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xdc\x02\x0b\x12\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\xdc\x02\x13\x1b\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\xdc\x02\x1e\x1f\n?\n\x04\x04\x11\x02\x01\x12\x04\xde\x02\x02\x1e\
    \x1a1\x20The\x20128-bit\x20ipv6\x20address,\x20in\x20network\x20byte\x20\
    order\n\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xde\x02\x02\n\n\r\n\x05\
    \x04\x11\x02\x01\x05\x12\x04\xde\x02\x0b\x10\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xde\x02\x11\x19\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xde\
    \x02\x1c\x1d\n,\n\x04\x04\x11\x02\x02\x12\x04\xe1\x02\x02\x1f\x1a\x1e\
    \x20Respond\x20with\x20randomized\x20port\n\n\r\n\x05\x04\x11\x02\x02\
    \x04\x12\x04\xe1\x02\x02\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xe1\x02\
    \x0b\x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xe1\x02\x12\x1a\n\r\n\x05\
    \x04\x11\x02\x02\x03\x12\x04\xe1\x02\x1d\x1e\nd\n\x04\x04\x11\x02\x03\
    \x12\x04\xe5\x02\x02\"\x1aV\x20Future:\x20station\x20provides\x20client\
    \x20with\x20secret,\x20want\x20chanel\x20present\n\x20Leave\x20null\x20f\
    or\x20now\n\n\r\n\x05\x04\x11\x02\x03\x04\x12\x04\xe5\x02\x02\n\n\r\n\
    \x05\x04\x11\x02\x03\x05\x12\x04\xe5\x02\x0b\x10\n\r\n\x05\x04\x11\x02\
    \x03\x01\x12\x04\xe5\x02\x11\x1d\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\
    \xe5\x02\x20!\nA\n\x04\x04\x11\x02\x04\x12\x04\xe8\x02\x02\x1c\x1a3\x20I\
    f\x20registration\x20wrong,\x20populate\x20this\x20error\x20string\n\n\r\
    \n\x05\x04\x11\x02\x04\x04\x12\x04\xe8\x02\x02\n\n\r\n\x05\x04\x11\x02\
    \x04\x05\x12\x04\xe8\x02\x0b\x11\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\
    \xe8\x02\x12\x17\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xe8\x02\x1a\x1b\n\
    +\n\x04\x04\x11\x02\x05\x12\x04\xeb\x02\x02%\x1a\x1d\x20ClientConf\x20fi\
    eld\x20(optional)\n\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xeb\x02\x02\n\
    \n\r\n\x05\x04\x11\x02\x05\x06\x12\x04\xeb\x02\x0b\x15\n\r\n\x05\x04\x11\
    \x02\x05\x01\x12\x04\xeb\x02\x16\x20\n\r\n\x05\x04\x11\x02\x05\x03\x12\
    \x04\xeb\x02#$\n!\n\x02\x04\x12\x12\x06\xef\x02\0\xf3\x02\x01\x1a\x13\
    \x20response\x20from\x20dns\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xef\x02\
    \x08\x13\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xf0\x02\x04\x1e\n\r\n\x05\x04\
    \x12\x02\0\x04\x12\x04\xf0\x02\x04\x0c\n\r\n\x05\x04\x12\x02\0\x05\x12\
    \x04\xf0\x02\r\x11\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf0\x02\x12\x19\n\
    \r\n\x05\x04\x12\x02\0\x03\x12\x04\xf0\x02\x1c\x1d\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xf1\x02\x04*\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xf1\
    \x02\x04\x0c\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xf1\x02\r\x11\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xf1\x02\x12%\n\r\n\x05\x04\x12\x02\x01\
    \x03\x12\x04\xf1\x02()\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xf2\x02\x04=\
    \n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xf2\x02\x04\x0c\n\r\n\x05\x04\x12\
    \x02\x02\x06\x12\x04\xf2\x02\r!\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\
    \xf2\x02\"8\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xf2\x02;<\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(19);
            messages.push(PubKey::generated_message_descriptor_data());
            messages.push(TLSDecoySpec::generated_message_descriptor_data());
            messages.push(ClientConf::generated_message_descriptor_data());
            messages.push(DnsRegConf::generated_message_descriptor_data());
            messages.push(DecoyList::generated_message_descriptor_data());
            messages.push(PhantomSubnetsList::generated_message_descriptor_data());
            messages.push(PhantomSubnets::generated_message_descriptor_data());
            messages.push(WebRTCICECandidate::generated_message_descriptor_data());
            messages.push(WebRTCSDP::generated_message_descriptor_data());
            messages.push(WebRTCSignal::generated_message_descriptor_data());
            messages.push(StationToClient::generated_message_descriptor_data());
            messages.push(RegistrationFlags::generated_message_descriptor_data());
            messages.push(ClientToStation::generated_message_descriptor_data());
            messages.push(GenericTransportParams::generated_message_descriptor_data());
            messages.push(C2SWrapper::generated_message_descriptor_data());
            messages.push(SessionStats::generated_message_descriptor_data());
            messages.push(StationToDetector::generated_message_descriptor_data());
            messages.push(RegistrationResponse::generated_message_descriptor_data());
            messages.push(DnsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(KeyType::generated_enum_descriptor_data());
            enums.push(DnsRegMethod::generated_enum_descriptor_data());
            enums.push(C2S_Transition::generated_enum_descriptor_data());
            enums.push(S2C_Transition::generated_enum_descriptor_data());
            enums.push(ErrorReasonS2C::generated_enum_descriptor_data());
            enums.push(TransportType::generated_enum_descriptor_data());
            enums.push(RegistrationSource::generated_enum_descriptor_data());
            enums.push(StationOperations::generated_enum_descriptor_data());
            enums.push(IPProto::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
