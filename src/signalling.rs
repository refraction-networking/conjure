// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `signalling.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct PubKey {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<KeyType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubKey {
    fn default() -> &'a PubKey {
        <PubKey as ::protobuf::Message>::default_instance()
    }
}

impl PubKey {
    pub fn new() -> PubKey {
        ::std::default::Default::default()
    }

    // optional bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.KeyType type = 2;


    pub fn get_field_type(&self) -> KeyType {
        self.field_type.unwrap_or(KeyType::AES_GCM_128)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: KeyType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PubKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubKey {
        PubKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &PubKey| { &m.key },
                |m: &mut PubKey| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KeyType>>(
                "type",
                |m: &PubKey| { &m.field_type },
                |m: &mut PubKey| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PubKey>(
                "PubKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PubKey {
        static instance: ::protobuf::rt::LazyV2<PubKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PubKey::new)
    }
}

impl ::protobuf::Clear for PubKey {
    fn clear(&mut self) {
        self.key.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TLSDecoySpec {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    ipv4addr: ::std::option::Option<u32>,
    ipv6addr: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub pubkey: ::protobuf::SingularPtrField<PubKey>,
    timeout: ::std::option::Option<u32>,
    tcpwin: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TLSDecoySpec {
    fn default() -> &'a TLSDecoySpec {
        <TLSDecoySpec as ::protobuf::Message>::default_instance()
    }
}

impl TLSDecoySpec {
    pub fn new() -> TLSDecoySpec {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;


    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 ipv4addr = 2;


    pub fn get_ipv4addr(&self) -> u32 {
        self.ipv4addr.unwrap_or(0)
    }
    pub fn clear_ipv4addr(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
    }

    pub fn has_ipv4addr(&self) -> bool {
        self.ipv4addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4addr(&mut self, v: u32) {
        self.ipv4addr = ::std::option::Option::Some(v);
    }

    // optional bytes ipv6addr = 6;


    pub fn get_ipv6addr(&self) -> &[u8] {
        match self.ipv6addr.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ipv6addr(&mut self) {
        self.ipv6addr.clear();
    }

    pub fn has_ipv6addr(&self) -> bool {
        self.ipv6addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ipv6addr.is_none() {
            self.ipv6addr.set_default();
        }
        self.ipv6addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6addr(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6addr.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.PubKey pubkey = 3;


    pub fn get_pubkey(&self) -> &PubKey {
        self.pubkey.as_ref().unwrap_or_else(|| <PubKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    pub fn has_pubkey(&self) -> bool {
        self.pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: PubKey) {
        self.pubkey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut PubKey {
        if self.pubkey.is_none() {
            self.pubkey.set_default();
        }
        self.pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_pubkey(&mut self) -> PubKey {
        self.pubkey.take().unwrap_or_else(|| PubKey::new())
    }

    // optional uint32 timeout = 4;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }

    // optional uint32 tcpwin = 5;


    pub fn get_tcpwin(&self) -> u32 {
        self.tcpwin.unwrap_or(0)
    }
    pub fn clear_tcpwin(&mut self) {
        self.tcpwin = ::std::option::Option::None;
    }

    pub fn has_tcpwin(&self) -> bool {
        self.tcpwin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpwin(&mut self, v: u32) {
        self.tcpwin = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TLSDecoySpec {
    fn is_initialized(&self) -> bool {
        for v in &self.pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ipv4addr = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ipv6addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pubkey)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcpwin = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ipv4addr {
            my_size += 5;
        }
        if let Some(ref v) = self.ipv6addr.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tcpwin {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.ipv4addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(ref v) = self.ipv6addr.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.pubkey.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tcpwin {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TLSDecoySpec {
        TLSDecoySpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &TLSDecoySpec| { &m.hostname },
                |m: &mut TLSDecoySpec| { &mut m.hostname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ipv4addr",
                |m: &TLSDecoySpec| { &m.ipv4addr },
                |m: &mut TLSDecoySpec| { &mut m.ipv4addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ipv6addr",
                |m: &TLSDecoySpec| { &m.ipv6addr },
                |m: &mut TLSDecoySpec| { &mut m.ipv6addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubKey>>(
                "pubkey",
                |m: &TLSDecoySpec| { &m.pubkey },
                |m: &mut TLSDecoySpec| { &mut m.pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &TLSDecoySpec| { &m.timeout },
                |m: &mut TLSDecoySpec| { &mut m.timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tcpwin",
                |m: &TLSDecoySpec| { &m.tcpwin },
                |m: &mut TLSDecoySpec| { &mut m.tcpwin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TLSDecoySpec>(
                "TLSDecoySpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TLSDecoySpec {
        static instance: ::protobuf::rt::LazyV2<TLSDecoySpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TLSDecoySpec::new)
    }
}

impl ::protobuf::Clear for TLSDecoySpec {
    fn clear(&mut self) {
        self.hostname.clear();
        self.ipv4addr = ::std::option::Option::None;
        self.ipv6addr.clear();
        self.pubkey.clear();
        self.timeout = ::std::option::Option::None;
        self.tcpwin = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TLSDecoySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TLSDecoySpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientConf {
    // message fields
    pub decoy_list: ::protobuf::SingularPtrField<DecoyList>,
    generation: ::std::option::Option<u32>,
    pub default_pubkey: ::protobuf::SingularPtrField<PubKey>,
    pub phantom_subnets_list: ::protobuf::SingularPtrField<PhantomSubnetsList>,
    pub conjure_pubkey: ::protobuf::SingularPtrField<PubKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientConf {
    fn default() -> &'a ClientConf {
        <ClientConf as ::protobuf::Message>::default_instance()
    }
}

impl ClientConf {
    pub fn new() -> ClientConf {
        ::std::default::Default::default()
    }

    // optional .tapdance.DecoyList decoy_list = 1;


    pub fn get_decoy_list(&self) -> &DecoyList {
        self.decoy_list.as_ref().unwrap_or_else(|| <DecoyList as ::protobuf::Message>::default_instance())
    }
    pub fn clear_decoy_list(&mut self) {
        self.decoy_list.clear();
    }

    pub fn has_decoy_list(&self) -> bool {
        self.decoy_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_list(&mut self, v: DecoyList) {
        self.decoy_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoy_list(&mut self) -> &mut DecoyList {
        if self.decoy_list.is_none() {
            self.decoy_list.set_default();
        }
        self.decoy_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_decoy_list(&mut self) -> DecoyList {
        self.decoy_list.take().unwrap_or_else(|| DecoyList::new())
    }

    // optional uint32 generation = 2;


    pub fn get_generation(&self) -> u32 {
        self.generation.unwrap_or(0)
    }
    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: u32) {
        self.generation = ::std::option::Option::Some(v);
    }

    // optional .tapdance.PubKey default_pubkey = 3;


    pub fn get_default_pubkey(&self) -> &PubKey {
        self.default_pubkey.as_ref().unwrap_or_else(|| <PubKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_pubkey(&mut self) {
        self.default_pubkey.clear();
    }

    pub fn has_default_pubkey(&self) -> bool {
        self.default_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_pubkey(&mut self, v: PubKey) {
        self.default_pubkey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_pubkey(&mut self) -> &mut PubKey {
        if self.default_pubkey.is_none() {
            self.default_pubkey.set_default();
        }
        self.default_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_pubkey(&mut self) -> PubKey {
        self.default_pubkey.take().unwrap_or_else(|| PubKey::new())
    }

    // optional .tapdance.PhantomSubnetsList phantom_subnets_list = 4;


    pub fn get_phantom_subnets_list(&self) -> &PhantomSubnetsList {
        self.phantom_subnets_list.as_ref().unwrap_or_else(|| <PhantomSubnetsList as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phantom_subnets_list(&mut self) {
        self.phantom_subnets_list.clear();
    }

    pub fn has_phantom_subnets_list(&self) -> bool {
        self.phantom_subnets_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phantom_subnets_list(&mut self, v: PhantomSubnetsList) {
        self.phantom_subnets_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phantom_subnets_list(&mut self) -> &mut PhantomSubnetsList {
        if self.phantom_subnets_list.is_none() {
            self.phantom_subnets_list.set_default();
        }
        self.phantom_subnets_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_phantom_subnets_list(&mut self) -> PhantomSubnetsList {
        self.phantom_subnets_list.take().unwrap_or_else(|| PhantomSubnetsList::new())
    }

    // optional .tapdance.PubKey conjure_pubkey = 5;


    pub fn get_conjure_pubkey(&self) -> &PubKey {
        self.conjure_pubkey.as_ref().unwrap_or_else(|| <PubKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conjure_pubkey(&mut self) {
        self.conjure_pubkey.clear();
    }

    pub fn has_conjure_pubkey(&self) -> bool {
        self.conjure_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conjure_pubkey(&mut self, v: PubKey) {
        self.conjure_pubkey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conjure_pubkey(&mut self) -> &mut PubKey {
        if self.conjure_pubkey.is_none() {
            self.conjure_pubkey.set_default();
        }
        self.conjure_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_conjure_pubkey(&mut self) -> PubKey {
        self.conjure_pubkey.take().unwrap_or_else(|| PubKey::new())
    }
}

impl ::protobuf::Message for ClientConf {
    fn is_initialized(&self) -> bool {
        for v in &self.decoy_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phantom_subnets_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conjure_pubkey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.decoy_list)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.generation = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_pubkey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phantom_subnets_list)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conjure_pubkey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.decoy_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.default_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phantom_subnets_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.conjure_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.decoy_list.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.generation {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.default_pubkey.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phantom_subnets_list.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.conjure_pubkey.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientConf {
        ClientConf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DecoyList>>(
                "decoy_list",
                |m: &ClientConf| { &m.decoy_list },
                |m: &mut ClientConf| { &mut m.decoy_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "generation",
                |m: &ClientConf| { &m.generation },
                |m: &mut ClientConf| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubKey>>(
                "default_pubkey",
                |m: &ClientConf| { &m.default_pubkey },
                |m: &mut ClientConf| { &mut m.default_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PhantomSubnetsList>>(
                "phantom_subnets_list",
                |m: &ClientConf| { &m.phantom_subnets_list },
                |m: &mut ClientConf| { &mut m.phantom_subnets_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubKey>>(
                "conjure_pubkey",
                |m: &ClientConf| { &m.conjure_pubkey },
                |m: &mut ClientConf| { &mut m.conjure_pubkey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientConf>(
                "ClientConf",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientConf {
        static instance: ::protobuf::rt::LazyV2<ClientConf> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientConf::new)
    }
}

impl ::protobuf::Clear for ClientConf {
    fn clear(&mut self) {
        self.decoy_list.clear();
        self.generation = ::std::option::Option::None;
        self.default_pubkey.clear();
        self.phantom_subnets_list.clear();
        self.conjure_pubkey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientConf {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsRegConf {
    // message fields
    dns_reg_method: ::std::option::Option<DnsRegMethod>,
    udp_addr: ::protobuf::SingularField<::std::string::String>,
    dot_addr: ::protobuf::SingularField<::std::string::String>,
    doh_url: ::protobuf::SingularField<::std::string::String>,
    domain: ::protobuf::SingularField<::std::string::String>,
    pubkey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    utls_distribution: ::protobuf::SingularField<::std::string::String>,
    stun_server: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsRegConf {
    fn default() -> &'a DnsRegConf {
        <DnsRegConf as ::protobuf::Message>::default_instance()
    }
}

impl DnsRegConf {
    pub fn new() -> DnsRegConf {
        ::std::default::Default::default()
    }

    // required .tapdance.DnsRegMethod dns_reg_method = 1;


    pub fn get_dns_reg_method(&self) -> DnsRegMethod {
        self.dns_reg_method.unwrap_or(DnsRegMethod::UDP)
    }
    pub fn clear_dns_reg_method(&mut self) {
        self.dns_reg_method = ::std::option::Option::None;
    }

    pub fn has_dns_reg_method(&self) -> bool {
        self.dns_reg_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dns_reg_method(&mut self, v: DnsRegMethod) {
        self.dns_reg_method = ::std::option::Option::Some(v);
    }

    // optional string udp_addr = 2;


    pub fn get_udp_addr(&self) -> &str {
        match self.udp_addr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_udp_addr(&mut self) {
        self.udp_addr.clear();
    }

    pub fn has_udp_addr(&self) -> bool {
        self.udp_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_addr(&mut self, v: ::std::string::String) {
        self.udp_addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_udp_addr(&mut self) -> &mut ::std::string::String {
        if self.udp_addr.is_none() {
            self.udp_addr.set_default();
        }
        self.udp_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_udp_addr(&mut self) -> ::std::string::String {
        self.udp_addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dot_addr = 3;


    pub fn get_dot_addr(&self) -> &str {
        match self.dot_addr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dot_addr(&mut self) {
        self.dot_addr.clear();
    }

    pub fn has_dot_addr(&self) -> bool {
        self.dot_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dot_addr(&mut self, v: ::std::string::String) {
        self.dot_addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dot_addr(&mut self) -> &mut ::std::string::String {
        if self.dot_addr.is_none() {
            self.dot_addr.set_default();
        }
        self.dot_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_dot_addr(&mut self) -> ::std::string::String {
        self.dot_addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doh_url = 4;


    pub fn get_doh_url(&self) -> &str {
        match self.doh_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_doh_url(&mut self) {
        self.doh_url.clear();
    }

    pub fn has_doh_url(&self) -> bool {
        self.doh_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doh_url(&mut self, v: ::std::string::String) {
        self.doh_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doh_url(&mut self) -> &mut ::std::string::String {
        if self.doh_url.is_none() {
            self.doh_url.set_default();
        }
        self.doh_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_doh_url(&mut self) -> ::std::string::String {
        self.doh_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string domain = 5;


    pub fn get_domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes pubkey = 6;


    pub fn get_pubkey(&self) -> &[u8] {
        match self.pubkey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    pub fn has_pubkey(&self) -> bool {
        self.pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pubkey.is_none() {
            self.pubkey.set_default();
        }
        self.pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        self.pubkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string utls_distribution = 7;


    pub fn get_utls_distribution(&self) -> &str {
        match self.utls_distribution.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_utls_distribution(&mut self) {
        self.utls_distribution.clear();
    }

    pub fn has_utls_distribution(&self) -> bool {
        self.utls_distribution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utls_distribution(&mut self, v: ::std::string::String) {
        self.utls_distribution = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utls_distribution(&mut self) -> &mut ::std::string::String {
        if self.utls_distribution.is_none() {
            self.utls_distribution.set_default();
        }
        self.utls_distribution.as_mut().unwrap()
    }

    // Take field
    pub fn take_utls_distribution(&mut self) -> ::std::string::String {
        self.utls_distribution.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stun_server = 8;


    pub fn get_stun_server(&self) -> &str {
        match self.stun_server.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_stun_server(&mut self) {
        self.stun_server.clear();
    }

    pub fn has_stun_server(&self) -> bool {
        self.stun_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_server(&mut self, v: ::std::string::String) {
        self.stun_server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stun_server(&mut self) -> &mut ::std::string::String {
        if self.stun_server.is_none() {
            self.stun_server.set_default();
        }
        self.stun_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_stun_server(&mut self) -> ::std::string::String {
        self.stun_server.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DnsRegConf {
    fn is_initialized(&self) -> bool {
        if self.dns_reg_method.is_none() {
            return false;
        }
        if self.domain.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.dns_reg_method, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.udp_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dot_addr)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.doh_url)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.domain)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pubkey)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.utls_distribution)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stun_server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dns_reg_method {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.udp_addr.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.dot_addr.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.doh_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.pubkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.utls_distribution.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.stun_server.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dns_reg_method {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.udp_addr.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.dot_addr.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.doh_url.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.pubkey.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.utls_distribution.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.stun_server.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsRegConf {
        DnsRegConf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DnsRegMethod>>(
                "dns_reg_method",
                |m: &DnsRegConf| { &m.dns_reg_method },
                |m: &mut DnsRegConf| { &mut m.dns_reg_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "udp_addr",
                |m: &DnsRegConf| { &m.udp_addr },
                |m: &mut DnsRegConf| { &mut m.udp_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dot_addr",
                |m: &DnsRegConf| { &m.dot_addr },
                |m: &mut DnsRegConf| { &mut m.dot_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "doh_url",
                |m: &DnsRegConf| { &m.doh_url },
                |m: &mut DnsRegConf| { &mut m.doh_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domain",
                |m: &DnsRegConf| { &m.domain },
                |m: &mut DnsRegConf| { &mut m.domain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pubkey",
                |m: &DnsRegConf| { &m.pubkey },
                |m: &mut DnsRegConf| { &mut m.pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "utls_distribution",
                |m: &DnsRegConf| { &m.utls_distribution },
                |m: &mut DnsRegConf| { &mut m.utls_distribution },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stun_server",
                |m: &DnsRegConf| { &m.stun_server },
                |m: &mut DnsRegConf| { &mut m.stun_server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsRegConf>(
                "DnsRegConf",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsRegConf {
        static instance: ::protobuf::rt::LazyV2<DnsRegConf> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsRegConf::new)
    }
}

impl ::protobuf::Clear for DnsRegConf {
    fn clear(&mut self) {
        self.dns_reg_method = ::std::option::Option::None;
        self.udp_addr.clear();
        self.dot_addr.clear();
        self.doh_url.clear();
        self.domain.clear();
        self.pubkey.clear();
        self.utls_distribution.clear();
        self.stun_server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsRegConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsRegConf {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecoyList {
    // message fields
    pub tls_decoys: ::protobuf::RepeatedField<TLSDecoySpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecoyList {
    fn default() -> &'a DecoyList {
        <DecoyList as ::protobuf::Message>::default_instance()
    }
}

impl DecoyList {
    pub fn new() -> DecoyList {
        ::std::default::Default::default()
    }

    // repeated .tapdance.TLSDecoySpec tls_decoys = 1;


    pub fn get_tls_decoys(&self) -> &[TLSDecoySpec] {
        &self.tls_decoys
    }
    pub fn clear_tls_decoys(&mut self) {
        self.tls_decoys.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls_decoys(&mut self, v: ::protobuf::RepeatedField<TLSDecoySpec>) {
        self.tls_decoys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tls_decoys(&mut self) -> &mut ::protobuf::RepeatedField<TLSDecoySpec> {
        &mut self.tls_decoys
    }

    // Take field
    pub fn take_tls_decoys(&mut self) -> ::protobuf::RepeatedField<TLSDecoySpec> {
        ::std::mem::replace(&mut self.tls_decoys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DecoyList {
    fn is_initialized(&self) -> bool {
        for v in &self.tls_decoys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tls_decoys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tls_decoys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tls_decoys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecoyList {
        DecoyList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TLSDecoySpec>>(
                "tls_decoys",
                |m: &DecoyList| { &m.tls_decoys },
                |m: &mut DecoyList| { &mut m.tls_decoys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecoyList>(
                "DecoyList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecoyList {
        static instance: ::protobuf::rt::LazyV2<DecoyList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecoyList::new)
    }
}

impl ::protobuf::Clear for DecoyList {
    fn clear(&mut self) {
        self.tls_decoys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecoyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecoyList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhantomSubnetsList {
    // message fields
    pub weighted_subnets: ::protobuf::RepeatedField<PhantomSubnets>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhantomSubnetsList {
    fn default() -> &'a PhantomSubnetsList {
        <PhantomSubnetsList as ::protobuf::Message>::default_instance()
    }
}

impl PhantomSubnetsList {
    pub fn new() -> PhantomSubnetsList {
        ::std::default::Default::default()
    }

    // repeated .tapdance.PhantomSubnets weighted_subnets = 1;


    pub fn get_weighted_subnets(&self) -> &[PhantomSubnets] {
        &self.weighted_subnets
    }
    pub fn clear_weighted_subnets(&mut self) {
        self.weighted_subnets.clear();
    }

    // Param is passed by value, moved
    pub fn set_weighted_subnets(&mut self, v: ::protobuf::RepeatedField<PhantomSubnets>) {
        self.weighted_subnets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_weighted_subnets(&mut self) -> &mut ::protobuf::RepeatedField<PhantomSubnets> {
        &mut self.weighted_subnets
    }

    // Take field
    pub fn take_weighted_subnets(&mut self) -> ::protobuf::RepeatedField<PhantomSubnets> {
        ::std::mem::replace(&mut self.weighted_subnets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PhantomSubnetsList {
    fn is_initialized(&self) -> bool {
        for v in &self.weighted_subnets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.weighted_subnets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.weighted_subnets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.weighted_subnets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhantomSubnetsList {
        PhantomSubnetsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PhantomSubnets>>(
                "weighted_subnets",
                |m: &PhantomSubnetsList| { &m.weighted_subnets },
                |m: &mut PhantomSubnetsList| { &mut m.weighted_subnets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhantomSubnetsList>(
                "PhantomSubnetsList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhantomSubnetsList {
        static instance: ::protobuf::rt::LazyV2<PhantomSubnetsList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhantomSubnetsList::new)
    }
}

impl ::protobuf::Clear for PhantomSubnetsList {
    fn clear(&mut self) {
        self.weighted_subnets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhantomSubnetsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhantomSubnetsList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhantomSubnets {
    // message fields
    weight: ::std::option::Option<u32>,
    pub subnets: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhantomSubnets {
    fn default() -> &'a PhantomSubnets {
        <PhantomSubnets as ::protobuf::Message>::default_instance()
    }
}

impl PhantomSubnets {
    pub fn new() -> PhantomSubnets {
        ::std::default::Default::default()
    }

    // optional uint32 weight = 1;


    pub fn get_weight(&self) -> u32 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // repeated string subnets = 2;


    pub fn get_subnets(&self) -> &[::std::string::String] {
        &self.subnets
    }
    pub fn clear_subnets(&mut self) {
        self.subnets.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subnets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subnets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subnets
    }

    // Take field
    pub fn take_subnets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subnets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PhantomSubnets {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subnets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subnets {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.weight {
            os.write_uint32(1, v)?;
        }
        for v in &self.subnets {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhantomSubnets {
        PhantomSubnets::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "weight",
                |m: &PhantomSubnets| { &m.weight },
                |m: &mut PhantomSubnets| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subnets",
                |m: &PhantomSubnets| { &m.subnets },
                |m: &mut PhantomSubnets| { &mut m.subnets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhantomSubnets>(
                "PhantomSubnets",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhantomSubnets {
        static instance: ::protobuf::rt::LazyV2<PhantomSubnets> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhantomSubnets::new)
    }
}

impl ::protobuf::Clear for PhantomSubnets {
    fn clear(&mut self) {
        self.weight = ::std::option::Option::None;
        self.subnets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhantomSubnets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhantomSubnets {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WebRTCICECandidate {
    // message fields
    ip_upper: ::std::option::Option<u64>,
    ip_lower: ::std::option::Option<u64>,
    composed_info: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebRTCICECandidate {
    fn default() -> &'a WebRTCICECandidate {
        <WebRTCICECandidate as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCICECandidate {
    pub fn new() -> WebRTCICECandidate {
        ::std::default::Default::default()
    }

    // required uint64 ip_upper = 1;


    pub fn get_ip_upper(&self) -> u64 {
        self.ip_upper.unwrap_or(0)
    }
    pub fn clear_ip_upper(&mut self) {
        self.ip_upper = ::std::option::Option::None;
    }

    pub fn has_ip_upper(&self) -> bool {
        self.ip_upper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_upper(&mut self, v: u64) {
        self.ip_upper = ::std::option::Option::Some(v);
    }

    // required uint64 ip_lower = 2;


    pub fn get_ip_lower(&self) -> u64 {
        self.ip_lower.unwrap_or(0)
    }
    pub fn clear_ip_lower(&mut self) {
        self.ip_lower = ::std::option::Option::None;
    }

    pub fn has_ip_lower(&self) -> bool {
        self.ip_lower.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_lower(&mut self, v: u64) {
        self.ip_lower = ::std::option::Option::Some(v);
    }

    // required uint32 composed_info = 3;


    pub fn get_composed_info(&self) -> u32 {
        self.composed_info.unwrap_or(0)
    }
    pub fn clear_composed_info(&mut self) {
        self.composed_info = ::std::option::Option::None;
    }

    pub fn has_composed_info(&self) -> bool {
        self.composed_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composed_info(&mut self, v: u32) {
        self.composed_info = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WebRTCICECandidate {
    fn is_initialized(&self) -> bool {
        if self.ip_upper.is_none() {
            return false;
        }
        if self.ip_lower.is_none() {
            return false;
        }
        if self.composed_info.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ip_upper = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ip_lower = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.composed_info = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ip_upper {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ip_lower {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.composed_info {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ip_upper {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ip_lower {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.composed_info {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebRTCICECandidate {
        WebRTCICECandidate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ip_upper",
                |m: &WebRTCICECandidate| { &m.ip_upper },
                |m: &mut WebRTCICECandidate| { &mut m.ip_upper },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ip_lower",
                |m: &WebRTCICECandidate| { &m.ip_lower },
                |m: &mut WebRTCICECandidate| { &mut m.ip_lower },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "composed_info",
                |m: &WebRTCICECandidate| { &m.composed_info },
                |m: &mut WebRTCICECandidate| { &mut m.composed_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WebRTCICECandidate>(
                "WebRTCICECandidate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WebRTCICECandidate {
        static instance: ::protobuf::rt::LazyV2<WebRTCICECandidate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebRTCICECandidate::new)
    }
}

impl ::protobuf::Clear for WebRTCICECandidate {
    fn clear(&mut self) {
        self.ip_upper = ::std::option::Option::None;
        self.ip_lower = ::std::option::Option::None;
        self.composed_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebRTCICECandidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCICECandidate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WebRTCSDP {
    // message fields
    field_type: ::std::option::Option<u32>,
    pub candidates: ::protobuf::RepeatedField<WebRTCICECandidate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebRTCSDP {
    fn default() -> &'a WebRTCSDP {
        <WebRTCSDP as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCSDP {
    pub fn new() -> WebRTCSDP {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // repeated .tapdance.WebRTCICECandidate candidates = 2;


    pub fn get_candidates(&self) -> &[WebRTCICECandidate] {
        &self.candidates
    }
    pub fn clear_candidates(&mut self) {
        self.candidates.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidates(&mut self, v: ::protobuf::RepeatedField<WebRTCICECandidate>) {
        self.candidates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_candidates(&mut self) -> &mut ::protobuf::RepeatedField<WebRTCICECandidate> {
        &mut self.candidates
    }

    // Take field
    pub fn take_candidates(&mut self) -> ::protobuf::RepeatedField<WebRTCICECandidate> {
        ::std::mem::replace(&mut self.candidates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WebRTCSDP {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.candidates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.candidates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.candidates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        for v in &self.candidates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebRTCSDP {
        WebRTCSDP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &WebRTCSDP| { &m.field_type },
                |m: &mut WebRTCSDP| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WebRTCICECandidate>>(
                "candidates",
                |m: &WebRTCSDP| { &m.candidates },
                |m: &mut WebRTCSDP| { &mut m.candidates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WebRTCSDP>(
                "WebRTCSDP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WebRTCSDP {
        static instance: ::protobuf::rt::LazyV2<WebRTCSDP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebRTCSDP::new)
    }
}

impl ::protobuf::Clear for WebRTCSDP {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.candidates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebRTCSDP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCSDP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WebRTCSignal {
    // message fields
    seed: ::protobuf::SingularField<::std::string::String>,
    pub sdp: ::protobuf::SingularPtrField<WebRTCSDP>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebRTCSignal {
    fn default() -> &'a WebRTCSignal {
        <WebRTCSignal as ::protobuf::Message>::default_instance()
    }
}

impl WebRTCSignal {
    pub fn new() -> WebRTCSignal {
        ::std::default::Default::default()
    }

    // required string seed = 1;


    pub fn get_seed(&self) -> &str {
        match self.seed.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_seed(&mut self) {
        self.seed.clear();
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: ::std::string::String) {
        self.seed = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed(&mut self) -> &mut ::std::string::String {
        if self.seed.is_none() {
            self.seed.set_default();
        }
        self.seed.as_mut().unwrap()
    }

    // Take field
    pub fn take_seed(&mut self) -> ::std::string::String {
        self.seed.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .tapdance.WebRTCSDP sdp = 2;


    pub fn get_sdp(&self) -> &WebRTCSDP {
        self.sdp.as_ref().unwrap_or_else(|| <WebRTCSDP as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sdp(&mut self) {
        self.sdp.clear();
    }

    pub fn has_sdp(&self) -> bool {
        self.sdp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp(&mut self, v: WebRTCSDP) {
        self.sdp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp(&mut self) -> &mut WebRTCSDP {
        if self.sdp.is_none() {
            self.sdp.set_default();
        }
        self.sdp.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp(&mut self) -> WebRTCSDP {
        self.sdp.take().unwrap_or_else(|| WebRTCSDP::new())
    }
}

impl ::protobuf::Message for WebRTCSignal {
    fn is_initialized(&self) -> bool {
        if self.seed.is_none() {
            return false;
        }
        if self.sdp.is_none() {
            return false;
        }
        for v in &self.sdp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sdp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.seed.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sdp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.seed.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sdp.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebRTCSignal {
        WebRTCSignal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seed",
                |m: &WebRTCSignal| { &m.seed },
                |m: &mut WebRTCSignal| { &mut m.seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WebRTCSDP>>(
                "sdp",
                |m: &WebRTCSignal| { &m.sdp },
                |m: &mut WebRTCSignal| { &mut m.sdp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WebRTCSignal>(
                "WebRTCSignal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WebRTCSignal {
        static instance: ::protobuf::rt::LazyV2<WebRTCSignal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebRTCSignal::new)
    }
}

impl ::protobuf::Clear for WebRTCSignal {
    fn clear(&mut self) {
        self.seed.clear();
        self.sdp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebRTCSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRTCSignal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StationToClient {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    state_transition: ::std::option::Option<S2C_Transition>,
    pub config_info: ::protobuf::SingularPtrField<ClientConf>,
    err_reason: ::std::option::Option<ErrorReasonS2C>,
    tmp_backoff: ::std::option::Option<u32>,
    station_id: ::protobuf::SingularField<::std::string::String>,
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StationToClient {
    fn default() -> &'a StationToClient {
        <StationToClient as ::protobuf::Message>::default_instance()
    }
}

impl StationToClient {
    pub fn new() -> StationToClient {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional .tapdance.S2C_Transition state_transition = 2;


    pub fn get_state_transition(&self) -> S2C_Transition {
        self.state_transition.unwrap_or(S2C_Transition::S2C_NO_CHANGE)
    }
    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: S2C_Transition) {
        self.state_transition = ::std::option::Option::Some(v);
    }

    // optional .tapdance.ClientConf config_info = 3;


    pub fn get_config_info(&self) -> &ClientConf {
        self.config_info.as_ref().unwrap_or_else(|| <ClientConf as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config_info(&mut self) {
        self.config_info.clear();
    }

    pub fn has_config_info(&self) -> bool {
        self.config_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_info(&mut self, v: ClientConf) {
        self.config_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_info(&mut self) -> &mut ClientConf {
        if self.config_info.is_none() {
            self.config_info.set_default();
        }
        self.config_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_info(&mut self) -> ClientConf {
        self.config_info.take().unwrap_or_else(|| ClientConf::new())
    }

    // optional .tapdance.ErrorReasonS2C err_reason = 4;


    pub fn get_err_reason(&self) -> ErrorReasonS2C {
        self.err_reason.unwrap_or(ErrorReasonS2C::NO_ERROR)
    }
    pub fn clear_err_reason(&mut self) {
        self.err_reason = ::std::option::Option::None;
    }

    pub fn has_err_reason(&self) -> bool {
        self.err_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_err_reason(&mut self, v: ErrorReasonS2C) {
        self.err_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 tmp_backoff = 5;


    pub fn get_tmp_backoff(&self) -> u32 {
        self.tmp_backoff.unwrap_or(0)
    }
    pub fn clear_tmp_backoff(&mut self) {
        self.tmp_backoff = ::std::option::Option::None;
    }

    pub fn has_tmp_backoff(&self) -> bool {
        self.tmp_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tmp_backoff(&mut self, v: u32) {
        self.tmp_backoff = ::std::option::Option::Some(v);
    }

    // optional string station_id = 6;


    pub fn get_station_id(&self) -> &str {
        match self.station_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_station_id(&mut self) {
        self.station_id.clear();
    }

    pub fn has_station_id(&self) -> bool {
        self.station_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_id(&mut self, v: ::std::string::String) {
        self.station_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_station_id(&mut self) -> &mut ::std::string::String {
        if self.station_id.is_none() {
            self.station_id.set_default();
        }
        self.station_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_station_id(&mut self) -> ::std::string::String {
        self.station_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes padding = 100;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StationToClient {
    fn is_initialized(&self) -> bool {
        for v in &self.config_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state_transition, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config_info)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.err_reason, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tmp_backoff = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.station_id)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.config_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.err_reason {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.tmp_backoff {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.station_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.config_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.err_reason {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.tmp_backoff {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.station_id.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(100, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StationToClient {
        StationToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &StationToClient| { &m.protocol_version },
                |m: &mut StationToClient| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<S2C_Transition>>(
                "state_transition",
                |m: &StationToClient| { &m.state_transition },
                |m: &mut StationToClient| { &mut m.state_transition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientConf>>(
                "config_info",
                |m: &StationToClient| { &m.config_info },
                |m: &mut StationToClient| { &mut m.config_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ErrorReasonS2C>>(
                "err_reason",
                |m: &StationToClient| { &m.err_reason },
                |m: &mut StationToClient| { &mut m.err_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tmp_backoff",
                |m: &StationToClient| { &m.tmp_backoff },
                |m: &mut StationToClient| { &mut m.tmp_backoff },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "station_id",
                |m: &StationToClient| { &m.station_id },
                |m: &mut StationToClient| { &mut m.station_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &StationToClient| { &m.padding },
                |m: &mut StationToClient| { &mut m.padding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StationToClient>(
                "StationToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StationToClient {
        static instance: ::protobuf::rt::LazyV2<StationToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StationToClient::new)
    }
}

impl ::protobuf::Clear for StationToClient {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.config_info.clear();
        self.err_reason = ::std::option::Option::None;
        self.tmp_backoff = ::std::option::Option::None;
        self.station_id.clear();
        self.padding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StationToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationFlags {
    // message fields
    upload_only: ::std::option::Option<bool>,
    dark_decoy: ::std::option::Option<bool>,
    proxy_header: ::std::option::Option<bool>,
    use_TIL: ::std::option::Option<bool>,
    prescanned: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationFlags {
    fn default() -> &'a RegistrationFlags {
        <RegistrationFlags as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationFlags {
    pub fn new() -> RegistrationFlags {
        ::std::default::Default::default()
    }

    // optional bool upload_only = 1;


    pub fn get_upload_only(&self) -> bool {
        self.upload_only.unwrap_or(false)
    }
    pub fn clear_upload_only(&mut self) {
        self.upload_only = ::std::option::Option::None;
    }

    pub fn has_upload_only(&self) -> bool {
        self.upload_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_only(&mut self, v: bool) {
        self.upload_only = ::std::option::Option::Some(v);
    }

    // optional bool dark_decoy = 2;


    pub fn get_dark_decoy(&self) -> bool {
        self.dark_decoy.unwrap_or(false)
    }
    pub fn clear_dark_decoy(&mut self) {
        self.dark_decoy = ::std::option::Option::None;
    }

    pub fn has_dark_decoy(&self) -> bool {
        self.dark_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dark_decoy(&mut self, v: bool) {
        self.dark_decoy = ::std::option::Option::Some(v);
    }

    // optional bool proxy_header = 3;


    pub fn get_proxy_header(&self) -> bool {
        self.proxy_header.unwrap_or(false)
    }
    pub fn clear_proxy_header(&mut self) {
        self.proxy_header = ::std::option::Option::None;
    }

    pub fn has_proxy_header(&self) -> bool {
        self.proxy_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_header(&mut self, v: bool) {
        self.proxy_header = ::std::option::Option::Some(v);
    }

    // optional bool use_TIL = 4;


    pub fn get_use_TIL(&self) -> bool {
        self.use_TIL.unwrap_or(false)
    }
    pub fn clear_use_TIL(&mut self) {
        self.use_TIL = ::std::option::Option::None;
    }

    pub fn has_use_TIL(&self) -> bool {
        self.use_TIL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_TIL(&mut self, v: bool) {
        self.use_TIL = ::std::option::Option::Some(v);
    }

    // optional bool prescanned = 5;


    pub fn get_prescanned(&self) -> bool {
        self.prescanned.unwrap_or(false)
    }
    pub fn clear_prescanned(&mut self) {
        self.prescanned = ::std::option::Option::None;
    }

    pub fn has_prescanned(&self) -> bool {
        self.prescanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prescanned(&mut self, v: bool) {
        self.prescanned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RegistrationFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.upload_only = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dark_decoy = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.proxy_header = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_TIL = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prescanned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.upload_only {
            my_size += 2;
        }
        if let Some(v) = self.dark_decoy {
            my_size += 2;
        }
        if let Some(v) = self.proxy_header {
            my_size += 2;
        }
        if let Some(v) = self.use_TIL {
            my_size += 2;
        }
        if let Some(v) = self.prescanned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.upload_only {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dark_decoy {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.proxy_header {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.use_TIL {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.prescanned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationFlags {
        RegistrationFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "upload_only",
                |m: &RegistrationFlags| { &m.upload_only },
                |m: &mut RegistrationFlags| { &mut m.upload_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dark_decoy",
                |m: &RegistrationFlags| { &m.dark_decoy },
                |m: &mut RegistrationFlags| { &mut m.dark_decoy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "proxy_header",
                |m: &RegistrationFlags| { &m.proxy_header },
                |m: &mut RegistrationFlags| { &mut m.proxy_header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_TIL",
                |m: &RegistrationFlags| { &m.use_TIL },
                |m: &mut RegistrationFlags| { &mut m.use_TIL },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prescanned",
                |m: &RegistrationFlags| { &m.prescanned },
                |m: &mut RegistrationFlags| { &mut m.prescanned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationFlags>(
                "RegistrationFlags",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationFlags {
        static instance: ::protobuf::rt::LazyV2<RegistrationFlags> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationFlags::new)
    }
}

impl ::protobuf::Clear for RegistrationFlags {
    fn clear(&mut self) {
        self.upload_only = ::std::option::Option::None;
        self.dark_decoy = ::std::option::Option::None;
        self.proxy_header = ::std::option::Option::None;
        self.use_TIL = ::std::option::Option::None;
        self.prescanned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientToStation {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    decoy_list_generation: ::std::option::Option<u32>,
    state_transition: ::std::option::Option<C2S_Transition>,
    upload_sync: ::std::option::Option<u64>,
    client_lib_version: ::std::option::Option<u32>,
    pub failed_decoys: ::protobuf::RepeatedField<::std::string::String>,
    pub stats: ::protobuf::SingularPtrField<SessionStats>,
    transport: ::std::option::Option<TransportType>,
    pub transport_params: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    covert_address: ::protobuf::SingularField<::std::string::String>,
    masked_decoy_server_name: ::protobuf::SingularField<::std::string::String>,
    v6_support: ::std::option::Option<bool>,
    v4_support: ::std::option::Option<bool>,
    pub flags: ::protobuf::SingularPtrField<RegistrationFlags>,
    pub webrtc_signal: ::protobuf::SingularPtrField<WebRTCSignal>,
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientToStation {
    fn default() -> &'a ClientToStation {
        <ClientToStation as ::protobuf::Message>::default_instance()
    }
}

impl ClientToStation {
    pub fn new() -> ClientToStation {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 decoy_list_generation = 2;


    pub fn get_decoy_list_generation(&self) -> u32 {
        self.decoy_list_generation.unwrap_or(0)
    }
    pub fn clear_decoy_list_generation(&mut self) {
        self.decoy_list_generation = ::std::option::Option::None;
    }

    pub fn has_decoy_list_generation(&self) -> bool {
        self.decoy_list_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_list_generation(&mut self, v: u32) {
        self.decoy_list_generation = ::std::option::Option::Some(v);
    }

    // optional .tapdance.C2S_Transition state_transition = 3;


    pub fn get_state_transition(&self) -> C2S_Transition {
        self.state_transition.unwrap_or(C2S_Transition::C2S_NO_CHANGE)
    }
    pub fn clear_state_transition(&mut self) {
        self.state_transition = ::std::option::Option::None;
    }

    pub fn has_state_transition(&self) -> bool {
        self.state_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_transition(&mut self, v: C2S_Transition) {
        self.state_transition = ::std::option::Option::Some(v);
    }

    // optional uint64 upload_sync = 4;


    pub fn get_upload_sync(&self) -> u64 {
        self.upload_sync.unwrap_or(0)
    }
    pub fn clear_upload_sync(&mut self) {
        self.upload_sync = ::std::option::Option::None;
    }

    pub fn has_upload_sync(&self) -> bool {
        self.upload_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_sync(&mut self, v: u64) {
        self.upload_sync = ::std::option::Option::Some(v);
    }

    // optional uint32 client_lib_version = 5;


    pub fn get_client_lib_version(&self) -> u32 {
        self.client_lib_version.unwrap_or(0)
    }
    pub fn clear_client_lib_version(&mut self) {
        self.client_lib_version = ::std::option::Option::None;
    }

    pub fn has_client_lib_version(&self) -> bool {
        self.client_lib_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_lib_version(&mut self, v: u32) {
        self.client_lib_version = ::std::option::Option::Some(v);
    }

    // repeated string failed_decoys = 10;


    pub fn get_failed_decoys(&self) -> &[::std::string::String] {
        &self.failed_decoys
    }
    pub fn clear_failed_decoys(&mut self) {
        self.failed_decoys.clear();
    }

    // Param is passed by value, moved
    pub fn set_failed_decoys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.failed_decoys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failed_decoys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.failed_decoys
    }

    // Take field
    pub fn take_failed_decoys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.failed_decoys, ::protobuf::RepeatedField::new())
    }

    // optional .tapdance.SessionStats stats = 11;


    pub fn get_stats(&self) -> &SessionStats {
        self.stats.as_ref().unwrap_or_else(|| <SessionStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: SessionStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut SessionStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> SessionStats {
        self.stats.take().unwrap_or_else(|| SessionStats::new())
    }

    // optional .tapdance.TransportType transport = 12;


    pub fn get_transport(&self) -> TransportType {
        self.transport.unwrap_or(TransportType::Null)
    }
    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: TransportType) {
        self.transport = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.Any transport_params = 13;


    pub fn get_transport_params(&self) -> &::protobuf::well_known_types::Any {
        self.transport_params.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transport_params(&mut self) {
        self.transport_params.clear();
    }

    pub fn has_transport_params(&self) -> bool {
        self.transport_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_params(&mut self, v: ::protobuf::well_known_types::Any) {
        self.transport_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transport_params(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.transport_params.is_none() {
            self.transport_params.set_default();
        }
        self.transport_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_transport_params(&mut self) -> ::protobuf::well_known_types::Any {
        self.transport_params.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // optional string covert_address = 20;


    pub fn get_covert_address(&self) -> &str {
        match self.covert_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_covert_address(&mut self) {
        self.covert_address.clear();
    }

    pub fn has_covert_address(&self) -> bool {
        self.covert_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_covert_address(&mut self, v: ::std::string::String) {
        self.covert_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_covert_address(&mut self) -> &mut ::std::string::String {
        if self.covert_address.is_none() {
            self.covert_address.set_default();
        }
        self.covert_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_covert_address(&mut self) -> ::std::string::String {
        self.covert_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string masked_decoy_server_name = 21;


    pub fn get_masked_decoy_server_name(&self) -> &str {
        match self.masked_decoy_server_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_masked_decoy_server_name(&mut self) {
        self.masked_decoy_server_name.clear();
    }

    pub fn has_masked_decoy_server_name(&self) -> bool {
        self.masked_decoy_server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked_decoy_server_name(&mut self, v: ::std::string::String) {
        self.masked_decoy_server_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked_decoy_server_name(&mut self) -> &mut ::std::string::String {
        if self.masked_decoy_server_name.is_none() {
            self.masked_decoy_server_name.set_default();
        }
        self.masked_decoy_server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked_decoy_server_name(&mut self) -> ::std::string::String {
        self.masked_decoy_server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool v6_support = 22;


    pub fn get_v6_support(&self) -> bool {
        self.v6_support.unwrap_or(false)
    }
    pub fn clear_v6_support(&mut self) {
        self.v6_support = ::std::option::Option::None;
    }

    pub fn has_v6_support(&self) -> bool {
        self.v6_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v6_support(&mut self, v: bool) {
        self.v6_support = ::std::option::Option::Some(v);
    }

    // optional bool v4_support = 23;


    pub fn get_v4_support(&self) -> bool {
        self.v4_support.unwrap_or(false)
    }
    pub fn clear_v4_support(&mut self) {
        self.v4_support = ::std::option::Option::None;
    }

    pub fn has_v4_support(&self) -> bool {
        self.v4_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v4_support(&mut self, v: bool) {
        self.v4_support = ::std::option::Option::Some(v);
    }

    // optional .tapdance.RegistrationFlags flags = 24;


    pub fn get_flags(&self) -> &RegistrationFlags {
        self.flags.as_ref().unwrap_or_else(|| <RegistrationFlags as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: RegistrationFlags) {
        self.flags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&mut self) -> &mut RegistrationFlags {
        if self.flags.is_none() {
            self.flags.set_default();
        }
        self.flags.as_mut().unwrap()
    }

    // Take field
    pub fn take_flags(&mut self) -> RegistrationFlags {
        self.flags.take().unwrap_or_else(|| RegistrationFlags::new())
    }

    // optional .tapdance.WebRTCSignal webrtc_signal = 31;


    pub fn get_webrtc_signal(&self) -> &WebRTCSignal {
        self.webrtc_signal.as_ref().unwrap_or_else(|| <WebRTCSignal as ::protobuf::Message>::default_instance())
    }
    pub fn clear_webrtc_signal(&mut self) {
        self.webrtc_signal.clear();
    }

    pub fn has_webrtc_signal(&self) -> bool {
        self.webrtc_signal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_signal(&mut self, v: WebRTCSignal) {
        self.webrtc_signal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webrtc_signal(&mut self) -> &mut WebRTCSignal {
        if self.webrtc_signal.is_none() {
            self.webrtc_signal.set_default();
        }
        self.webrtc_signal.as_mut().unwrap()
    }

    // Take field
    pub fn take_webrtc_signal(&mut self) -> WebRTCSignal {
        self.webrtc_signal.take().unwrap_or_else(|| WebRTCSignal::new())
    }

    // optional bytes padding = 100;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ClientToStation {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.webrtc_signal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.decoy_list_generation = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state_transition, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upload_sync = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_lib_version = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.failed_decoys)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                12 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.transport, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transport_params)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.covert_address)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.masked_decoy_server_name)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.v6_support = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.v4_support = ::std::option::Option::Some(tmp);
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flags)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.webrtc_signal)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.decoy_list_generation {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state_transition {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.upload_sync {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_lib_version {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.failed_decoys {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::enum_size(12, v);
        }
        if let Some(ref v) = self.transport_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.covert_address.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.masked_decoy_server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.v6_support {
            my_size += 3;
        }
        if let Some(v) = self.v4_support {
            my_size += 3;
        }
        if let Some(ref v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.webrtc_signal.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.decoy_list_generation {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state_transition {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.upload_sync {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.client_lib_version {
            os.write_uint32(5, v)?;
        }
        for v in &self.failed_decoys {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.transport_params.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.covert_address.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.masked_decoy_server_name.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(v) = self.v6_support {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.v4_support {
            os.write_bool(23, v)?;
        }
        if let Some(ref v) = self.flags.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.webrtc_signal.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(100, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientToStation {
        ClientToStation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &ClientToStation| { &m.protocol_version },
                |m: &mut ClientToStation| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "decoy_list_generation",
                |m: &ClientToStation| { &m.decoy_list_generation },
                |m: &mut ClientToStation| { &mut m.decoy_list_generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<C2S_Transition>>(
                "state_transition",
                |m: &ClientToStation| { &m.state_transition },
                |m: &mut ClientToStation| { &mut m.state_transition },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upload_sync",
                |m: &ClientToStation| { &m.upload_sync },
                |m: &mut ClientToStation| { &mut m.upload_sync },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_lib_version",
                |m: &ClientToStation| { &m.client_lib_version },
                |m: &mut ClientToStation| { &mut m.client_lib_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "failed_decoys",
                |m: &ClientToStation| { &m.failed_decoys },
                |m: &mut ClientToStation| { &mut m.failed_decoys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SessionStats>>(
                "stats",
                |m: &ClientToStation| { &m.stats },
                |m: &mut ClientToStation| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransportType>>(
                "transport",
                |m: &ClientToStation| { &m.transport },
                |m: &mut ClientToStation| { &mut m.transport },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "transport_params",
                |m: &ClientToStation| { &m.transport_params },
                |m: &mut ClientToStation| { &mut m.transport_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "covert_address",
                |m: &ClientToStation| { &m.covert_address },
                |m: &mut ClientToStation| { &mut m.covert_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "masked_decoy_server_name",
                |m: &ClientToStation| { &m.masked_decoy_server_name },
                |m: &mut ClientToStation| { &mut m.masked_decoy_server_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "v6_support",
                |m: &ClientToStation| { &m.v6_support },
                |m: &mut ClientToStation| { &mut m.v6_support },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "v4_support",
                |m: &ClientToStation| { &m.v4_support },
                |m: &mut ClientToStation| { &mut m.v4_support },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegistrationFlags>>(
                "flags",
                |m: &ClientToStation| { &m.flags },
                |m: &mut ClientToStation| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WebRTCSignal>>(
                "webrtc_signal",
                |m: &ClientToStation| { &m.webrtc_signal },
                |m: &mut ClientToStation| { &mut m.webrtc_signal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &ClientToStation| { &m.padding },
                |m: &mut ClientToStation| { &mut m.padding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientToStation>(
                "ClientToStation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientToStation {
        static instance: ::protobuf::rt::LazyV2<ClientToStation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientToStation::new)
    }
}

impl ::protobuf::Clear for ClientToStation {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.decoy_list_generation = ::std::option::Option::None;
        self.state_transition = ::std::option::Option::None;
        self.upload_sync = ::std::option::Option::None;
        self.client_lib_version = ::std::option::Option::None;
        self.failed_decoys.clear();
        self.stats.clear();
        self.transport = ::std::option::Option::None;
        self.transport_params.clear();
        self.covert_address.clear();
        self.masked_decoy_server_name.clear();
        self.v6_support = ::std::option::Option::None;
        self.v4_support = ::std::option::Option::None;
        self.flags.clear();
        self.webrtc_signal.clear();
        self.padding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientToStation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientToStation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenericTransportParams {
    // message fields
    randomize_dst_port: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenericTransportParams {
    fn default() -> &'a GenericTransportParams {
        <GenericTransportParams as ::protobuf::Message>::default_instance()
    }
}

impl GenericTransportParams {
    pub fn new() -> GenericTransportParams {
        ::std::default::Default::default()
    }

    // optional bool randomize_dst_port = 13;


    pub fn get_randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.unwrap_or(false)
    }
    pub fn clear_randomize_dst_port(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
    }

    pub fn has_randomize_dst_port(&self) -> bool {
        self.randomize_dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomize_dst_port(&mut self, v: bool) {
        self.randomize_dst_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GenericTransportParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.randomize_dst_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.randomize_dst_port {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.randomize_dst_port {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenericTransportParams {
        GenericTransportParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "randomize_dst_port",
                |m: &GenericTransportParams| { &m.randomize_dst_port },
                |m: &mut GenericTransportParams| { &mut m.randomize_dst_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenericTransportParams>(
                "GenericTransportParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenericTransportParams {
        static instance: ::protobuf::rt::LazyV2<GenericTransportParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenericTransportParams::new)
    }
}

impl ::protobuf::Clear for GenericTransportParams {
    fn clear(&mut self) {
        self.randomize_dst_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenericTransportParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericTransportParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct C2SWrapper {
    // message fields
    shared_secret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub registration_payload: ::protobuf::SingularPtrField<ClientToStation>,
    registration_source: ::std::option::Option<RegistrationSource>,
    registration_address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    decoy_address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub registration_response: ::protobuf::SingularPtrField<RegistrationResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a C2SWrapper {
    fn default() -> &'a C2SWrapper {
        <C2SWrapper as ::protobuf::Message>::default_instance()
    }
}

impl C2SWrapper {
    pub fn new() -> C2SWrapper {
        ::std::default::Default::default()
    }

    // optional bytes shared_secret = 1;


    pub fn get_shared_secret(&self) -> &[u8] {
        match self.shared_secret.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_shared_secret(&mut self) {
        self.shared_secret.clear();
    }

    pub fn has_shared_secret(&self) -> bool {
        self.shared_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.shared_secret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shared_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.shared_secret.is_none() {
            self.shared_secret.set_default();
        }
        self.shared_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_shared_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.shared_secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.ClientToStation registration_payload = 3;


    pub fn get_registration_payload(&self) -> &ClientToStation {
        self.registration_payload.as_ref().unwrap_or_else(|| <ClientToStation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration_payload(&mut self) {
        self.registration_payload.clear();
    }

    pub fn has_registration_payload(&self) -> bool {
        self.registration_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_payload(&mut self, v: ClientToStation) {
        self.registration_payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_payload(&mut self) -> &mut ClientToStation {
        if self.registration_payload.is_none() {
            self.registration_payload.set_default();
        }
        self.registration_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_payload(&mut self) -> ClientToStation {
        self.registration_payload.take().unwrap_or_else(|| ClientToStation::new())
    }

    // optional .tapdance.RegistrationSource registration_source = 4;


    pub fn get_registration_source(&self) -> RegistrationSource {
        self.registration_source.unwrap_or(RegistrationSource::Unspecified)
    }
    pub fn clear_registration_source(&mut self) {
        self.registration_source = ::std::option::Option::None;
    }

    pub fn has_registration_source(&self) -> bool {
        self.registration_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_source(&mut self, v: RegistrationSource) {
        self.registration_source = ::std::option::Option::Some(v);
    }

    // optional bytes registration_address = 6;


    pub fn get_registration_address(&self) -> &[u8] {
        match self.registration_address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_registration_address(&mut self) {
        self.registration_address.clear();
    }

    pub fn has_registration_address(&self) -> bool {
        self.registration_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.registration_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.registration_address.is_none() {
            self.registration_address.set_default();
        }
        self.registration_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_address(&mut self) -> ::std::vec::Vec<u8> {
        self.registration_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes decoy_address = 7;


    pub fn get_decoy_address(&self) -> &[u8] {
        match self.decoy_address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_decoy_address(&mut self) {
        self.decoy_address.clear();
    }

    pub fn has_decoy_address(&self) -> bool {
        self.decoy_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoy_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.decoy_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoy_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.decoy_address.is_none() {
            self.decoy_address.set_default();
        }
        self.decoy_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_decoy_address(&mut self) -> ::std::vec::Vec<u8> {
        self.decoy_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .tapdance.RegistrationResponse registration_response = 8;


    pub fn get_registration_response(&self) -> &RegistrationResponse {
        self.registration_response.as_ref().unwrap_or_else(|| <RegistrationResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration_response(&mut self) {
        self.registration_response.clear();
    }

    pub fn has_registration_response(&self) -> bool {
        self.registration_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_response(&mut self, v: RegistrationResponse) {
        self.registration_response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_response(&mut self) -> &mut RegistrationResponse {
        if self.registration_response.is_none() {
            self.registration_response.set_default();
        }
        self.registration_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_response(&mut self) -> RegistrationResponse {
        self.registration_response.take().unwrap_or_else(|| RegistrationResponse::new())
    }
}

impl ::protobuf::Message for C2SWrapper {
    fn is_initialized(&self) -> bool {
        for v in &self.registration_payload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.registration_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.shared_secret)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration_payload)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.registration_source, 4, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.registration_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.decoy_address)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shared_secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.registration_payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.registration_source {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.registration_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.decoy_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.registration_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shared_secret.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.registration_payload.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.registration_source {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.registration_address.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.decoy_address.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.registration_response.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> C2SWrapper {
        C2SWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "shared_secret",
                |m: &C2SWrapper| { &m.shared_secret },
                |m: &mut C2SWrapper| { &mut m.shared_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientToStation>>(
                "registration_payload",
                |m: &C2SWrapper| { &m.registration_payload },
                |m: &mut C2SWrapper| { &mut m.registration_payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RegistrationSource>>(
                "registration_source",
                |m: &C2SWrapper| { &m.registration_source },
                |m: &mut C2SWrapper| { &mut m.registration_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "registration_address",
                |m: &C2SWrapper| { &m.registration_address },
                |m: &mut C2SWrapper| { &mut m.registration_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "decoy_address",
                |m: &C2SWrapper| { &m.decoy_address },
                |m: &mut C2SWrapper| { &mut m.decoy_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegistrationResponse>>(
                "registration_response",
                |m: &C2SWrapper| { &m.registration_response },
                |m: &mut C2SWrapper| { &mut m.registration_response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<C2SWrapper>(
                "C2SWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static C2SWrapper {
        static instance: ::protobuf::rt::LazyV2<C2SWrapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(C2SWrapper::new)
    }
}

impl ::protobuf::Clear for C2SWrapper {
    fn clear(&mut self) {
        self.shared_secret.clear();
        self.registration_payload.clear();
        self.registration_source = ::std::option::Option::None;
        self.registration_address.clear();
        self.decoy_address.clear();
        self.registration_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for C2SWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for C2SWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SessionStats {
    // message fields
    failed_decoys_amount: ::std::option::Option<u32>,
    total_time_to_connect: ::std::option::Option<u32>,
    rtt_to_station: ::std::option::Option<u32>,
    tls_to_decoy: ::std::option::Option<u32>,
    tcp_to_decoy: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionStats {
    fn default() -> &'a SessionStats {
        <SessionStats as ::protobuf::Message>::default_instance()
    }
}

impl SessionStats {
    pub fn new() -> SessionStats {
        ::std::default::Default::default()
    }

    // optional uint32 failed_decoys_amount = 20;


    pub fn get_failed_decoys_amount(&self) -> u32 {
        self.failed_decoys_amount.unwrap_or(0)
    }
    pub fn clear_failed_decoys_amount(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
    }

    pub fn has_failed_decoys_amount(&self) -> bool {
        self.failed_decoys_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_decoys_amount(&mut self, v: u32) {
        self.failed_decoys_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 total_time_to_connect = 31;


    pub fn get_total_time_to_connect(&self) -> u32 {
        self.total_time_to_connect.unwrap_or(0)
    }
    pub fn clear_total_time_to_connect(&mut self) {
        self.total_time_to_connect = ::std::option::Option::None;
    }

    pub fn has_total_time_to_connect(&self) -> bool {
        self.total_time_to_connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_time_to_connect(&mut self, v: u32) {
        self.total_time_to_connect = ::std::option::Option::Some(v);
    }

    // optional uint32 rtt_to_station = 33;


    pub fn get_rtt_to_station(&self) -> u32 {
        self.rtt_to_station.unwrap_or(0)
    }
    pub fn clear_rtt_to_station(&mut self) {
        self.rtt_to_station = ::std::option::Option::None;
    }

    pub fn has_rtt_to_station(&self) -> bool {
        self.rtt_to_station.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtt_to_station(&mut self, v: u32) {
        self.rtt_to_station = ::std::option::Option::Some(v);
    }

    // optional uint32 tls_to_decoy = 38;


    pub fn get_tls_to_decoy(&self) -> u32 {
        self.tls_to_decoy.unwrap_or(0)
    }
    pub fn clear_tls_to_decoy(&mut self) {
        self.tls_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tls_to_decoy(&self) -> bool {
        self.tls_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls_to_decoy(&mut self, v: u32) {
        self.tls_to_decoy = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_to_decoy = 39;


    pub fn get_tcp_to_decoy(&self) -> u32 {
        self.tcp_to_decoy.unwrap_or(0)
    }
    pub fn clear_tcp_to_decoy(&mut self) {
        self.tcp_to_decoy = ::std::option::Option::None;
    }

    pub fn has_tcp_to_decoy(&self) -> bool {
        self.tcp_to_decoy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_to_decoy(&mut self, v: u32) {
        self.tcp_to_decoy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SessionStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.failed_decoys_amount = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_time_to_connect = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtt_to_station = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tls_to_decoy = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcp_to_decoy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.failed_decoys_amount {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_time_to_connect {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtt_to_station {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tls_to_decoy {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tcp_to_decoy {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.failed_decoys_amount {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.total_time_to_connect {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.rtt_to_station {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.tls_to_decoy {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.tcp_to_decoy {
            os.write_uint32(39, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionStats {
        SessionStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "failed_decoys_amount",
                |m: &SessionStats| { &m.failed_decoys_amount },
                |m: &mut SessionStats| { &mut m.failed_decoys_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_time_to_connect",
                |m: &SessionStats| { &m.total_time_to_connect },
                |m: &mut SessionStats| { &mut m.total_time_to_connect },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rtt_to_station",
                |m: &SessionStats| { &m.rtt_to_station },
                |m: &mut SessionStats| { &mut m.rtt_to_station },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tls_to_decoy",
                |m: &SessionStats| { &m.tls_to_decoy },
                |m: &mut SessionStats| { &mut m.tls_to_decoy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tcp_to_decoy",
                |m: &SessionStats| { &m.tcp_to_decoy },
                |m: &mut SessionStats| { &mut m.tcp_to_decoy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionStats>(
                "SessionStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SessionStats {
        static instance: ::protobuf::rt::LazyV2<SessionStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SessionStats::new)
    }
}

impl ::protobuf::Clear for SessionStats {
    fn clear(&mut self) {
        self.failed_decoys_amount = ::std::option::Option::None;
        self.total_time_to_connect = ::std::option::Option::None;
        self.rtt_to_station = ::std::option::Option::None;
        self.tls_to_decoy = ::std::option::Option::None;
        self.tcp_to_decoy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StationToDetector {
    // message fields
    phantom_ip: ::protobuf::SingularField<::std::string::String>,
    client_ip: ::protobuf::SingularField<::std::string::String>,
    timeout_ns: ::std::option::Option<u64>,
    operation: ::std::option::Option<StationOperations>,
    dst_port: ::std::option::Option<u32>,
    src_port: ::std::option::Option<u32>,
    proto: ::std::option::Option<IPProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StationToDetector {
    fn default() -> &'a StationToDetector {
        <StationToDetector as ::protobuf::Message>::default_instance()
    }
}

impl StationToDetector {
    pub fn new() -> StationToDetector {
        ::std::default::Default::default()
    }

    // optional string phantom_ip = 1;


    pub fn get_phantom_ip(&self) -> &str {
        match self.phantom_ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phantom_ip(&mut self) {
        self.phantom_ip.clear();
    }

    pub fn has_phantom_ip(&self) -> bool {
        self.phantom_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phantom_ip(&mut self, v: ::std::string::String) {
        self.phantom_ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phantom_ip(&mut self) -> &mut ::std::string::String {
        if self.phantom_ip.is_none() {
            self.phantom_ip.set_default();
        }
        self.phantom_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_phantom_ip(&mut self) -> ::std::string::String {
        self.phantom_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string client_ip = 2;


    pub fn get_client_ip(&self) -> &str {
        match self.client_ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_ip(&mut self) {
        self.client_ip.clear();
    }

    pub fn has_client_ip(&self) -> bool {
        self.client_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_ip(&mut self, v: ::std::string::String) {
        self.client_ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_ip(&mut self) -> &mut ::std::string::String {
        if self.client_ip.is_none() {
            self.client_ip.set_default();
        }
        self.client_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_ip(&mut self) -> ::std::string::String {
        self.client_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timeout_ns = 3;


    pub fn get_timeout_ns(&self) -> u64 {
        self.timeout_ns.unwrap_or(0)
    }
    pub fn clear_timeout_ns(&mut self) {
        self.timeout_ns = ::std::option::Option::None;
    }

    pub fn has_timeout_ns(&self) -> bool {
        self.timeout_ns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ns(&mut self, v: u64) {
        self.timeout_ns = ::std::option::Option::Some(v);
    }

    // optional .tapdance.StationOperations operation = 4;


    pub fn get_operation(&self) -> StationOperations {
        self.operation.unwrap_or(StationOperations::Unknown)
    }
    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: StationOperations) {
        self.operation = ::std::option::Option::Some(v);
    }

    // optional uint32 dst_port = 10;


    pub fn get_dst_port(&self) -> u32 {
        self.dst_port.unwrap_or(0)
    }
    pub fn clear_dst_port(&mut self) {
        self.dst_port = ::std::option::Option::None;
    }

    pub fn has_dst_port(&self) -> bool {
        self.dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_port(&mut self, v: u32) {
        self.dst_port = ::std::option::Option::Some(v);
    }

    // optional uint32 src_port = 11;


    pub fn get_src_port(&self) -> u32 {
        self.src_port.unwrap_or(0)
    }
    pub fn clear_src_port(&mut self) {
        self.src_port = ::std::option::Option::None;
    }

    pub fn has_src_port(&self) -> bool {
        self.src_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_port(&mut self, v: u32) {
        self.src_port = ::std::option::Option::Some(v);
    }

    // optional .tapdance.IPProto proto = 12;


    pub fn get_proto(&self) -> IPProto {
        self.proto.unwrap_or(IPProto::Unk)
    }
    pub fn clear_proto(&mut self) {
        self.proto = ::std::option::Option::None;
    }

    pub fn has_proto(&self) -> bool {
        self.proto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proto(&mut self, v: IPProto) {
        self.proto = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StationToDetector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phantom_ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_ip)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout_ns = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.operation, 4, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_port = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_port = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.proto, 12, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phantom_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.client_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timeout_ns {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.dst_port {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.src_port {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.proto {
            my_size += ::protobuf::rt::enum_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phantom_ip.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.client_ip.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.timeout_ns {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.operation {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.dst_port {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.src_port {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.proto {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StationToDetector {
        StationToDetector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phantom_ip",
                |m: &StationToDetector| { &m.phantom_ip },
                |m: &mut StationToDetector| { &mut m.phantom_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_ip",
                |m: &StationToDetector| { &m.client_ip },
                |m: &mut StationToDetector| { &mut m.client_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeout_ns",
                |m: &StationToDetector| { &m.timeout_ns },
                |m: &mut StationToDetector| { &mut m.timeout_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StationOperations>>(
                "operation",
                |m: &StationToDetector| { &m.operation },
                |m: &mut StationToDetector| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dst_port",
                |m: &StationToDetector| { &m.dst_port },
                |m: &mut StationToDetector| { &mut m.dst_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "src_port",
                |m: &StationToDetector| { &m.src_port },
                |m: &mut StationToDetector| { &mut m.src_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IPProto>>(
                "proto",
                |m: &StationToDetector| { &m.proto },
                |m: &mut StationToDetector| { &mut m.proto },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StationToDetector>(
                "StationToDetector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StationToDetector {
        static instance: ::protobuf::rt::LazyV2<StationToDetector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StationToDetector::new)
    }
}

impl ::protobuf::Clear for StationToDetector {
    fn clear(&mut self) {
        self.phantom_ip.clear();
        self.client_ip.clear();
        self.timeout_ns = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.dst_port = ::std::option::Option::None;
        self.src_port = ::std::option::Option::None;
        self.proto = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StationToDetector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationToDetector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegistrationResponse {
    // message fields
    ipv4addr: ::std::option::Option<u32>,
    ipv6addr: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    dst_port: ::std::option::Option<u32>,
    serverRandom: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    error: ::protobuf::SingularField<::std::string::String>,
    pub clientConf: ::protobuf::SingularPtrField<ClientConf>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegistrationResponse {
    fn default() -> &'a RegistrationResponse {
        <RegistrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegistrationResponse {
    pub fn new() -> RegistrationResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ipv4addr = 1;


    pub fn get_ipv4addr(&self) -> u32 {
        self.ipv4addr.unwrap_or(0)
    }
    pub fn clear_ipv4addr(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
    }

    pub fn has_ipv4addr(&self) -> bool {
        self.ipv4addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4addr(&mut self, v: u32) {
        self.ipv4addr = ::std::option::Option::Some(v);
    }

    // optional bytes ipv6addr = 2;


    pub fn get_ipv6addr(&self) -> &[u8] {
        match self.ipv6addr.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ipv6addr(&mut self) {
        self.ipv6addr.clear();
    }

    pub fn has_ipv6addr(&self) -> bool {
        self.ipv6addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ipv6addr.is_none() {
            self.ipv6addr.set_default();
        }
        self.ipv6addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6addr(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6addr.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 dst_port = 3;


    pub fn get_dst_port(&self) -> u32 {
        self.dst_port.unwrap_or(0)
    }
    pub fn clear_dst_port(&mut self) {
        self.dst_port = ::std::option::Option::None;
    }

    pub fn has_dst_port(&self) -> bool {
        self.dst_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_port(&mut self, v: u32) {
        self.dst_port = ::std::option::Option::Some(v);
    }

    // optional bytes serverRandom = 4;


    pub fn get_serverRandom(&self) -> &[u8] {
        match self.serverRandom.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_serverRandom(&mut self) {
        self.serverRandom.clear();
    }

    pub fn has_serverRandom(&self) -> bool {
        self.serverRandom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverRandom(&mut self, v: ::std::vec::Vec<u8>) {
        self.serverRandom = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverRandom(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serverRandom.is_none() {
            self.serverRandom.set_default();
        }
        self.serverRandom.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverRandom(&mut self) -> ::std::vec::Vec<u8> {
        self.serverRandom.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string error = 5;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .tapdance.ClientConf clientConf = 6;


    pub fn get_clientConf(&self) -> &ClientConf {
        self.clientConf.as_ref().unwrap_or_else(|| <ClientConf as ::protobuf::Message>::default_instance())
    }
    pub fn clear_clientConf(&mut self) {
        self.clientConf.clear();
    }

    pub fn has_clientConf(&self) -> bool {
        self.clientConf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientConf(&mut self, v: ClientConf) {
        self.clientConf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientConf(&mut self) -> &mut ClientConf {
        if self.clientConf.is_none() {
            self.clientConf.set_default();
        }
        self.clientConf.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientConf(&mut self) -> ClientConf {
        self.clientConf.take().unwrap_or_else(|| ClientConf::new())
    }
}

impl ::protobuf::Message for RegistrationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.clientConf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ipv4addr = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ipv6addr)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverRandom)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clientConf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ipv4addr {
            my_size += 5;
        }
        if let Some(ref v) = self.ipv6addr.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.dst_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.serverRandom.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.clientConf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ipv4addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.ipv6addr.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.dst_port {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.serverRandom.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.clientConf.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegistrationResponse {
        RegistrationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ipv4addr",
                |m: &RegistrationResponse| { &m.ipv4addr },
                |m: &mut RegistrationResponse| { &mut m.ipv4addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ipv6addr",
                |m: &RegistrationResponse| { &m.ipv6addr },
                |m: &mut RegistrationResponse| { &mut m.ipv6addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dst_port",
                |m: &RegistrationResponse| { &m.dst_port },
                |m: &mut RegistrationResponse| { &mut m.dst_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverRandom",
                |m: &RegistrationResponse| { &m.serverRandom },
                |m: &mut RegistrationResponse| { &mut m.serverRandom },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &RegistrationResponse| { &m.error },
                |m: &mut RegistrationResponse| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientConf>>(
                "clientConf",
                |m: &RegistrationResponse| { &m.clientConf },
                |m: &mut RegistrationResponse| { &mut m.clientConf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegistrationResponse>(
                "RegistrationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegistrationResponse {
        static instance: ::protobuf::rt::LazyV2<RegistrationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegistrationResponse::new)
    }
}

impl ::protobuf::Clear for RegistrationResponse {
    fn clear(&mut self) {
        self.ipv4addr = ::std::option::Option::None;
        self.ipv6addr.clear();
        self.dst_port = ::std::option::Option::None;
        self.serverRandom.clear();
        self.error.clear();
        self.clientConf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegistrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsResponse {
    // message fields
    success: ::std::option::Option<bool>,
    clientconf_outdated: ::std::option::Option<bool>,
    pub bidirectional_response: ::protobuf::SingularPtrField<RegistrationResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsResponse {
    fn default() -> &'a DnsResponse {
        <DnsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DnsResponse {
    pub fn new() -> DnsResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional bool clientconf_outdated = 2;


    pub fn get_clientconf_outdated(&self) -> bool {
        self.clientconf_outdated.unwrap_or(false)
    }
    pub fn clear_clientconf_outdated(&mut self) {
        self.clientconf_outdated = ::std::option::Option::None;
    }

    pub fn has_clientconf_outdated(&self) -> bool {
        self.clientconf_outdated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientconf_outdated(&mut self, v: bool) {
        self.clientconf_outdated = ::std::option::Option::Some(v);
    }

    // optional .tapdance.RegistrationResponse bidirectional_response = 3;


    pub fn get_bidirectional_response(&self) -> &RegistrationResponse {
        self.bidirectional_response.as_ref().unwrap_or_else(|| <RegistrationResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bidirectional_response(&mut self) {
        self.bidirectional_response.clear();
    }

    pub fn has_bidirectional_response(&self) -> bool {
        self.bidirectional_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bidirectional_response(&mut self, v: RegistrationResponse) {
        self.bidirectional_response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bidirectional_response(&mut self) -> &mut RegistrationResponse {
        if self.bidirectional_response.is_none() {
            self.bidirectional_response.set_default();
        }
        self.bidirectional_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_bidirectional_response(&mut self) -> RegistrationResponse {
        self.bidirectional_response.take().unwrap_or_else(|| RegistrationResponse::new())
    }
}

impl ::protobuf::Message for DnsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.bidirectional_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clientconf_outdated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bidirectional_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        if let Some(v) = self.clientconf_outdated {
            my_size += 2;
        }
        if let Some(ref v) = self.bidirectional_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.clientconf_outdated {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.bidirectional_response.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsResponse {
        DnsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &DnsResponse| { &m.success },
                |m: &mut DnsResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clientconf_outdated",
                |m: &DnsResponse| { &m.clientconf_outdated },
                |m: &mut DnsResponse| { &mut m.clientconf_outdated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegistrationResponse>>(
                "bidirectional_response",
                |m: &DnsResponse| { &m.bidirectional_response },
                |m: &mut DnsResponse| { &mut m.bidirectional_response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsResponse>(
                "DnsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsResponse {
        static instance: ::protobuf::rt::LazyV2<DnsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsResponse::new)
    }
}

impl ::protobuf::Clear for DnsResponse {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.clientconf_outdated = ::std::option::Option::None;
        self.bidirectional_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KeyType {
    AES_GCM_128 = 90,
    AES_GCM_256 = 91,
}

impl ::protobuf::ProtobufEnum for KeyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyType> {
        match value {
            90 => ::std::option::Option::Some(KeyType::AES_GCM_128),
            91 => ::std::option::Option::Some(KeyType::AES_GCM_256),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KeyType] = &[
            KeyType::AES_GCM_128,
            KeyType::AES_GCM_256,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<KeyType>("KeyType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for KeyType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for KeyType {
    fn default() -> Self {
        KeyType::AES_GCM_128
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DnsRegMethod {
    UDP = 0,
    DOT = 1,
    DOH = 2,
}

impl ::protobuf::ProtobufEnum for DnsRegMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DnsRegMethod> {
        match value {
            0 => ::std::option::Option::Some(DnsRegMethod::UDP),
            1 => ::std::option::Option::Some(DnsRegMethod::DOT),
            2 => ::std::option::Option::Some(DnsRegMethod::DOH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DnsRegMethod] = &[
            DnsRegMethod::UDP,
            DnsRegMethod::DOT,
            DnsRegMethod::DOH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DnsRegMethod>("DnsRegMethod", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DnsRegMethod {
}

impl ::std::default::Default for DnsRegMethod {
    fn default() -> Self {
        DnsRegMethod::UDP
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsRegMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum C2S_Transition {
    C2S_NO_CHANGE = 0,
    C2S_SESSION_INIT = 1,
    C2S_SESSION_COVERT_INIT = 11,
    C2S_EXPECT_RECONNECT = 2,
    C2S_SESSION_CLOSE = 3,
    C2S_YIELD_UPLOAD = 4,
    C2S_ACQUIRE_UPLOAD = 5,
    C2S_EXPECT_UPLOADONLY_RECONN = 6,
    C2S_ERROR = 255,
}

impl ::protobuf::ProtobufEnum for C2S_Transition {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<C2S_Transition> {
        match value {
            0 => ::std::option::Option::Some(C2S_Transition::C2S_NO_CHANGE),
            1 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_INIT),
            11 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_RECONNECT),
            3 => ::std::option::Option::Some(C2S_Transition::C2S_SESSION_CLOSE),
            4 => ::std::option::Option::Some(C2S_Transition::C2S_YIELD_UPLOAD),
            5 => ::std::option::Option::Some(C2S_Transition::C2S_ACQUIRE_UPLOAD),
            6 => ::std::option::Option::Some(C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN),
            255 => ::std::option::Option::Some(C2S_Transition::C2S_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [C2S_Transition] = &[
            C2S_Transition::C2S_NO_CHANGE,
            C2S_Transition::C2S_SESSION_INIT,
            C2S_Transition::C2S_SESSION_COVERT_INIT,
            C2S_Transition::C2S_EXPECT_RECONNECT,
            C2S_Transition::C2S_SESSION_CLOSE,
            C2S_Transition::C2S_YIELD_UPLOAD,
            C2S_Transition::C2S_ACQUIRE_UPLOAD,
            C2S_Transition::C2S_EXPECT_UPLOADONLY_RECONN,
            C2S_Transition::C2S_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<C2S_Transition>("C2S_Transition", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for C2S_Transition {
}

impl ::std::default::Default for C2S_Transition {
    fn default() -> Self {
        C2S_Transition::C2S_NO_CHANGE
    }
}

impl ::protobuf::reflect::ProtobufValue for C2S_Transition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum S2C_Transition {
    S2C_NO_CHANGE = 0,
    S2C_SESSION_INIT = 1,
    S2C_SESSION_COVERT_INIT = 11,
    S2C_CONFIRM_RECONNECT = 2,
    S2C_SESSION_CLOSE = 3,
    S2C_ERROR = 255,
}

impl ::protobuf::ProtobufEnum for S2C_Transition {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<S2C_Transition> {
        match value {
            0 => ::std::option::Option::Some(S2C_Transition::S2C_NO_CHANGE),
            1 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_INIT),
            11 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_COVERT_INIT),
            2 => ::std::option::Option::Some(S2C_Transition::S2C_CONFIRM_RECONNECT),
            3 => ::std::option::Option::Some(S2C_Transition::S2C_SESSION_CLOSE),
            255 => ::std::option::Option::Some(S2C_Transition::S2C_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [S2C_Transition] = &[
            S2C_Transition::S2C_NO_CHANGE,
            S2C_Transition::S2C_SESSION_INIT,
            S2C_Transition::S2C_SESSION_COVERT_INIT,
            S2C_Transition::S2C_CONFIRM_RECONNECT,
            S2C_Transition::S2C_SESSION_CLOSE,
            S2C_Transition::S2C_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<S2C_Transition>("S2C_Transition", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for S2C_Transition {
}

impl ::std::default::Default for S2C_Transition {
    fn default() -> Self {
        S2C_Transition::S2C_NO_CHANGE
    }
}

impl ::protobuf::reflect::ProtobufValue for S2C_Transition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrorReasonS2C {
    NO_ERROR = 0,
    COVERT_STREAM = 1,
    CLIENT_REPORTED = 2,
    CLIENT_PROTOCOL = 3,
    STATION_INTERNAL = 4,
    DECOY_OVERLOAD = 5,
    CLIENT_STREAM = 100,
    CLIENT_TIMEOUT = 101,
}

impl ::protobuf::ProtobufEnum for ErrorReasonS2C {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorReasonS2C> {
        match value {
            0 => ::std::option::Option::Some(ErrorReasonS2C::NO_ERROR),
            1 => ::std::option::Option::Some(ErrorReasonS2C::COVERT_STREAM),
            2 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_REPORTED),
            3 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_PROTOCOL),
            4 => ::std::option::Option::Some(ErrorReasonS2C::STATION_INTERNAL),
            5 => ::std::option::Option::Some(ErrorReasonS2C::DECOY_OVERLOAD),
            100 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_STREAM),
            101 => ::std::option::Option::Some(ErrorReasonS2C::CLIENT_TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrorReasonS2C] = &[
            ErrorReasonS2C::NO_ERROR,
            ErrorReasonS2C::COVERT_STREAM,
            ErrorReasonS2C::CLIENT_REPORTED,
            ErrorReasonS2C::CLIENT_PROTOCOL,
            ErrorReasonS2C::STATION_INTERNAL,
            ErrorReasonS2C::DECOY_OVERLOAD,
            ErrorReasonS2C::CLIENT_STREAM,
            ErrorReasonS2C::CLIENT_TIMEOUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ErrorReasonS2C>("ErrorReasonS2C", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ErrorReasonS2C {
}

impl ::std::default::Default for ErrorReasonS2C {
    fn default() -> Self {
        ErrorReasonS2C::NO_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorReasonS2C {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransportType {
    Null = 0,
    Min = 1,
    Obfs4 = 2,
    Webrtc = 99,
}

impl ::protobuf::ProtobufEnum for TransportType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransportType> {
        match value {
            0 => ::std::option::Option::Some(TransportType::Null),
            1 => ::std::option::Option::Some(TransportType::Min),
            2 => ::std::option::Option::Some(TransportType::Obfs4),
            99 => ::std::option::Option::Some(TransportType::Webrtc),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransportType] = &[
            TransportType::Null,
            TransportType::Min,
            TransportType::Obfs4,
            TransportType::Webrtc,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TransportType>("TransportType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TransportType {
}

impl ::std::default::Default for TransportType {
    fn default() -> Self {
        TransportType::Null
    }
}

impl ::protobuf::reflect::ProtobufValue for TransportType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RegistrationSource {
    Unspecified = 0,
    Detector = 1,
    API = 2,
    DetectorPrescan = 3,
    BidirectionalAPI = 4,
    DNS = 5,
    BidirectionalDNS = 6,
}

impl ::protobuf::ProtobufEnum for RegistrationSource {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RegistrationSource> {
        match value {
            0 => ::std::option::Option::Some(RegistrationSource::Unspecified),
            1 => ::std::option::Option::Some(RegistrationSource::Detector),
            2 => ::std::option::Option::Some(RegistrationSource::API),
            3 => ::std::option::Option::Some(RegistrationSource::DetectorPrescan),
            4 => ::std::option::Option::Some(RegistrationSource::BidirectionalAPI),
            5 => ::std::option::Option::Some(RegistrationSource::DNS),
            6 => ::std::option::Option::Some(RegistrationSource::BidirectionalDNS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RegistrationSource] = &[
            RegistrationSource::Unspecified,
            RegistrationSource::Detector,
            RegistrationSource::API,
            RegistrationSource::DetectorPrescan,
            RegistrationSource::BidirectionalAPI,
            RegistrationSource::DNS,
            RegistrationSource::BidirectionalDNS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RegistrationSource>("RegistrationSource", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RegistrationSource {
}

impl ::std::default::Default for RegistrationSource {
    fn default() -> Self {
        RegistrationSource::Unspecified
    }
}

impl ::protobuf::reflect::ProtobufValue for RegistrationSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StationOperations {
    Unknown = 0,
    New = 1,
    Update = 2,
    Clear = 3,
}

impl ::protobuf::ProtobufEnum for StationOperations {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StationOperations> {
        match value {
            0 => ::std::option::Option::Some(StationOperations::Unknown),
            1 => ::std::option::Option::Some(StationOperations::New),
            2 => ::std::option::Option::Some(StationOperations::Update),
            3 => ::std::option::Option::Some(StationOperations::Clear),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StationOperations] = &[
            StationOperations::Unknown,
            StationOperations::New,
            StationOperations::Update,
            StationOperations::Clear,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StationOperations>("StationOperations", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StationOperations {
}

impl ::std::default::Default for StationOperations {
    fn default() -> Self {
        StationOperations::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for StationOperations {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IPProto {
    Unk = 0,
    Tcp = 1,
    Udp = 2,
}

impl ::protobuf::ProtobufEnum for IPProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IPProto> {
        match value {
            0 => ::std::option::Option::Some(IPProto::Unk),
            1 => ::std::option::Option::Some(IPProto::Tcp),
            2 => ::std::option::Option::Some(IPProto::Udp),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IPProto] = &[
            IPProto::Unk,
            IPProto::Tcp,
            IPProto::Udp,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<IPProto>("IPProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for IPProto {
}

impl ::std::default::Default for IPProto {
    fn default() -> Self {
        IPProto::Unk
    }
}

impl ::protobuf::reflect::ProtobufValue for IPProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10signalling.proto\x12\x08tapdance\x1a\x19google/protobuf/any.proto\
    \"A\n\x06PubKey\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12%\n\x04\
    type\x18\x02\x20\x01(\x0e2\x11.tapdance.KeyTypeR\x04type\"\xbe\x01\n\x0c\
    TLSDecoySpec\x12\x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostname\x12\
    \x1a\n\x08ipv4addr\x18\x02\x20\x01(\x07R\x08ipv4addr\x12\x1a\n\x08ipv6ad\
    dr\x18\x06\x20\x01(\x0cR\x08ipv6addr\x12(\n\x06pubkey\x18\x03\x20\x01(\
    \x0b2\x10.tapdance.PubKeyR\x06pubkey\x12\x18\n\x07timeout\x18\x04\x20\
    \x01(\rR\x07timeout\x12\x16\n\x06tcpwin\x18\x05\x20\x01(\rR\x06tcpwin\"\
    \xa2\x02\n\nClientConf\x122\n\ndecoy_list\x18\x01\x20\x01(\x0b2\x13.tapd\
    ance.DecoyListR\tdecoyList\x12\x1e\n\ngeneration\x18\x02\x20\x01(\rR\nge\
    neration\x127\n\x0edefault_pubkey\x18\x03\x20\x01(\x0b2\x10.tapdance.Pub\
    KeyR\rdefaultPubkey\x12N\n\x14phantom_subnets_list\x18\x04\x20\x01(\x0b2\
    \x1c.tapdance.PhantomSubnetsListR\x12phantomSubnetsList\x127\n\x0econjur\
    e_pubkey\x18\x05\x20\x01(\x0b2\x10.tapdance.PubKeyR\rconjurePubkey\"\x97\
    \x02\n\nDnsRegConf\x12<\n\x0edns_reg_method\x18\x01\x20\x02(\x0e2\x16.ta\
    pdance.DnsRegMethodR\x0cdnsRegMethod\x12\x19\n\x08udp_addr\x18\x02\x20\
    \x01(\tR\x07udpAddr\x12\x19\n\x08dot_addr\x18\x03\x20\x01(\tR\x07dotAddr\
    \x12\x17\n\x07doh_url\x18\x04\x20\x01(\tR\x06dohUrl\x12\x16\n\x06domain\
    \x18\x05\x20\x02(\tR\x06domain\x12\x16\n\x06pubkey\x18\x06\x20\x01(\x0cR\
    \x06pubkey\x12+\n\x11utls_distribution\x18\x07\x20\x01(\tR\x10utlsDistri\
    bution\x12\x1f\n\x0bstun_server\x18\x08\x20\x01(\tR\nstunServer\"B\n\tDe\
    coyList\x125\n\ntls_decoys\x18\x01\x20\x03(\x0b2\x16.tapdance.TLSDecoySp\
    ecR\ttlsDecoys\"Y\n\x12PhantomSubnetsList\x12C\n\x10weighted_subnets\x18\
    \x01\x20\x03(\x0b2\x18.tapdance.PhantomSubnetsR\x0fweightedSubnets\"B\n\
    \x0ePhantomSubnets\x12\x16\n\x06weight\x18\x01\x20\x01(\rR\x06weight\x12\
    \x18\n\x07subnets\x18\x02\x20\x03(\tR\x07subnets\"o\n\x12WebRTCICECandid\
    ate\x12\x19\n\x08ip_upper\x18\x01\x20\x02(\x04R\x07ipUpper\x12\x19\n\x08\
    ip_lower\x18\x02\x20\x02(\x04R\x07ipLower\x12#\n\rcomposed_info\x18\x03\
    \x20\x02(\rR\x0ccomposedInfo\"]\n\tWebRTCSDP\x12\x12\n\x04type\x18\x01\
    \x20\x02(\rR\x04type\x12<\n\ncandidates\x18\x02\x20\x03(\x0b2\x1c.tapdan\
    ce.WebRTCICECandidateR\ncandidates\"I\n\x0cWebRTCSignal\x12\x12\n\x04see\
    d\x18\x01\x20\x02(\tR\x04seed\x12%\n\x03sdp\x18\x02\x20\x02(\x0b2\x13.ta\
    pdance.WebRTCSDPR\x03sdp\"\xcb\x02\n\x0fStationToClient\x12)\n\x10protoc\
    ol_version\x18\x01\x20\x01(\rR\x0fprotocolVersion\x12C\n\x10state_transi\
    tion\x18\x02\x20\x01(\x0e2\x18.tapdance.S2C_TransitionR\x0fstateTransiti\
    on\x125\n\x0bconfig_info\x18\x03\x20\x01(\x0b2\x14.tapdance.ClientConfR\
    \nconfigInfo\x127\n\nerr_reason\x18\x04\x20\x01(\x0e2\x18.tapdance.Error\
    ReasonS2CR\terrReason\x12\x1f\n\x0btmp_backoff\x18\x05\x20\x01(\rR\ntmpB\
    ackoff\x12\x1d\n\nstation_id\x18\x06\x20\x01(\tR\tstationId\x12\x18\n\
    \x07padding\x18d\x20\x01(\x0cR\x07padding\"\xaf\x01\n\x11RegistrationFla\
    gs\x12\x1f\n\x0bupload_only\x18\x01\x20\x01(\x08R\nuploadOnly\x12\x1d\n\
    \ndark_decoy\x18\x02\x20\x01(\x08R\tdarkDecoy\x12!\n\x0cproxy_header\x18\
    \x03\x20\x01(\x08R\x0bproxyHeader\x12\x17\n\x07use_TIL\x18\x04\x20\x01(\
    \x08R\x06useTIL\x12\x1e\n\nprescanned\x18\x05\x20\x01(\x08R\nprescanned\
    \"\xf7\x05\n\x0fClientToStation\x12)\n\x10protocol_version\x18\x01\x20\
    \x01(\rR\x0fprotocolVersion\x122\n\x15decoy_list_generation\x18\x02\x20\
    \x01(\rR\x13decoyListGeneration\x12C\n\x10state_transition\x18\x03\x20\
    \x01(\x0e2\x18.tapdance.C2S_TransitionR\x0fstateTransition\x12\x1f\n\x0b\
    upload_sync\x18\x04\x20\x01(\x04R\nuploadSync\x12,\n\x12client_lib_versi\
    on\x18\x05\x20\x01(\rR\x10clientLibVersion\x12#\n\rfailed_decoys\x18\n\
    \x20\x03(\tR\x0cfailedDecoys\x12,\n\x05stats\x18\x0b\x20\x01(\x0b2\x16.t\
    apdance.SessionStatsR\x05stats\x125\n\ttransport\x18\x0c\x20\x01(\x0e2\
    \x17.tapdance.TransportTypeR\ttransport\x12?\n\x10transport_params\x18\r\
    \x20\x01(\x0b2\x14.google.protobuf.AnyR\x0ftransportParams\x12%\n\x0ecov\
    ert_address\x18\x14\x20\x01(\tR\rcovertAddress\x127\n\x18masked_decoy_se\
    rver_name\x18\x15\x20\x01(\tR\x15maskedDecoyServerName\x12\x1d\n\nv6_sup\
    port\x18\x16\x20\x01(\x08R\tv6Support\x12\x1d\n\nv4_support\x18\x17\x20\
    \x01(\x08R\tv4Support\x121\n\x05flags\x18\x18\x20\x01(\x0b2\x1b.tapdance\
    .RegistrationFlagsR\x05flags\x12;\n\rwebrtc_signal\x18\x1f\x20\x01(\x0b2\
    \x16.tapdance.WebRTCSignalR\x0cwebrtcSignal\x12\x18\n\x07padding\x18d\
    \x20\x01(\x0cR\x07padding\"F\n\x16GenericTransportParams\x12,\n\x12rando\
    mize_dst_port\x18\r\x20\x01(\x08R\x10randomizeDstPort\"\xfb\x02\n\nC2SWr\
    apper\x12#\n\rshared_secret\x18\x01\x20\x01(\x0cR\x0csharedSecret\x12L\n\
    \x14registration_payload\x18\x03\x20\x01(\x0b2\x19.tapdance.ClientToStat\
    ionR\x13registrationPayload\x12M\n\x13registration_source\x18\x04\x20\
    \x01(\x0e2\x1c.tapdance.RegistrationSourceR\x12registrationSource\x121\n\
    \x14registration_address\x18\x06\x20\x01(\x0cR\x13registrationAddress\
    \x12#\n\rdecoy_address\x18\x07\x20\x01(\x0cR\x0cdecoyAddress\x12S\n\x15r\
    egistration_response\x18\x08\x20\x01(\x0b2\x1e.tapdance.RegistrationResp\
    onseR\x14registrationResponse\"\xdd\x01\n\x0cSessionStats\x120\n\x14fail\
    ed_decoys_amount\x18\x14\x20\x01(\rR\x12failedDecoysAmount\x121\n\x15tot\
    al_time_to_connect\x18\x1f\x20\x01(\rR\x12totalTimeToConnect\x12$\n\x0er\
    tt_to_station\x18!\x20\x01(\rR\x0crttToStation\x12\x20\n\x0ctls_to_decoy\
    \x18&\x20\x01(\rR\ntlsToDecoy\x12\x20\n\x0ctcp_to_decoy\x18'\x20\x01(\rR\
    \ntcpToDecoy\"\x88\x02\n\x11StationToDetector\x12\x1d\n\nphantom_ip\x18\
    \x01\x20\x01(\tR\tphantomIp\x12\x1b\n\tclient_ip\x18\x02\x20\x01(\tR\x08\
    clientIp\x12\x1d\n\ntimeout_ns\x18\x03\x20\x01(\x04R\ttimeoutNs\x129\n\t\
    operation\x18\x04\x20\x01(\x0e2\x1b.tapdance.StationOperationsR\toperati\
    on\x12\x19\n\x08dst_port\x18\n\x20\x01(\rR\x07dstPort\x12\x19\n\x08src_p\
    ort\x18\x0b\x20\x01(\rR\x07srcPort\x12'\n\x05proto\x18\x0c\x20\x01(\x0e2\
    \x11.tapdance.IPProtoR\x05proto\"\xd9\x01\n\x14RegistrationResponse\x12\
    \x1a\n\x08ipv4addr\x18\x01\x20\x01(\x07R\x08ipv4addr\x12\x1a\n\x08ipv6ad\
    dr\x18\x02\x20\x01(\x0cR\x08ipv6addr\x12\x19\n\x08dst_port\x18\x03\x20\
    \x01(\rR\x07dstPort\x12\"\n\x0cserverRandom\x18\x04\x20\x01(\x0cR\x0cser\
    verRandom\x12\x14\n\x05error\x18\x05\x20\x01(\tR\x05error\x124\n\nclient\
    Conf\x18\x06\x20\x01(\x0b2\x14.tapdance.ClientConfR\nclientConf\"\xaf\
    \x01\n\x0bDnsResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07succ\
    ess\x12/\n\x13clientconf_outdated\x18\x02\x20\x01(\x08R\x12clientconfOut\
    dated\x12U\n\x16bidirectional_response\x18\x03\x20\x01(\x0b2\x1e.tapdanc\
    e.RegistrationResponseR\x15bidirectionalResponse*+\n\x07KeyType\x12\x0f\
    \n\x0bAES_GCM_128\x10Z\x12\x0f\n\x0bAES_GCM_256\x10[*)\n\x0cDnsRegMethod\
    \x12\x07\n\x03UDP\x10\0\x12\x07\n\x03DOT\x10\x01\x12\x07\n\x03DOH\x10\
    \x02*\xe7\x01\n\x0eC2S_Transition\x12\x11\n\rC2S_NO_CHANGE\x10\0\x12\x14\
    \n\x10C2S_SESSION_INIT\x10\x01\x12\x1b\n\x17C2S_SESSION_COVERT_INIT\x10\
    \x0b\x12\x18\n\x14C2S_EXPECT_RECONNECT\x10\x02\x12\x15\n\x11C2S_SESSION_\
    CLOSE\x10\x03\x12\x14\n\x10C2S_YIELD_UPLOAD\x10\x04\x12\x16\n\x12C2S_ACQ\
    UIRE_UPLOAD\x10\x05\x12\x20\n\x1cC2S_EXPECT_UPLOADONLY_RECONN\x10\x06\
    \x12\x0e\n\tC2S_ERROR\x10\xff\x01*\x98\x01\n\x0eS2C_Transition\x12\x11\n\
    \rS2C_NO_CHANGE\x10\0\x12\x14\n\x10S2C_SESSION_INIT\x10\x01\x12\x1b\n\
    \x17S2C_SESSION_COVERT_INIT\x10\x0b\x12\x19\n\x15S2C_CONFIRM_RECONNECT\
    \x10\x02\x12\x15\n\x11S2C_SESSION_CLOSE\x10\x03\x12\x0e\n\tS2C_ERROR\x10\
    \xff\x01*\xac\x01\n\x0eErrorReasonS2C\x12\x0c\n\x08NO_ERROR\x10\0\x12\
    \x11\n\rCOVERT_STREAM\x10\x01\x12\x13\n\x0fCLIENT_REPORTED\x10\x02\x12\
    \x13\n\x0fCLIENT_PROTOCOL\x10\x03\x12\x14\n\x10STATION_INTERNAL\x10\x04\
    \x12\x12\n\x0eDECOY_OVERLOAD\x10\x05\x12\x11\n\rCLIENT_STREAM\x10d\x12\
    \x12\n\x0eCLIENT_TIMEOUT\x10e*9\n\rTransportType\x12\x08\n\x04Null\x10\0\
    \x12\x07\n\x03Min\x10\x01\x12\t\n\x05Obfs4\x10\x02\x12\n\n\x06Webrtc\x10\
    c*\x86\x01\n\x12RegistrationSource\x12\x0f\n\x0bUnspecified\x10\0\x12\
    \x0c\n\x08Detector\x10\x01\x12\x07\n\x03API\x10\x02\x12\x13\n\x0fDetecto\
    rPrescan\x10\x03\x12\x14\n\x10BidirectionalAPI\x10\x04\x12\x07\n\x03DNS\
    \x10\x05\x12\x14\n\x10BidirectionalDNS\x10\x06*@\n\x11StationOperations\
    \x12\x0b\n\x07Unknown\x10\0\x12\x07\n\x03New\x10\x01\x12\n\n\x06Update\
    \x10\x02\x12\t\n\x05Clear\x10\x03*$\n\x07IPProto\x12\x07\n\x03Unk\x10\0\
    \x12\x07\n\x03Tcp\x10\x01\x12\x07\n\x03Udp\x10\x02J\x8fy\n\x07\x12\x05\0\
    \0\xf3\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\xb0\x01\n\x01\x02\x12\
    \x03\x06\0\x112\xa5\x01\x20TODO:\x20We're\x20using\x20proto2\x20because\
    \x20it's\x20the\x20default\x20on\x20Ubuntu\x2016.04.\n\x20At\x20some\x20\
    point\x20we\x20will\x20want\x20to\x20migrate\x20to\x20proto3,\x20but\x20\
    we\x20are\x20not\n\x20using\x20any\x20proto3\x20features\x20yet.\n\n\t\n\
    \x02\x03\0\x12\x03\x08\0#\n\n\n\x02\x05\0\x12\x04\n\0\r\x01\n\n\n\x03\
    \x05\0\x01\x12\x03\n\x05\x0c\n\x0b\n\x04\x05\0\x02\0\x12\x03\x0b\x04\x15\
    \n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x0b\x04\x0f\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03\x0b\x12\x14\n\x20\n\x04\x05\0\x02\x01\x12\x03\x0c\x04\x15\"\
    \x13\x20not\x20supported\x20atm\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\
    \x0c\x04\x0f\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x0c\x12\x14\n\n\n\x02\
    \x04\0\x12\x04\x0f\0\x14\x01\n\n\n\x03\x04\0\x01\x12\x03\x0f\x08\x0e\n4\
    \n\x04\x04\0\x02\0\x12\x03\x11\x04\x1b\x1a'\x20A\x20public\x20key,\x20as\
    \x20used\x20by\x20the\x20station.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\
    \x11\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x11\r\x12\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\x11\x13\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \x11\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x13\x04\x1e\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x06\x12\
    \x03\x13\r\x14\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x13\x15\x19\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\x13\x1c\x1d\n\n\n\x02\x04\x01\x12\x04\x16\
    \0<\x01\n\n\n\x03\x04\x01\x01\x12\x03\x16\x08\x14\n\xa1\x01\n\x04\x04\
    \x01\x02\0\x12\x03\x1b\x04!\x1a\x93\x01\x20The\x20hostname/SNI\x20to\x20\
    use\x20for\x20this\x20host\n\n\x20The\x20hostname\x20is\x20the\x20only\
    \x20required\x20field,\x20although\x20other\n\x20fields\x20are\x20expect\
    ed\x20to\x20be\x20present\x20in\x20most\x20cases.\n\n\x0c\n\x05\x04\x01\
    \x02\0\x04\x12\x03\x1b\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1b\
    \r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1b\x14\x1c\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03\x1b\x1f\x20\n\xf7\x01\n\x04\x04\x01\x02\x01\x12\
    \x03\"\x04\"\x1a\xe9\x01\x20The\x2032-bit\x20ipv4\x20address,\x20in\x20n\
    etwork\x20byte\x20order\n\n\x20If\x20the\x20IPv4\x20address\x20is\x20abs\
    ent,\x20then\x20it\x20may\x20be\x20resolved\x20via\n\x20DNS\x20by\x20the\
    \x20client,\x20or\x20the\x20client\x20may\x20discard\x20this\x20decoy\
    \x20spec\n\x20if\x20local\x20DNS\x20is\x20untrusted,\x20or\x20the\x20ser\
    vice\x20may\x20be\x20multihomed.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03\"\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\"\r\x14\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03\"\x15\x1d\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\"\x20!\n>\n\x04\x04\x01\x02\x02\x12\x03%\x04\x20\x1a1\x20Th\
    e\x20128-bit\x20ipv6\x20address,\x20in\x20network\x20byte\x20order\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x04\x12\x03%\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \x02\x05\x12\x03%\r\x12\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03%\x13\x1b\
    \n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03%\x1e\x1f\n\x91\x01\n\x04\x04\
    \x01\x02\x03\x12\x03+\x04\x1f\x1a\x83\x01\x20The\x20Tapdance\x20station\
    \x20public\x20key\x20to\x20use\x20when\x20contacting\x20this\n\x20decoy\
    \n\n\x20If\x20omitted,\x20the\x20default\x20station\x20public\x20key\x20\
    (if\x20any)\x20is\x20used.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03+\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03+\r\x13\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03+\x14\x1a\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03+\x1d\x1e\n\xee\x01\n\x04\x04\x01\x02\x04\x12\x032\x04\x20\x1a\xe0\
    \x01\x20The\x20maximum\x20duration,\x20in\x20milliseconds,\x20to\x20main\
    tain\x20an\x20open\n\x20connection\x20to\x20this\x20decoy\x20(because\
    \x20the\x20decoy\x20may\x20close\x20the\n\x20connection\x20itself\x20aft\
    er\x20this\x20length\x20of\x20time)\n\n\x20If\x20omitted,\x20a\x20defaul\
    t\x20of\x2030,000\x20milliseconds\x20is\x20assumed.\n\n\x0c\n\x05\x04\
    \x01\x02\x04\x04\x12\x032\x04\x0c\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\
    \x032\r\x13\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x032\x14\x1b\n\x0c\n\x05\
    \x04\x01\x02\x04\x03\x12\x032\x1e\x1f\n\xb0\x02\n\x04\x04\x01\x02\x05\
    \x12\x03;\x04\x1f\x1a\xa2\x02\x20The\x20maximum\x20TCP\x20window\x20size\
    \x20to\x20attempt\x20to\x20use\x20for\x20this\x20decoy.\n\n\x20If\x20omi\
    tted,\x20a\x20default\x20of\x2015360\x20is\x20assumed.\n\n\x20TODO:\x20t\
    he\x20default\x20is\x20based\x20on\x20the\x20current\x20heuristic\x20of\
    \x20only\n\x20using\x20decoys\x20that\x20permit\x20windows\x20of\x2015KB\
    \x20or\x20larger.\x20\x20If\x20this\n\x20heuristic\x20changes,\x20then\
    \x20this\x20default\x20doesn't\x20make\x20sense.\n\n\x0c\n\x05\x04\x01\
    \x02\x05\x04\x12\x03;\x04\x0c\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03;\r\
    \x13\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03;\x14\x1a\n\x0c\n\x05\x04\
    \x01\x02\x05\x03\x12\x03;\x1d\x1e\n\x83\x08\n\x02\x04\x02\x12\x04S\0Y\
    \x012\xf6\x07\x20In\x20version\x201,\x20the\x20request\x20is\x20very\x20\
    simple:\x20when\n\x20the\x20client\x20sends\x20a\x20MSG_PROTO\x20to\x20t\
    he\x20station,\x20if\x20the\n\x20generation\x20number\x20is\x20present,\
    \x20then\x20this\x20request\x20includes\n\x20(in\x20addition\x20to\x20wh\
    atever\x20other\x20operations\x20are\x20part\x20of\x20the\n\x20request)\
    \x20a\x20request\x20for\x20the\x20station\x20to\x20send\x20a\x20copy\x20\
    of\n\x20the\x20current\x20decoy\x20set\x20that\x20has\x20a\x20generation\
    \x20number\x20greater\n\x20than\x20the\x20generation\x20number\x20in\x20\
    its\x20request.\n\n\x20If\x20the\x20response\x20contains\x20a\x20DecoyLi\
    stUpdate\x20with\x20a\x20generation\x20number\x20equal\n\x20to\x20that\
    \x20which\x20the\x20client\x20sent,\x20then\x20the\x20client\x20is\x20\"\
    caught\x20up\"\x20with\n\x20the\x20station\x20and\x20the\x20response\x20\
    contains\x20no\x20new\x20information\n\x20(and\x20all\x20other\x20fields\
    \x20may\x20be\x20omitted\x20or\x20empty).\x20\x20Otherwise,\n\x20the\x20\
    station\x20will\x20send\x20the\x20latest\x20configuration\x20information\
    ,\n\x20along\x20with\x20its\x20generation\x20number.\n\n\x20The\x20stati\
    on\x20can\x20also\x20send\x20ClientConf\x20messages\n\x20(as\x20part\x20\
    of\x20Station2Client\x20messages)\x20whenever\x20it\x20wants.\n\x20The\
    \x20client\x20is\x20expected\x20to\x20react\x20as\x20if\x20it\x20had\x20\
    requested\n\x20such\x20messages\x20--\x20possibly\x20by\x20ignoring\x20t\
    hem,\x20if\x20the\x20client\n\x20is\x20already\x20up-to-date\x20accordin\
    g\x20to\x20the\x20generation\x20number.\n\n\n\n\x03\x04\x02\x01\x12\x03S\
    \x08\x12\n\x0b\n\x04\x04\x02\x02\0\x12\x03T\x04&\n\x0c\n\x05\x04\x02\x02\
    \0\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03T\r\x16\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03T\x17!\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03T$%\n\x0b\n\x04\x04\x02\x02\x01\x12\x03U\x04#\n\x0c\n\x05\x04\
    \x02\x02\x01\x04\x12\x03U\x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\
    \x03U\r\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03U\x14\x1e\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03U!\"\n\x0b\n\x04\x04\x02\x02\x02\x12\x03V\
    \x04'\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03V\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x02\x06\x12\x03V\r\x13\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03V\
    \x14\"\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03V%&\n\x0b\n\x04\x04\x02\
    \x02\x03\x12\x03W\x049\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03W\x04\x0c\
    \n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03W\r\x1f\n\x0c\n\x05\x04\x02\x02\
    \x03\x01\x12\x03W\x204\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03W78\n\x0b\
    \n\x04\x04\x02\x02\x04\x12\x03X\x04'\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\
    \x03X\x04\x0c\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03X\r\x13\n\x0c\n\x05\
    \x04\x02\x02\x04\x01\x12\x03X\x14\"\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\
    \x03X%&\n-\n\x02\x04\x03\x12\x04\\\0e\x01\x1a!\x20Configuration\x20for\
    \x20DNS\x20registrar\n\n\n\n\x03\x04\x03\x01\x12\x03\\\x08\x12\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x03]\x04-\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03]\
    \x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03]\r\x19\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03]\x1a(\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03]+,\n\
    \x0b\n\x04\x04\x03\x02\x01\x12\x03^\x04!\n\x0c\n\x05\x04\x03\x02\x01\x04\
    \x12\x03^\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03^\r\x13\n\x0c\n\
    \x05\x04\x03\x02\x01\x01\x12\x03^\x14\x1c\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03^\x1f\x20\n\x0b\n\x04\x04\x03\x02\x02\x12\x03_\x04!\n\x0c\n\
    \x05\x04\x03\x02\x02\x04\x12\x03_\x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\
    \x05\x12\x03_\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03_\x14\x1c\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03_\x1f\x20\n\x0b\n\x04\x04\x03\x02\
    \x03\x12\x03`\x04\x20\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03`\x04\x0c\n\
    \x0c\n\x05\x04\x03\x02\x03\x05\x12\x03`\r\x13\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03`\x14\x1b\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03`\x1e\
    \x1f\n\x0b\n\x04\x04\x03\x02\x04\x12\x03a\x04\x1f\n\x0c\n\x05\x04\x03\
    \x02\x04\x04\x12\x03a\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03a\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03a\x14\x1a\n\x0c\n\x05\x04\
    \x03\x02\x04\x03\x12\x03a\x1d\x1e\n\x0b\n\x04\x04\x03\x02\x05\x12\x03b\
    \x04\x1e\n\x0c\n\x05\x04\x03\x02\x05\x04\x12\x03b\x04\x0c\n\x0c\n\x05\
    \x04\x03\x02\x05\x05\x12\x03b\r\x12\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\
    \x03b\x13\x19\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03b\x1c\x1d\n\x0b\n\
    \x04\x04\x03\x02\x06\x12\x03c\x04*\n\x0c\n\x05\x04\x03\x02\x06\x04\x12\
    \x03c\x04\x0c\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x03c\r\x13\n\x0c\n\x05\
    \x04\x03\x02\x06\x01\x12\x03c\x14%\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\
    \x03c()\n\x0b\n\x04\x04\x03\x02\x07\x12\x03d\x04$\n\x0c\n\x05\x04\x03\
    \x02\x07\x04\x12\x03d\x04\x0c\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03d\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03d\x14\x1f\n\x0c\n\x05\x04\
    \x03\x02\x07\x03\x12\x03d\"#\n\n\n\x02\x05\x01\x12\x04g\0k\x01\n\n\n\x03\
    \x05\x01\x01\x12\x03g\x05\x11\n\x0b\n\x04\x05\x01\x02\0\x12\x03h\x04\x0c\
    \n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03h\x04\x07\n\x0c\n\x05\x05\x01\x02\
    \0\x02\x12\x03h\n\x0b\n\x0b\n\x04\x05\x01\x02\x01\x12\x03i\x04\x0c\n\x0c\
    \n\x05\x05\x01\x02\x01\x01\x12\x03i\x04\x07\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03i\n\x0b\n\x0b\n\x04\x05\x01\x02\x02\x12\x03j\x04\x0c\n\x0c\n\
    \x05\x05\x01\x02\x02\x01\x12\x03j\x04\x07\n\x0c\n\x05\x05\x01\x02\x02\
    \x02\x12\x03j\n\x0b\n\n\n\x02\x04\x04\x12\x04m\0o\x01\n\n\n\x03\x04\x04\
    \x01\x12\x03m\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03n\x04)\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x03n\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\
    \x12\x03n\r\x19\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03n\x1a$\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03n'(\n\n\n\x02\x04\x05\x12\x04q\0s\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03q\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03r\x04\
    1\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03r\x04\x0c\n\x0c\n\x05\x04\x05\x02\
    \0\x06\x12\x03r\r\x1b\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03r\x1c,\n\x0c\
    \n\x05\x04\x05\x02\0\x03\x12\x03r/0\n\n\n\x02\x04\x06\x12\x04u\0x\x01\n\
    \n\n\x03\x04\x06\x01\x12\x03u\x08\x16\n\x0b\n\x04\x04\x06\x02\0\x12\x03v\
    \x04\x1f\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03v\x04\x0c\n\x0c\n\x05\x04\
    \x06\x02\0\x05\x12\x03v\r\x13\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03v\x14\
    \x1a\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03v\x1d\x1e\n\x0b\n\x04\x04\x06\
    \x02\x01\x12\x03w\x04\x20\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03w\x04\
    \x0c\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03w\r\x13\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03w\x14\x1b\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03w\
    \x1e\x1f\n.\n\x02\x05\x02\x12\x05{\0\x85\x01\x01\x1a!\x20State\x20transi\
    tions\x20of\x20the\x20client\n\n\n\n\x03\x05\x02\x01\x12\x03{\x05\x13\n\
    \x0b\n\x04\x05\x02\x02\0\x12\x03|\x04\x16\n\x0c\n\x05\x05\x02\x02\0\x01\
    \x12\x03|\x04\x11\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03|\x14\x15\n\"\n\
    \x04\x05\x02\x02\x01\x12\x03}\x04\x19\"\x15\x20connect\x20me\x20to\x20sq\
    uid\n\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03}\x04\x14\n\x0c\n\x05\x05\
    \x02\x02\x01\x02\x12\x03}\x17\x18\n,\n\x04\x05\x02\x02\x02\x12\x03~\x04!\
    \"\x1f\x20connect\x20me\x20to\x20provided\x20covert\n\n\x0c\n\x05\x05\
    \x02\x02\x02\x01\x12\x03~\x04\x1b\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\
    \x03~\x1e\x20\n\x0b\n\x04\x05\x02\x02\x03\x12\x03\x7f\x04\x1d\n\x0c\n\
    \x05\x05\x02\x02\x03\x01\x12\x03\x7f\x04\x18\n\x0c\n\x05\x05\x02\x02\x03\
    \x02\x12\x03\x7f\x1b\x1c\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\x80\x01\x04\
    \x1a\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\x80\x01\x04\x15\n\r\n\x05\x05\
    \x02\x02\x04\x02\x12\x04\x80\x01\x18\x19\n\x0c\n\x04\x05\x02\x02\x05\x12\
    \x04\x81\x01\x04\x19\n\r\n\x05\x05\x02\x02\x05\x01\x12\x04\x81\x01\x04\
    \x14\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\x81\x01\x17\x18\n\x0c\n\x04\
    \x05\x02\x02\x06\x12\x04\x82\x01\x04\x1b\n\r\n\x05\x05\x02\x02\x06\x01\
    \x12\x04\x82\x01\x04\x16\n\r\n\x05\x05\x02\x02\x06\x02\x12\x04\x82\x01\
    \x19\x1a\n\x0c\n\x04\x05\x02\x02\x07\x12\x04\x83\x01\x04%\n\r\n\x05\x05\
    \x02\x02\x07\x01\x12\x04\x83\x01\x04\x20\n\r\n\x05\x05\x02\x02\x07\x02\
    \x12\x04\x83\x01#$\n\x0c\n\x04\x05\x02\x02\x08\x12\x04\x84\x01\x04\x14\n\
    \r\n\x05\x05\x02\x02\x08\x01\x12\x04\x84\x01\x04\r\n\r\n\x05\x05\x02\x02\
    \x08\x02\x12\x04\x84\x01\x10\x13\n/\n\x02\x05\x03\x12\x06\x88\x01\0\x90\
    \x01\x01\x1a!\x20State\x20transitions\x20of\x20the\x20server\n\n\x0b\n\
    \x03\x05\x03\x01\x12\x04\x88\x01\x05\x13\n\x0c\n\x04\x05\x03\x02\0\x12\
    \x04\x89\x01\x04\x16\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\x89\x01\x04\x11\
    \n\r\n\x05\x05\x03\x02\0\x02\x12\x04\x89\x01\x14\x15\n\"\n\x04\x05\x03\
    \x02\x01\x12\x04\x8a\x01\x04\x19\"\x14\x20connected\x20to\x20squid\n\n\r\
    \n\x05\x05\x03\x02\x01\x01\x12\x04\x8a\x01\x04\x14\n\r\n\x05\x05\x03\x02\
    \x01\x02\x12\x04\x8a\x01\x17\x18\n(\n\x04\x05\x03\x02\x02\x12\x04\x8b\
    \x01\x04!\"\x1a\x20connected\x20to\x20covert\x20host\n\n\r\n\x05\x05\x03\
    \x02\x02\x01\x12\x04\x8b\x01\x04\x1b\n\r\n\x05\x05\x03\x02\x02\x02\x12\
    \x04\x8b\x01\x1e\x20\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\x8c\x01\x04\x1e\
    \n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\x8c\x01\x04\x19\n\r\n\x05\x05\x03\
    \x02\x03\x02\x12\x04\x8c\x01\x1c\x1d\n\x0c\n\x04\x05\x03\x02\x04\x12\x04\
    \x8d\x01\x04\x1a\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\x8d\x01\x04\x15\n\
    \r\n\x05\x05\x03\x02\x04\x02\x12\x04\x8d\x01\x18\x19\nS\n\x04\x05\x03\
    \x02\x05\x12\x04\x8f\x01\x04\x14\x1aE\x20TODO\x20should\x20probably\x20a\
    lso\x20allow\x20EXPECT_RECONNECT\x20here,\x20for\x20DittoTap\n\n\r\n\x05\
    \x05\x03\x02\x05\x01\x12\x04\x8f\x01\x04\r\n\r\n\x05\x05\x03\x02\x05\x02\
    \x12\x04\x8f\x01\x10\x13\n8\n\x02\x05\x04\x12\x06\x93\x01\0\x9d\x01\x01\
    \x1a*\x20Should\x20accompany\x20all\x20S2C_ERROR\x20messages.\n\n\x0b\n\
    \x03\x05\x04\x01\x12\x04\x93\x01\x05\x13\n\x0c\n\x04\x05\x04\x02\0\x12\
    \x04\x94\x01\x04\x11\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\x94\x01\x04\x0c\
    \n\r\n\x05\x05\x04\x02\0\x02\x12\x04\x94\x01\x0f\x10\n*\n\x04\x05\x04\
    \x02\x01\x12\x04\x95\x01\x04\x16\"\x1c\x20Squid\x20TCP\x20connection\x20\
    broke\n\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\x95\x01\x04\x11\n\r\n\x05\
    \x05\x04\x02\x01\x02\x12\x04\x95\x01\x14\x15\n7\n\x04\x05\x04\x02\x02\
    \x12\x04\x96\x01\x04\x18\")\x20You\x20told\x20me\x20something\x20was\x20\
    wrong,\x20client\n\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\x96\x01\x04\x13\
    \n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\x96\x01\x16\x17\n@\n\x04\x05\x04\
    \x02\x03\x12\x04\x97\x01\x04\x18\"2\x20You\x20messed\x20up,\x20client\
    \x20(e.g.\x20sent\x20a\x20bad\x20protobuf)\n\n\r\n\x05\x05\x04\x02\x03\
    \x01\x12\x04\x97\x01\x04\x13\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\x97\
    \x01\x16\x17\n\x17\n\x04\x05\x04\x02\x04\x12\x04\x98\x01\x04\x19\"\t\x20\
    I\x20broke\n\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\x98\x01\x04\x14\n\r\n\
    \x05\x05\x04\x02\x04\x02\x12\x04\x98\x01\x17\x18\nE\n\x04\x05\x04\x02\
    \x05\x12\x04\x99\x01\x04\x17\"7\x20Everything's\x20fine,\x20but\x20don't\
    \x20use\x20this\x20decoy\x20right\x20now\n\n\r\n\x05\x05\x04\x02\x05\x01\
    \x12\x04\x99\x01\x04\x12\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\x99\x01\
    \x15\x16\nD\n\x04\x05\x04\x02\x06\x12\x04\x9b\x01\x04\x18\"6\x20My\x20st\
    ream\x20to\x20you\x20broke.\x20(This\x20is\x20impossible\x20to\x20send)\
    \n\n\r\n\x05\x05\x04\x02\x06\x01\x12\x04\x9b\x01\x04\x11\n\r\n\x05\x05\
    \x04\x02\x06\x02\x12\x04\x9b\x01\x14\x17\nA\n\x04\x05\x04\x02\x07\x12\
    \x04\x9c\x01\x04\x19\"3\x20You\x20never\x20came\x20back.\x20(This\x20is\
    \x20impossible\x20to\x20send)\n\n\r\n\x05\x05\x04\x02\x07\x01\x12\x04\
    \x9c\x01\x04\x12\n\r\n\x05\x05\x04\x02\x07\x02\x12\x04\x9c\x01\x15\x18\n\
    \x0c\n\x02\x05\x05\x12\x06\x9f\x01\0\xa4\x01\x01\n\x0b\n\x03\x05\x05\x01\
    \x12\x04\x9f\x01\x05\x12\n\x0c\n\x04\x05\x05\x02\0\x12\x04\xa0\x01\x04\r\
    \n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xa0\x01\x04\x08\n\r\n\x05\x05\x05\
    \x02\0\x02\x12\x04\xa0\x01\x0b\x0c\n`\n\x04\x05\x05\x02\x01\x12\x04\xa1\
    \x01\x04\x0c\"R\x20Send\x20a\x2032-byte\x20HMAC\x20id\x20to\x20let\x20th\
    e\x20station\x20distinguish\x20registrations\x20to\x20same\x20host\n\n\r\
    \n\x05\x05\x05\x02\x01\x01\x12\x04\xa1\x01\x04\x07\n\r\n\x05\x05\x05\x02\
    \x01\x02\x12\x04\xa1\x01\n\x0b\n$\n\x04\x05\x05\x02\x02\x12\x04\xa2\x01\
    \x04\x0e\"\x16\x20Not\x20implemented\x20yet?\n\n\r\n\x05\x05\x05\x02\x02\
    \x01\x12\x04\xa2\x01\x04\t\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xa2\x01\
    \x0c\r\n1\n\x04\x05\x05\x02\x03\x12\x04\xa3\x01\x04\x10\"#\x20UDP\x20tra\
    nsport:\x20WebRTC\x20DataChannel\n\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\
    \xa3\x01\x04\n\n\r\n\x05\x05\x05\x02\x03\x02\x12\x04\xa3\x01\r\x0f\n:\n\
    \x02\x04\x07\x12\x06\xa7\x01\0\xad\x01\x01\x1a,\x20Deflated\x20ICE\x20Ca\
    ndidate\x20by\x20seed2sdp\x20package\n\n\x0b\n\x03\x04\x07\x01\x12\x04\
    \xa7\x01\x08\x1a\n5\n\x04\x04\x07\x02\0\x12\x04\xa9\x01\x04!\x1a'\x20IP\
    \x20is\x20represented\x20in\x20its\x2016-byte\x20form\n\n\r\n\x05\x04\
    \x07\x02\0\x04\x12\x04\xa9\x01\x04\x0c\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\xa9\x01\r\x13\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xa9\x01\x14\x1c\n\
    \r\n\x05\x04\x07\x02\0\x03\x12\x04\xa9\x01\x1f\x20\n\x0c\n\x04\x04\x07\
    \x02\x01\x12\x04\xaa\x01\x04!\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\xaa\
    \x01\x04\x0c\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xaa\x01\r\x13\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\xaa\x01\x14\x1c\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xaa\x01\x1f\x20\n\x9b\x01\n\x04\x04\x07\x02\x02\x12\x04\
    \xac\x01\x04&\x1a\x8c\x01\x20Composed\x20info\x20includes\x20port,\x20tc\
    ptype\x20(unset\x20if\x20not\x20tcp),\x20candidate\x20type\x20(host,\x20\
    srflx,\x20prflx),\x20protocol\x20(TCP/UDP),\x20and\x20component\x20(RTP/\
    RTCP)\n\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xac\x01\x04\x0c\n\r\n\x05\
    \x04\x07\x02\x02\x05\x12\x04\xac\x01\r\x13\n\r\n\x05\x04\x07\x02\x02\x01\
    \x12\x04\xac\x01\x14!\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xac\x01$%\n;\
    \n\x02\x04\x08\x12\x06\xb0\x01\0\xb3\x01\x01\x1a-\x20Deflated\x20SDP\x20\
    for\x20WebRTC\x20by\x20seed2sdp\x20package\n\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xb0\x01\x08\x11\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xb1\x01\x04\x1d\n\
    \r\n\x05\x04\x08\x02\0\x04\x12\x04\xb1\x01\x04\x0c\n\r\n\x05\x04\x08\x02\
    \0\x05\x12\x04\xb1\x01\r\x13\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xb1\x01\
    \x14\x18\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xb1\x01\x1b\x1c\n2\n\x04\
    \x04\x08\x02\x01\x12\x04\xb2\x01\x04/\"$\x20there\x20could\x20be\x20mult\
    iple\x20candidates\n\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xb2\x01\x04\
    \x0c\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xb2\x01\r\x1f\n\r\n\x05\x04\
    \x08\x02\x01\x01\x12\x04\xb2\x01\x20*\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\xb2\x01-.\n?\n\x02\x04\t\x12\x06\xb6\x01\0\xb9\x01\x01\x1a1\x20WebR\
    TCSignal\x20includes\x20a\x20deflated\x20SDP\x20and\x20a\x20seed\n\n\x0b\
    \n\x03\x04\t\x01\x12\x04\xb6\x01\x08\x14\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \xb7\x01\x04\x1d\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xb7\x01\x04\x0c\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\xb7\x01\r\x13\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xb7\x01\x14\x18\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xb7\x01\x1b\x1c\n\
    \x0c\n\x04\x04\t\x02\x01\x12\x04\xb8\x01\x04\x1f\n\r\n\x05\x04\t\x02\x01\
    \x04\x12\x04\xb8\x01\x04\x0c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xb8\x01\
    \r\x16\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xb8\x01\x17\x1a\n\r\n\x05\x04\
    \t\x02\x01\x03\x12\x04\xb8\x01\x1d\x1e\n\x0c\n\x02\x04\n\x12\x06\xbb\x01\
    \0\xd2\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xbb\x01\x08\x17\nO\n\x04\
    \x04\n\x02\0\x12\x04\xbd\x01\x04)\x1aA\x20Should\x20accompany\x20(at\x20\
    least)\x20SESSION_INIT\x20and\x20CONFIRM_RECONNECT.\n\n\r\n\x05\x04\n\
    \x02\0\x04\x12\x04\xbd\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xbd\
    \x01\r\x13\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xbd\x01\x14$\n\r\n\x05\x04\
    \n\x02\0\x03\x12\x04\xbd\x01'(\nv\n\x04\x04\n\x02\x01\x12\x04\xc1\x01\
    \x041\x1ah\x20There\x20might\x20be\x20a\x20state\x20transition.\x20May\
    \x20be\x20absent;\x20absence\x20should\x20be\n\x20treated\x20identically\
    \x20to\x20NO_CHANGE.\n\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xc1\x01\x04\
    \x0c\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xc1\x01\r\x1b\n\r\n\x05\x04\n\
    \x02\x01\x01\x12\x04\xc1\x01\x1c,\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\
    \xc1\x01/0\nc\n\x04\x04\n\x02\x02\x12\x04\xc5\x01\x04(\x1aU\x20The\x20st\
    ation\x20can\x20send\x20client\x20config\x20info\x20piggybacked\n\x20on\
    \x20any\x20message,\x20as\x20it\x20sees\x20fit\n\n\r\n\x05\x04\n\x02\x02\
    \x04\x12\x04\xc5\x01\x04\x0c\n\r\n\x05\x04\n\x02\x02\x06\x12\x04\xc5\x01\
    \r\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xc5\x01\x18#\n\r\n\x05\x04\n\
    \x02\x02\x03\x12\x04\xc5\x01&'\nP\n\x04\x04\n\x02\x03\x12\x04\xc8\x01\
    \x04+\x1aB\x20If\x20state_transition\x20==\x20S2C_ERROR,\x20this\x20fiel\
    d\x20is\x20the\x20explanation.\n\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\xc8\
    \x01\x04\x0c\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\xc8\x01\r\x1b\n\r\n\x05\
    \x04\n\x02\x03\x01\x12\x04\xc8\x01\x1c&\n\r\n\x05\x04\n\x02\x03\x03\x12\
    \x04\xc8\x01)*\nQ\n\x04\x04\n\x02\x04\x12\x04\xcb\x01\x04$\x1aC\x20Signa\
    ls\x20client\x20to\x20stop\x20connecting\x20for\x20following\x20amount\
    \x20of\x20seconds\n\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\xcb\x01\x04\x0c\
    \n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xcb\x01\r\x13\n\r\n\x05\x04\n\x02\
    \x04\x01\x12\x04\xcb\x01\x14\x1f\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xcb\
    \x01\"#\nK\n\x04\x04\n\x02\x05\x12\x04\xce\x01\x04#\x1a=\x20Sent\x20in\
    \x20SESSION_INIT,\x20identifies\x20the\x20station\x20that\x20picked\x20u\
    p\n\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xce\x01\x04\x0c\n\r\n\x05\x04\n\
    \x02\x05\x05\x12\x04\xce\x01\r\x13\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\
    \xce\x01\x14\x1e\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xce\x01!\"\nG\n\x04\
    \x04\n\x02\x06\x12\x04\xd1\x01\x04!\x1a9\x20Random-sized\x20junk\x20to\
    \x20defeat\x20packet\x20size\x20fingerprinting.\n\n\r\n\x05\x04\n\x02\
    \x06\x04\x12\x04\xd1\x01\x04\x0c\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\xd1\
    \x01\r\x12\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\xd1\x01\x13\x1a\n\r\n\x05\
    \x04\n\x02\x06\x03\x12\x04\xd1\x01\x1d\x20\n\x0c\n\x02\x04\x0b\x12\x06\
    \xd4\x01\0\xda\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xd4\x01\x08\x19\n\
    \x0c\n\x04\x04\x0b\x02\0\x12\x04\xd5\x01\x08&\n\r\n\x05\x04\x0b\x02\0\
    \x04\x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xd5\x01\
    \x11\x15\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xd5\x01\x16!\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\xd5\x01$%\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xd6\
    \x01\x08%\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xd6\x01\x08\x10\n\r\n\
    \x05\x04\x0b\x02\x01\x05\x12\x04\xd6\x01\x11\x15\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\xd6\x01\x16\x20\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xd6\x01#$\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xd7\x01\x08'\n\r\n\x05\
    \x04\x0b\x02\x02\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x02\
    \x05\x12\x04\xd7\x01\x11\x15\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xd7\
    \x01\x16\"\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xd7\x01%&\n\x0c\n\x04\
    \x04\x0b\x02\x03\x12\x04\xd8\x01\x04\x1e\n\r\n\x05\x04\x0b\x02\x03\x04\
    \x12\x04\xd8\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xd8\x01\r\
    \x11\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xd8\x01\x12\x19\n\r\n\x05\x04\
    \x0b\x02\x03\x03\x12\x04\xd8\x01\x1c\x1d\n\x0c\n\x04\x04\x0b\x02\x04\x12\
    \x04\xd9\x01\x04!\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\xd9\x01\x04\x0c\
    \n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\xd9\x01\r\x11\n\r\n\x05\x04\x0b\
    \x02\x04\x01\x12\x04\xd9\x01\x12\x1c\n\r\n\x05\x04\x0b\x02\x04\x03\x12\
    \x04\xd9\x01\x1f\x20\n\x0c\n\x02\x04\x0c\x12\x06\xdc\x01\0\x91\x02\x01\n\
    \x0b\n\x03\x04\x0c\x01\x12\x04\xdc\x01\x08\x17\n\x0c\n\x04\x04\x0c\x02\0\
    \x12\x04\xdd\x01\x04)\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xdd\x01\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xdd\x01\r\x13\n\r\n\x05\x04\x0c\
    \x02\0\x01\x12\x04\xdd\x01\x14$\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xdd\
    \x01'(\n\xd0\x01\n\x04\x04\x0c\x02\x01\x12\x04\xe2\x01\x04.\x1a\xc1\x01\
    \x20The\x20client\x20reports\x20its\x20decoy\x20list's\x20version\x20num\
    ber\x20here,\x20which\x20the\n\x20station\x20can\x20use\x20to\x20decide\
    \x20whether\x20to\x20send\x20an\x20updated\x20one.\x20The\x20station\n\
    \x20should\x20always\x20send\x20a\x20list\x20if\x20this\x20field\x20is\
    \x20set\x20to\x200.\n\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xe2\x01\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xe2\x01\r\x13\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\xe2\x01\x14)\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\xe2\x01,-\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xe4\x01\x041\n\r\n\
    \x05\x04\x0c\x02\x02\x04\x12\x04\xe4\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x02\x06\x12\x04\xe4\x01\r\x1b\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xe4\
    \x01\x1c,\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xe4\x01/0\n\x80\x01\n\
    \x04\x04\x0c\x02\x03\x12\x04\xe8\x01\x04$\x1ar\x20The\x20position\x20in\
    \x20the\x20overall\x20session's\x20upload\x20sequence\x20where\x20the\
    \x20current\n\x20YIELD=>ACQUIRE\x20switchover\x20is\x20happening.\n\n\r\
    \n\x05\x04\x0c\x02\x03\x04\x12\x04\xe8\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x03\x05\x12\x04\xe8\x01\r\x13\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xe8\
    \x01\x14\x1f\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xe8\x01\"#\ng\n\x04\
    \x04\x0c\x02\x04\x12\x04\xec\x01\x04+\x1aY\x20High\x20level\x20client\
    \x20library\x20version\x20used\x20for\x20indicating\x20feature\x20suppor\
    t,\x20or\n\x20lack\x20therof.\n\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\
    \xec\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\xec\x01\r\x13\n\r\
    \n\x05\x04\x0c\x02\x04\x01\x12\x04\xec\x01\x14&\n\r\n\x05\x04\x0c\x02\
    \x04\x03\x12\x04\xec\x01)*\nq\n\x04\x04\x0c\x02\x05\x12\x04\xf0\x01\x04'\
    \x1ac\x20List\x20of\x20decoys\x20that\x20client\x20have\x20unsuccessfull\
    y\x20tried\x20in\x20current\x20session.\n\x20Could\x20be\x20sent\x20in\
    \x20chunks\n\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xf0\x01\x04\x0c\n\r\n\
    \x05\x04\x0c\x02\x05\x05\x12\x04\xf0\x01\r\x13\n\r\n\x05\x04\x0c\x02\x05\
    \x01\x12\x04\xf0\x01\x14!\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xf0\x01$\
    &\n\x0c\n\x04\x04\x0c\x02\x06\x12\x04\xf2\x01\x04%\n\r\n\x05\x04\x0c\x02\
    \x06\x04\x12\x04\xf2\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x06\x06\x12\x04\
    \xf2\x01\r\x19\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xf2\x01\x1a\x1f\n\r\
    \n\x05\x04\x0c\x02\x06\x03\x12\x04\xf2\x01\"$\nk\n\x04\x04\x0c\x02\x07\
    \x12\x04\xf5\x01\x04*\x1a]\x20NullTransport,\x20MinTransport,\x20Obfs4Tr\
    ansport,\x20etc.\x20Transport\x20type\x20we\x20want\x20from\x20phantom\
    \x20proxy\n\n\r\n\x05\x04\x0c\x02\x07\x04\x12\x04\xf5\x01\x04\x0c\n\r\n\
    \x05\x04\x0c\x02\x07\x06\x12\x04\xf5\x01\r\x1a\n\r\n\x05\x04\x0c\x02\x07\
    \x01\x12\x04\xf5\x01\x1b$\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\xf5\x01'\
    )\n\x0c\n\x04\x04\x0c\x02\x08\x12\x04\xf7\x01\x047\n\r\n\x05\x04\x0c\x02\
    \x08\x04\x12\x04\xf7\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x08\x06\x12\x04\
    \xf7\x01\r\x20\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\xf7\x01!1\n\r\n\x05\
    \x04\x0c\x02\x08\x03\x12\x04\xf7\x0146\n\xc8\x03\n\x04\x04\x0c\x02\t\x12\
    \x04\xff\x01\x04(\x1a\xb9\x03\x20Station\x20is\x20only\x20required\x20to\
    \x20check\x20this\x20variable\x20during\x20session\x20initialization.\n\
    \x20If\x20set,\x20station\x20must\x20facilitate\x20connection\x20to\x20s\
    aid\x20target\x20by\x20itself,\x20i.e.\x20write\x20into\x20squid\n\x20so\
    cket\x20an\x20HTTP/SOCKS/any\x20other\x20connection\x20request.\n\x20cov\
    ert_address\x20must\x20have\x20exactly\x20one\x20':'\x20colon,\x20that\
    \x20separates\x20host\x20(literal\x20IP\x20address\x20or\n\x20resolvable\
    \x20hostname)\x20and\x20port\n\x20TODO:\x20make\x20it\x20required\x20for\
    \x20initialization,\x20and\x20stop\x20connecting\x20any\x20client\x20str\
    aight\x20to\x20squid?\n\n\r\n\x05\x04\x0c\x02\t\x04\x12\x04\xff\x01\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\xff\x01\r\x13\n\r\n\x05\x04\x0c\
    \x02\t\x01\x12\x04\xff\x01\x14\"\n\r\n\x05\x04\x0c\x02\t\x03\x12\x04\xff\
    \x01%'\nR\n\x04\x04\x0c\x02\n\x12\x04\x82\x02\x042\x1aD\x20Used\x20in\
    \x20dark\x20decoys\x20to\x20signal\x20which\x20dark\x20decoy\x20it\x20wi\
    ll\x20connect\x20to.\n\n\r\n\x05\x04\x0c\x02\n\x04\x12\x04\x82\x02\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\n\x05\x12\x04\x82\x02\r\x13\n\r\n\x05\x04\x0c\
    \x02\n\x01\x12\x04\x82\x02\x14,\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\x82\
    \x02/1\nR\n\x04\x04\x0c\x02\x0b\x12\x04\x85\x02\x04\"\x1aD\x20Used\x20to\
    \x20indicate\x20to\x20server\x20if\x20client\x20is\x20registering\x20v4,\
    \x20v6\x20or\x20both\n\n\r\n\x05\x04\x0c\x02\x0b\x04\x12\x04\x85\x02\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\x0b\x05\x12\x04\x85\x02\r\x11\n\r\n\x05\x04\
    \x0c\x02\x0b\x01\x12\x04\x85\x02\x12\x1c\n\r\n\x05\x04\x0c\x02\x0b\x03\
    \x12\x04\x85\x02\x1f!\n\x0c\n\x04\x04\x0c\x02\x0c\x12\x04\x86\x02\x04\"\
    \n\r\n\x05\x04\x0c\x02\x0c\x04\x12\x04\x86\x02\x04\x0c\n\r\n\x05\x04\x0c\
    \x02\x0c\x05\x12\x04\x86\x02\r\x11\n\r\n\x05\x04\x0c\x02\x0c\x01\x12\x04\
    \x86\x02\x12\x1c\n\r\n\x05\x04\x0c\x02\x0c\x03\x12\x04\x86\x02\x1f!\nD\n\
    \x04\x04\x0c\x02\r\x12\x04\x89\x02\x04*\x1a6\x20A\x20collection\x20of\
    \x20optional\x20flags\x20for\x20the\x20registration.\n\n\r\n\x05\x04\x0c\
    \x02\r\x04\x12\x04\x89\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\r\x06\x12\x04\
    \x89\x02\r\x1e\n\r\n\x05\x04\x0c\x02\r\x01\x12\x04\x89\x02\x1f$\n\r\n\
    \x05\x04\x0c\x02\r\x03\x12\x04\x89\x02')\nq\n\x04\x04\x0c\x02\x0e\x12\
    \x04\x8d\x02\x04-\x1ac\x20Transport\x20Extensions\n\x20TODO(jmwample)\
    \x20-\x20move\x20to\x20WebRTC\x20specific\x20transport\x20params\x20prot\
    obuf\x20message.\n\n\r\n\x05\x04\x0c\x02\x0e\x04\x12\x04\x8d\x02\x04\x0c\
    \n\r\n\x05\x04\x0c\x02\x0e\x06\x12\x04\x8d\x02\r\x19\n\r\n\x05\x04\x0c\
    \x02\x0e\x01\x12\x04\x8d\x02\x1a'\n\r\n\x05\x04\x0c\x02\x0e\x03\x12\x04\
    \x8d\x02*,\nG\n\x04\x04\x0c\x02\x0f\x12\x04\x90\x02\x04!\x1a9\x20Random-\
    sized\x20junk\x20to\x20defeat\x20packet\x20size\x20fingerprinting.\n\n\r\
    \n\x05\x04\x0c\x02\x0f\x04\x12\x04\x90\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x0f\x05\x12\x04\x90\x02\r\x12\n\r\n\x05\x04\x0c\x02\x0f\x01\x12\x04\x90\
    \x02\x13\x1a\n\r\n\x05\x04\x0c\x02\x0f\x03\x12\x04\x90\x02\x1d\x20\n\x0c\
    \n\x02\x04\r\x12\x06\x93\x02\0\x98\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\
    \x93\x02\x08\x1e\n\xcb\x01\n\x04\x04\r\x02\0\x12\x04\x97\x02\x04*\x1a\
    \xbc\x01\x20Indicates\x20whether\x20the\x20client\x20has\x20elected\x20t\
    o\x20use\x20destination\x20port\n\x20randomization.\x20Should\x20be\x20c\
    hecked\x20against\x20selected\x20transport\x20to\x20ensure\n\x20that\x20\
    destination\x20port\x20randomization\x20is\x20supported.\n\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\x97\x02\x04\x0c\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \x97\x02\r\x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x97\x02\x12$\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\x97\x02')\n\x0c\n\x02\x05\x06\x12\x06\x9a\x02\0\
    \xa2\x02\x01\n\x0b\n\x03\x05\x06\x01\x12\x04\x9a\x02\x05\x17\n\x0c\n\x04\
    \x05\x06\x02\0\x12\x04\x9b\x02\x02\x12\n\r\n\x05\x05\x06\x02\0\x01\x12\
    \x04\x9b\x02\x02\r\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\x9b\x02\x10\x11\n\
    \x0c\n\x04\x05\x06\x02\x01\x12\x04\x9c\x02\x08\x15\n\r\n\x05\x05\x06\x02\
    \x01\x01\x12\x04\x9c\x02\x08\x10\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\
    \x9c\x02\x13\x14\n\x0c\n\x04\x05\x06\x02\x02\x12\x04\x9d\x02\x08\x10\n\r\
    \n\x05\x05\x06\x02\x02\x01\x12\x04\x9d\x02\x08\x0b\n\r\n\x05\x05\x06\x02\
    \x02\x02\x12\x04\x9d\x02\x0e\x0f\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\x9e\
    \x02\x02\x16\n\r\n\x05\x05\x06\x02\x03\x01\x12\x04\x9e\x02\x02\x11\n\r\n\
    \x05\x05\x06\x02\x03\x02\x12\x04\x9e\x02\x14\x15\n\x0c\n\x04\x05\x06\x02\
    \x04\x12\x04\x9f\x02\x02\x17\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\x9f\
    \x02\x02\x12\n\r\n\x05\x05\x06\x02\x04\x02\x12\x04\x9f\x02\x15\x16\n\x0c\
    \n\x04\x05\x06\x02\x05\x12\x04\xa0\x02\x02\n\n\r\n\x05\x05\x06\x02\x05\
    \x01\x12\x04\xa0\x02\x02\x05\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xa0\
    \x02\x08\t\n\x0c\n\x04\x05\x06\x02\x06\x12\x04\xa1\x02\x02\x17\n\r\n\x05\
    \x05\x06\x02\x06\x01\x12\x04\xa1\x02\x02\x12\n\r\n\x05\x05\x06\x02\x06\
    \x02\x12\x04\xa1\x02\x15\x16\n\x0c\n\x02\x04\x0e\x12\x06\xa4\x02\0\xb0\
    \x02\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa4\x02\x08\x12\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\xa5\x02\x02#\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xa5\
    \x02\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xa5\x02\x0b\x10\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xa5\x02\x11\x1e\n\r\n\x05\x04\x0e\x02\0\x03\
    \x12\x04\xa5\x02!\"\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xa6\x02\x08:\n\r\
    \n\x05\x04\x0e\x02\x01\x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\xa6\x02\x11\x20\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \xa6\x02!5\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa6\x0289\n\x0c\n\x04\
    \x04\x0e\x02\x02\x12\x04\xa7\x02\x026\n\r\n\x05\x04\x0e\x02\x02\x04\x12\
    \x04\xa7\x02\x02\n\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\xa7\x02\x0b\x1d\
    \n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa7\x02\x1e1\n\r\n\x05\x04\x0e\
    \x02\x02\x03\x12\x04\xa7\x0245\nC\n\x04\x04\x0e\x02\x03\x12\x04\xaa\x02\
    \x02*\x1a5\x20client\x20source\x20address\x20when\x20receiving\x20a\x20r\
    egistration\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xaa\x02\x02\n\n\r\n\
    \x05\x04\x0e\x02\x03\x05\x12\x04\xaa\x02\x0b\x10\n\r\n\x05\x04\x0e\x02\
    \x03\x01\x12\x04\xaa\x02\x11%\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xaa\
    \x02()\nH\n\x04\x04\x0e\x02\x04\x12\x04\xad\x02\x02#\x1a:\x20Decoy\x20ad\
    dress\x20used\x20when\x20registering\x20over\x20Decoy\x20registrar\n\n\r\
    \n\x05\x04\x0e\x02\x04\x04\x12\x04\xad\x02\x02\n\n\r\n\x05\x04\x0e\x02\
    \x04\x05\x12\x04\xad\x02\x0b\x10\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \xad\x02\x11\x1e\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xad\x02!\"\n\x0c\
    \n\x04\x04\x0e\x02\x05\x12\x04\xaf\x02\x02:\n\r\n\x05\x04\x0e\x02\x05\
    \x04\x12\x04\xaf\x02\x02\n\n\r\n\x05\x04\x0e\x02\x05\x06\x12\x04\xaf\x02\
    \x0b\x1f\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xaf\x02\x205\n\r\n\x05\
    \x04\x0e\x02\x05\x03\x12\x04\xaf\x0289\n\x0c\n\x02\x04\x0f\x12\x06\xb2\
    \x02\0\xbe\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xb2\x02\x08\x14\n9\n\
    \x04\x04\x0f\x02\0\x12\x04\xb3\x02\x04.\"+\x20how\x20many\x20decoys\x20w\
    ere\x20tried\x20before\x20success\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\
    \xb3\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xb3\x02\r\x13\n\r\n\
    \x05\x04\x0f\x02\0\x01\x12\x04\xb3\x02\x14(\n\r\n\x05\x04\x0f\x02\0\x03\
    \x12\x04\xb3\x02+-\nm\n\x04\x04\x0f\x02\x01\x12\x04\xb8\x02\x04/\x1a\x1e\
    \x20Applicable\x20to\x20whole\x20session:\n\"\x1a\x20includes\x20failed\
    \x20attempts\n2#\x20Timings\x20below\x20are\x20in\x20milliseconds\n\n\r\
    \n\x05\x04\x0f\x02\x01\x04\x12\x04\xb8\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\
    \x01\x05\x12\x04\xb8\x02\r\x13\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xb8\
    \x02\x14)\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xb8\x02,.\nR\n\x04\x04\
    \x0f\x02\x02\x12\x04\xbb\x02\x04(\x1a\x1f\x20Last\x20(i.e.\x20successful\
    )\x20decoy:\n\"#\x20measured\x20during\x20initial\x20handshake\n\n\r\n\
    \x05\x04\x0f\x02\x02\x04\x12\x04\xbb\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\
    \x02\x05\x12\x04\xbb\x02\r\x13\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xbb\
    \x02\x14\"\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xbb\x02%'\n%\n\x04\x04\
    \x0f\x02\x03\x12\x04\xbc\x02\x04&\"\x17\x20includes\x20tcp\x20to\x20deco\
    y\n\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\xbc\x02\x04\x0c\n\r\n\x05\x04\
    \x0f\x02\x03\x05\x12\x04\xbc\x02\r\x13\n\r\n\x05\x04\x0f\x02\x03\x01\x12\
    \x04\xbc\x02\x14\x20\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xbc\x02#%\nB\
    \n\x04\x04\x0f\x02\x04\x12\x04\xbd\x02\x04&\"4\x20measured\x20when\x20es\
    tablishing\x20tcp\x20connection\x20to\x20decot\n\n\r\n\x05\x04\x0f\x02\
    \x04\x04\x12\x04\xbd\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\
    \xbd\x02\r\x13\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xbd\x02\x14\x20\n\r\
    \n\x05\x04\x0f\x02\x04\x03\x12\x04\xbd\x02#%\n\x0c\n\x02\x05\x07\x12\x06\
    \xc0\x02\0\xc5\x02\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\xc0\x02\x05\x16\n\
    \x0c\n\x04\x05\x07\x02\0\x12\x04\xc1\x02\x04\x10\n\r\n\x05\x05\x07\x02\0\
    \x01\x12\x04\xc1\x02\x04\x0b\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\xc1\x02\
    \x0e\x0f\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xc2\x02\x04\x0c\n\r\n\x05\
    \x05\x07\x02\x01\x01\x12\x04\xc2\x02\x04\x07\n\r\n\x05\x05\x07\x02\x01\
    \x02\x12\x04\xc2\x02\n\x0b\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\xc3\x02\
    \x04\x0f\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xc3\x02\x04\n\n\r\n\x05\
    \x05\x07\x02\x02\x02\x12\x04\xc3\x02\r\x0e\n\x0c\n\x04\x05\x07\x02\x03\
    \x12\x04\xc4\x02\x04\x0e\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\xc4\x02\
    \x04\t\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\xc4\x02\x0c\r\n\x0c\n\x02\
    \x05\x08\x12\x06\xc7\x02\0\xcb\x02\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\
    \xc7\x02\x05\x0c\n\x0c\n\x04\x05\x08\x02\0\x12\x04\xc8\x02\x04\x0c\n\r\n\
    \x05\x05\x08\x02\0\x01\x12\x04\xc8\x02\x04\x07\n\r\n\x05\x05\x08\x02\0\
    \x02\x12\x04\xc8\x02\n\x0b\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xc9\x02\
    \x04\x0c\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\xc9\x02\x04\x07\n\r\n\x05\
    \x05\x08\x02\x01\x02\x12\x04\xc9\x02\n\x0b\n\x0c\n\x04\x05\x08\x02\x02\
    \x12\x04\xca\x02\x04\x0c\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\xca\x02\
    \x04\x07\n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\xca\x02\n\x0b\n\x0c\n\x02\
    \x04\x10\x12\x06\xcd\x02\0\xd8\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \xcd\x02\x08\x19\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xce\x02\x04#\n\r\n\
    \x05\x04\x10\x02\0\x04\x12\x04\xce\x02\x04\x0c\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\xce\x02\r\x13\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xce\x02\
    \x14\x1e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xce\x02!\"\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\xcf\x02\x04\"\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\
    \xcf\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xcf\x02\r\x13\n\r\
    \n\x05\x04\x10\x02\x01\x01\x12\x04\xcf\x02\x14\x1d\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\xcf\x02\x20!\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xd1\
    \x02\x04#\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xd1\x02\x04\x0c\n\r\n\
    \x05\x04\x10\x02\x02\x05\x12\x04\xd1\x02\r\x13\n\r\n\x05\x04\x10\x02\x02\
    \x01\x12\x04\xd1\x02\x14\x1e\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd1\
    \x02!\"\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\xd3\x02\x04-\n\r\n\x05\x04\
    \x10\x02\x03\x04\x12\x04\xd3\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x03\x06\
    \x12\x04\xd3\x02\r\x1e\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xd3\x02\x1f\
    (\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xd3\x02+,\n\x0c\n\x04\x04\x10\
    \x02\x04\x12\x04\xd5\x02\x04\"\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\xd5\
    \x02\x04\x0c\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xd5\x02\r\x13\n\r\n\
    \x05\x04\x10\x02\x04\x01\x12\x04\xd5\x02\x14\x1c\n\r\n\x05\x04\x10\x02\
    \x04\x03\x12\x04\xd5\x02\x1f!\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xd6\
    \x02\x04\"\n\r\n\x05\x04\x10\x02\x05\x04\x12\x04\xd6\x02\x04\x0c\n\r\n\
    \x05\x04\x10\x02\x05\x05\x12\x04\xd6\x02\r\x13\n\r\n\x05\x04\x10\x02\x05\
    \x01\x12\x04\xd6\x02\x14\x1c\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xd6\
    \x02\x1f!\n\x0c\n\x04\x04\x10\x02\x06\x12\x04\xd7\x02\x04\x20\n\r\n\x05\
    \x04\x10\x02\x06\x04\x12\x04\xd7\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x06\
    \x06\x12\x04\xd7\x02\r\x14\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xd7\x02\
    \x15\x1a\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\xd7\x02\x1d\x1f\nT\n\x02\
    \x04\x11\x12\x06\xdb\x02\0\xec\x02\x01\x1aF\x20Adding\x20message\x20resp\
    onse\x20from\x20Station\x20to\x20Client\x20for\x20bidirectional\x20API\n\
    \n\x0b\n\x03\x04\x11\x01\x12\x04\xdb\x02\x08\x1c\n\x0c\n\x04\x04\x11\x02\
    \0\x12\x04\xdc\x02\x02\x20\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xdc\x02\
    \x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xdc\x02\x0b\x12\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\xdc\x02\x13\x1b\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\xdc\x02\x1e\x1f\n?\n\x04\x04\x11\x02\x01\x12\x04\xde\x02\x02\x1e\
    \x1a1\x20The\x20128-bit\x20ipv6\x20address,\x20in\x20network\x20byte\x20\
    order\n\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xde\x02\x02\n\n\r\n\x05\
    \x04\x11\x02\x01\x05\x12\x04\xde\x02\x0b\x10\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xde\x02\x11\x19\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xde\
    \x02\x1c\x1d\n,\n\x04\x04\x11\x02\x02\x12\x04\xe1\x02\x02\x1f\x1a\x1e\
    \x20Respond\x20with\x20randomized\x20port\n\n\r\n\x05\x04\x11\x02\x02\
    \x04\x12\x04\xe1\x02\x02\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xe1\x02\
    \x0b\x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xe1\x02\x12\x1a\n\r\n\x05\
    \x04\x11\x02\x02\x03\x12\x04\xe1\x02\x1d\x1e\nd\n\x04\x04\x11\x02\x03\
    \x12\x04\xe5\x02\x02\"\x1aV\x20Future:\x20station\x20provides\x20client\
    \x20with\x20secret,\x20want\x20chanel\x20present\n\x20Leave\x20null\x20f\
    or\x20now\n\n\r\n\x05\x04\x11\x02\x03\x04\x12\x04\xe5\x02\x02\n\n\r\n\
    \x05\x04\x11\x02\x03\x05\x12\x04\xe5\x02\x0b\x10\n\r\n\x05\x04\x11\x02\
    \x03\x01\x12\x04\xe5\x02\x11\x1d\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\
    \xe5\x02\x20!\nA\n\x04\x04\x11\x02\x04\x12\x04\xe8\x02\x02\x1c\x1a3\x20I\
    f\x20registration\x20wrong,\x20populate\x20this\x20error\x20string\n\n\r\
    \n\x05\x04\x11\x02\x04\x04\x12\x04\xe8\x02\x02\n\n\r\n\x05\x04\x11\x02\
    \x04\x05\x12\x04\xe8\x02\x0b\x11\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\
    \xe8\x02\x12\x17\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xe8\x02\x1a\x1b\n\
    +\n\x04\x04\x11\x02\x05\x12\x04\xeb\x02\x02%\x1a\x1d\x20ClientConf\x20fi\
    eld\x20(optional)\n\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xeb\x02\x02\n\
    \n\r\n\x05\x04\x11\x02\x05\x06\x12\x04\xeb\x02\x0b\x15\n\r\n\x05\x04\x11\
    \x02\x05\x01\x12\x04\xeb\x02\x16\x20\n\r\n\x05\x04\x11\x02\x05\x03\x12\
    \x04\xeb\x02#$\n!\n\x02\x04\x12\x12\x06\xef\x02\0\xf3\x02\x01\x1a\x13\
    \x20response\x20from\x20dns\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xef\x02\
    \x08\x13\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xf0\x02\x04\x1e\n\r\n\x05\x04\
    \x12\x02\0\x04\x12\x04\xf0\x02\x04\x0c\n\r\n\x05\x04\x12\x02\0\x05\x12\
    \x04\xf0\x02\r\x11\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf0\x02\x12\x19\n\
    \r\n\x05\x04\x12\x02\0\x03\x12\x04\xf0\x02\x1c\x1d\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xf1\x02\x04*\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xf1\
    \x02\x04\x0c\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xf1\x02\r\x11\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xf1\x02\x12%\n\r\n\x05\x04\x12\x02\x01\
    \x03\x12\x04\xf1\x02()\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xf2\x02\x04=\
    \n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xf2\x02\x04\x0c\n\r\n\x05\x04\x12\
    \x02\x02\x06\x12\x04\xf2\x02\r!\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\
    \xf2\x02\"8\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xf2\x02;<\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
